<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>多线程基础总结 | 技术小站</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="logo.ico">
    <meta name="description" content="生活不止眼前的代码，还有迈向田野的步伐">
    
    <link rel="preload" href="/blog/assets/css/0.styles.ae2fffaf.css" as="style"><link rel="preload" href="/blog/assets/js/app.69fb67a1.js" as="script"><link rel="preload" href="/blog/assets/js/2.4016a2d7.js" as="script"><link rel="preload" href="/blog/assets/js/9.a57e59ce.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.67bef570.js"><link rel="prefetch" href="/blog/assets/js/11.fe8c8fa3.js"><link rel="prefetch" href="/blog/assets/js/12.75dccbee.js"><link rel="prefetch" href="/blog/assets/js/13.44b0bfe8.js"><link rel="prefetch" href="/blog/assets/js/14.9346e768.js"><link rel="prefetch" href="/blog/assets/js/15.e83fb7bf.js"><link rel="prefetch" href="/blog/assets/js/16.85958add.js"><link rel="prefetch" href="/blog/assets/js/17.fe068445.js"><link rel="prefetch" href="/blog/assets/js/18.6d981bf2.js"><link rel="prefetch" href="/blog/assets/js/19.5cfcd256.js"><link rel="prefetch" href="/blog/assets/js/20.b617c2ee.js"><link rel="prefetch" href="/blog/assets/js/21.8faec1e4.js"><link rel="prefetch" href="/blog/assets/js/22.b5ecd719.js"><link rel="prefetch" href="/blog/assets/js/23.908cdf8b.js"><link rel="prefetch" href="/blog/assets/js/24.bb07b8a3.js"><link rel="prefetch" href="/blog/assets/js/25.12239f0c.js"><link rel="prefetch" href="/blog/assets/js/26.f0612eeb.js"><link rel="prefetch" href="/blog/assets/js/27.9f9faf8f.js"><link rel="prefetch" href="/blog/assets/js/28.09413d35.js"><link rel="prefetch" href="/blog/assets/js/29.c95d8f86.js"><link rel="prefetch" href="/blog/assets/js/3.af3a3e6c.js"><link rel="prefetch" href="/blog/assets/js/30.3f05f0e2.js"><link rel="prefetch" href="/blog/assets/js/31.5e64ba2b.js"><link rel="prefetch" href="/blog/assets/js/32.3b6ae82a.js"><link rel="prefetch" href="/blog/assets/js/33.0b289b40.js"><link rel="prefetch" href="/blog/assets/js/34.262cbd9c.js"><link rel="prefetch" href="/blog/assets/js/35.efdad6b2.js"><link rel="prefetch" href="/blog/assets/js/36.77d34ce4.js"><link rel="prefetch" href="/blog/assets/js/37.df81f2ee.js"><link rel="prefetch" href="/blog/assets/js/38.2be04f95.js"><link rel="prefetch" href="/blog/assets/js/39.7ccaa519.js"><link rel="prefetch" href="/blog/assets/js/4.a3bbc4b9.js"><link rel="prefetch" href="/blog/assets/js/40.027f317c.js"><link rel="prefetch" href="/blog/assets/js/41.d1d909a0.js"><link rel="prefetch" href="/blog/assets/js/42.d7dd1430.js"><link rel="prefetch" href="/blog/assets/js/43.6cd158cc.js"><link rel="prefetch" href="/blog/assets/js/44.b6b88860.js"><link rel="prefetch" href="/blog/assets/js/45.1495d9ad.js"><link rel="prefetch" href="/blog/assets/js/46.2e119b51.js"><link rel="prefetch" href="/blog/assets/js/47.86b36b7a.js"><link rel="prefetch" href="/blog/assets/js/48.83522760.js"><link rel="prefetch" href="/blog/assets/js/49.0388f364.js"><link rel="prefetch" href="/blog/assets/js/5.0f95da72.js"><link rel="prefetch" href="/blog/assets/js/50.d2d4b56a.js"><link rel="prefetch" href="/blog/assets/js/51.147e59d2.js"><link rel="prefetch" href="/blog/assets/js/52.36d01276.js"><link rel="prefetch" href="/blog/assets/js/53.b8607bb7.js"><link rel="prefetch" href="/blog/assets/js/54.e0f73188.js"><link rel="prefetch" href="/blog/assets/js/55.5950cd7e.js"><link rel="prefetch" href="/blog/assets/js/56.2bff181f.js"><link rel="prefetch" href="/blog/assets/js/6.621b7d8e.js"><link rel="prefetch" href="/blog/assets/js/7.1250f6d4.js"><link rel="prefetch" href="/blog/assets/js/8.33180036.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.ae2fffaf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">技术小站</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/concurrent/" class="nav-link router-link-active">
  高并发
</a></div><div class="nav-item"><a href="/blog/design/" class="nav-link">
  设计模式
</a></div><div class="nav-item"><a href="/blog/jvm/" class="nav-link">
  JVM
</a></div><div class="nav-item"><a href="/blog/server/" class="nav-link">
  服务器向
</a></div><div class="nav-item"><a href="/blog/util/" class="nav-link">
  工具向
</a></div><div class="nav-item"><a href="/blog/personal/" class="nav-link">
  关于我
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/concurrent/" class="nav-link router-link-active">
  高并发
</a></div><div class="nav-item"><a href="/blog/design/" class="nav-link">
  设计模式
</a></div><div class="nav-item"><a href="/blog/jvm/" class="nav-link">
  JVM
</a></div><div class="nav-item"><a href="/blog/server/" class="nav-link">
  服务器向
</a></div><div class="nav-item"><a href="/blog/util/" class="nav-link">
  工具向
</a></div><div class="nav-item"><a href="/blog/personal/" class="nav-link">
  关于我
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>一、多线程基础</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/concurrent/basic/多线程基础.html" class="active sidebar-link">多线程基础总结</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/concurrent/basic/多线程基础.html#多线程基础总结" class="sidebar-link">多线程基础总结</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/concurrent/basic/多线程基础.html#多线程三大特性" class="sidebar-link">多线程三大特性</a></li><li class="sidebar-sub-header"><a href="/blog/concurrent/basic/多线程基础.html#线程创建的三种方式" class="sidebar-link">线程创建的三种方式</a></li><li class="sidebar-sub-header"><a href="/blog/concurrent/basic/多线程基础.html#线程停止" class="sidebar-link">线程停止</a></li><li class="sidebar-sub-header"><a href="/blog/concurrent/basic/多线程基础.html#线程中断" class="sidebar-link">线程中断</a></li><li class="sidebar-sub-header"><a href="/blog/concurrent/basic/多线程基础.html#线程等待-wait-和通知-notify" class="sidebar-link">线程等待(wait)和通知(notify)</a></li><li class="sidebar-sub-header"><a href="/blog/concurrent/basic/多线程基础.html#挂起-suspend-和继续执行-resume" class="sidebar-link">挂起(suspend)和继续执行(resume)</a></li><li class="sidebar-sub-header"><a href="/blog/concurrent/basic/多线程基础.html#等待线程结束-join-和-礼让线程-yeild" class="sidebar-link">等待线程结束(join) 和 礼让线程(yeild)</a></li><li class="sidebar-sub-header"><a href="/blog/concurrent/basic/多线程基础.html#volatile-关键字" class="sidebar-link">volatile 关键字</a></li><li class="sidebar-sub-header"><a href="/blog/concurrent/basic/多线程基础.html#线程组" class="sidebar-link">线程组</a></li><li class="sidebar-sub-header"><a href="/blog/concurrent/basic/多线程基础.html#守护线程" class="sidebar-link">守护线程</a></li><li class="sidebar-sub-header"><a href="/blog/concurrent/basic/多线程基础.html#线程优先级" class="sidebar-link">线程优先级</a></li></ul></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>二、线程池</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>三、synchronized</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>四、锁</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>五、并发控制工具</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>六、并发容器</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="多线程基础总结"><a href="#多线程基础总结" class="header-anchor">#</a> 多线程基础总结</h2> <h3 id="多线程三大特性"><a href="#多线程三大特性" class="header-anchor">#</a> 多线程三大特性</h3> <h4 id="_1-原子性"><a href="#_1-原子性" class="header-anchor">#</a> 1. 原子性</h4> <p>原子性是指在一个操作中就是 CPU 不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。
如果一个操作是原子性的，那么多线程并发的情况下，就不会出现变量被修改的情况。</p> <ul><li><p>比如 <code>a = 0</code>；（ a  非 <code>long</code> 和 <code>double</code> 类型） 这个操作是不可分割的，那么我们说这个操作是原子操作。</p></li> <li><p>再比如 <code>a++</code> ； 这个操作实际是 <code>a = a + 1</code> ；是可分割的，所以它不是一个原子操作。</p></li></ul> <p>非原子操作都会存在线程安全问题，需要我们使用同步技术（ <code>sychronized</code> 等）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。</p> <p><code>Java</code> 的 <code>concurrent</code> 包下提供了一些原子类，我们可以通过阅读 API 来了解这些原子类的用法。</p> <p>比如：<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicReference</code>等。</p> <p>（由 <code>Java</code> 内存模型来直接保证的原子性变量操作包括 <code>read</code>、 <code>load</code>、 <code>use</code>、 <code>assign</code>、 <code>store</code> 和 <code>write</code> 六个，大致可以认为基础数据类型的访问和读写是具备原子性的。如果应用场景需要一个更大范围的原子性保证，<code>Java</code> 内存模型还提供了 <code>lock</code> 和 <code>unlock</code> 操作来满足这种需求，尽管虚拟机未把 <code>lock</code> 与 <code>unlock</code> 操作直接开放给用户使用，但是却提供了更高层次的字节码指令 <code>monitorenter</code> 和 <code>monitorexit</code> 来隐匿地使用这两个操作，这两个字节码指令反映到 <code>Java</code> 代码中就是同步关键字 <code>synchronized</code>，因此在 <code>synchronized</code> 块之间的操作也具备原子性。）</p> <p><strong>1.1  Java 中的原子性</strong></p> <ul><li><p>除了 <code>long</code> 和 <code>double</code> 类型的赋值操作。</p> <ul><li><p>原因：</p> <p>在 32 位长度操作系统中，<code>long</code> 和 <code>double</code> 类型的赋值不是原子操作。
因为 <code>long</code> 和 <code>double</code> 都是 64 位的，在 32 位系统上，对 <code>long</code> 和 <code>double</code> 类型的数据进行读写都要分为两步完成。若同时两个线程同时写一个变量内存，一个写低 8 位，一个写高 8 位，就会导致无效数据出现。</p></li> <li><p>解决办法：</p> <p><code>long</code> 和 <code>double</code> 类型声明为 <code>volatile</code> 。<code>Java</code> 的内存模型保证声明为 <code>volatile</code> 的 <code>long</code> 和 <code>double</code> 变量的 <code>get</code> 和 <code>set</code> 操作是原子的。</p></li></ul></li> <li><p>所有引用 <code>reference</code> 的赋值操作(如 <code>AtomicReference</code> )。</p></li> <li><p><code>java.concurrent.Atomic.*</code> 包中所有类的一切操作。</p></li></ul> <p><strong>1.2  如何保证原子性</strong></p> <ul><li>使用 <code>synchronized</code> 关键字定义同步代码块或同步方法来保证原子性。</li> <li>受用 <code>lock</code> 加锁来保证原子性。</li> <li>使用 <code>Atomic</code> 相关类保证原子性。</li></ul> <p><strong>1.3  参考链接</strong></p> <p><a href="https://gitee.com/zztiyjw/concurrent-practice/blob/master/src/test/java/com/albert/concurrent/book/chapterone/ThreadAtomicity_01.java" target="_blank" rel="noopener noreferrer">原子性练习<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <hr> <h4 id="_2-可见性"><a href="#_2-可见性" class="header-anchor">#</a> 2. 可见性</h4> <p>当一个线程修改了共享变量的值，其他线程能够看到修改的值。<code>Java</code> 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方法来实现可见性的。</p> <p><strong>2.1  如何保证可见性</strong></p> <ul><li>通过 <code>volatile</code> 关键字标记变量保证可见性。</li> <li>使用 <code>synchronized</code> 关键字定义同步代码块或同步方法来保证可见性。</li> <li>使用 <code>lock</code> 加锁来保证可见性。</li> <li>使用 <code>Atomic</code> 相关类保证可见性。</li> <li>通过 <code>final</code> 关键字来保证可见性。</li></ul> <hr> <h4 id="_3-有序性"><a href="#_3-有序性" class="header-anchor">#</a> 3. 有序性</h4> <p>即程序执行的顺序按照代码的先后顺序执行。<code>java</code> 存在指令重排，所以存在有序性问题。</p> <p><strong>3.1 如何保证有序性</strong></p> <ul><li>通过 <code>volatile</code> 关键字标记变量保证有序性。</li> <li>使用 <code>synchronized</code> 关键字定义同步代码块或同步方法来保证有序性。</li> <li>使用 <code>lock</code> 加锁来保证有序性。</li></ul> <p>参考博客：<a href="https://www.cnblogs.com/weixuqin/p/11424688.html" target="_blank" rel="noopener noreferrer">并发三大特性<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <hr> <h3 id="线程创建的三种方式"><a href="#线程创建的三种方式" class="header-anchor">#</a> 线程创建的三种方式</h3> <h4 id="_1-thread"><a href="#_1-thread" class="header-anchor">#</a> 1. Thread</h4> <p>不推荐使用。<code>Java</code> 是单继承，所以不推荐使用继承来实现并发类。
注意：直接调用 <code>run()</code> 方法，相当于调用了该方法，没有开启新线程。只有调用 <code>start()</code> 方法，才是开启了一个新线程和主线程争夺资源。</p> <h4 id="_2-ruunable"><a href="#_2-ruunable" class="header-anchor">#</a> 2. Ruunable</h4> <p>推荐使用。没有结果返回，可以作为 <code>Thread</code> 类的参数创建线程，也可以与线程池捆绑使用。</p> <h4 id="_3-callable"><a href="#_3-callable" class="header-anchor">#</a> 3. Callable</h4> <p>推荐使用，有结果返回。可与 <code>FutureTask</code> 搭配使用，也可以与线程池捆绑使用，搭配 <code>Future</code> 获取任务执行完成的返回值。</p> <p>参考：<a href="https://gitee.com/zztiyjw/concurrent-practice/blob/master/src/main/java/com/albert/concurrent/basic/create" target="_blank" rel="noopener noreferrer">线程的三种创建方式练习目录<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <hr> <h3 id="线程停止"><a href="#线程停止" class="header-anchor">#</a> 线程停止</h3> <h4 id="停止方法"><a href="#停止方法" class="header-anchor">#</a> 停止方法</h4> <ul><li><p><code>stop()</code> 方法(不推荐使用)
<code>stop()</code> 方法被调用的时候，会直接释放线程拥有的锁对象，这样会破坏临界区的原子性。</p></li> <li><p><code>stop()</code> 方法的优化
优化 <code>stop()</code> 方法，在调用时不直接释放锁资源，保证临界区资源执行完成后再释放锁资源。</p></li></ul> <h4 id="参考链接"><a href="#参考链接" class="header-anchor">#</a> 参考链接</h4> <ul><li><a href="https://gitee.com/zztiyjw/concurrent-practice/blob/master/src/test/java/com/albert/concurrent/book/chaptertwo/ThreadStop_01.java" target="_blank" rel="noopener noreferrer">stop 方法的练习<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://gitee.com/zztiyjw/concurrent-practice/blob/master/src/test/java/com/albert/concurrent/book/chaptertwo/ThreadStopResolve_02.java" target="_blank" rel="noopener noreferrer">stop 方法的优化练习<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <hr> <h3 id="线程中断"><a href="#线程中断" class="header-anchor">#</a> 线程中断</h3> <p>线程中断并不会立即将线程退出，而是发出一个中断信号。目标线程接收中断信号后，如何退出由目标线程的逻辑决定。</p> <h4 id="常用方法"><a href="#常用方法" class="header-anchor">#</a> 常用方法</h4> <p><code>Java</code> 中 <code>Thread</code> 类提供了关于线程中断的三个方法：</p> <ul><li><code>interrupt()</code> : 中断线程。</li> <li><code>isInterrupted()</code> : 判断线程中断的状态。</li> <li><code>interrupted()</code> : 判断线程中断的状态，并重置中断标志。实际是调用了 <code>isInterrupted()</code> 方法，并传入中断标志数据。</li></ul> <h4 id="参考链接-2"><a href="#参考链接-2" class="header-anchor">#</a> 参考链接</h4> <p><a href="https://gitee.com/zztiyjw/concurrent-practice/blob/master/src/test/java/com/albert/concurrent/book/chaptertwo/ThreadInterruption_03.java" target="_blank" rel="noopener noreferrer">线程中断的相关练习<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <hr> <h3 id="线程等待-wait-和通知-notify"><a href="#线程等待-wait-和通知-notify" class="header-anchor">#</a> 线程等待(wait)和通知(notify)</h3> <h4 id="常用方法-2"><a href="#常用方法-2" class="header-anchor">#</a> 常用方法</h4> <p><code>wait()</code> 方法和 <code>notify()</code> 方法是 <code>Object</code> 类里的方法，意味着任何对象都可以调用这两个方法。</p> <ul><li><code>wait()</code> 方法使用时会释放锁对象，进入等待。</li> <li><code>notify()</code>会随机唤醒一个等待的线程，被唤醒的线程会重新竞争锁对象。</li> <li>还有一个方法<code>notifyAll()</code> ，会唤醒所有进入等待的线程。</li></ul> <p>注意：不论是 <code>wait()</code> 方法还是 <code>notify()</code> 方法，都需要获取锁对象才能调用。</p> <h4 id="参考链接-3"><a href="#参考链接-3" class="header-anchor">#</a> 参考链接</h4> <p><a href="https://gitee.com/zztiyjw/concurrent-practice/blob/master/src/test/java/com/albert/concurrent/book/chaptertwo/ThreadWaitAndNotify_04.java" target="_blank" rel="noopener noreferrer">wait 和 notify的相关练习<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="扩展知识"><a href="#扩展知识" class="header-anchor">#</a> 扩展知识</h4> <ol><li><code>Thread.sleep()</code> 方法和 <code>Object.wait()</code> 一样也可以让线程等待，而 <code>sleep()</code> 可以指定等待时间，<code>wait()</code> 可以被唤醒。还有一个主要区别，<code>wait()</code> 会释放目标对象的锁，而 <code>sleep()</code> 不会释放任何资源。</li> <li><code>Lock</code> 有一个好搭档 <code>Condition</code> 实现的功能和 <code>wait</code> 和 <code>notify</code> 基本一致，只不过 <code>Condition</code> 依赖于 <code>Lock</code>。</li></ol> <hr> <h3 id="挂起-suspend-和继续执行-resume"><a href="#挂起-suspend-和继续执行-resume" class="header-anchor">#</a> 挂起(suspend)和继续执行(resume)</h3> <h4 id="常用方法-3"><a href="#常用方法-3" class="header-anchor">#</a> 常用方法</h4> <ul><li><code>suspend()</code> 会阻塞当前线程，但是不会释放锁对象。（不推荐使用，推荐使用并发工具 - <code>LockSupport</code> ）</li> <li><code>resume()</code> 会取消当前线程的阻塞状态。</li></ul> <p>注意：<code>Thread.suspend()</code> 阻塞当前线程时，不会释放锁对象。若不调用 <code>resume()</code> 方法，或者在 <code>suspend()</code> 方法调用之前调用了 <code>resume()</code> 方法，则该线程会一直持有锁对象，进而造成死锁。</p> <h4 id="参考链接-4"><a href="#参考链接-4" class="header-anchor">#</a> 参考链接</h4> <p><a href="https://gitee.com/zztiyjw/concurrent-practice/blob/master/src/test/java/com/albert/concurrent/book/chaptertwo/ThreadSuspendAndResume_05.java" target="_blank" rel="noopener noreferrer">suspend 和 resume 的相关练习<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <hr> <h3 id="等待线程结束-join-和-礼让线程-yeild"><a href="#等待线程结束-join-和-礼让线程-yeild" class="header-anchor">#</a> 等待线程结束(join) 和 礼让线程(yeild)</h3> <ul><li><code>join()</code> : 等待调用线程执行结束。</li></ul> <p><strong>源码分析</strong></p> <p><code>join()</code> 实际上是调用了 <code>wait()</code> 方法，在当前线程实例上实现了线程等待。而线程在执行完成之前会调用 <code>notifyAll()</code> 方法通知等待线程继续执行。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token keyword">long</span> millis<span class="token punctuation">)</span>
    <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token keyword">long</span> base <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> now <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>millis <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">&quot;timeout value is negative&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>millis <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">isAlive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">long</span> delay <span class="token operator">=</span> millis <span class="token operator">-</span> now<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>delay <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token function">wait</span><span class="token punctuation">(</span>delay<span class="token punctuation">)</span><span class="token punctuation">;</span>
                now <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> base<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
		
		<span class="token comment">//通知本地方法实现线程等待</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><ul><li><code>yeild()</code> 方法：让出线程资源,但是会重新竞争。</li></ul> <p>参考：<a href="https://gitee.com/zztiyjw/concurrent-practice/blob/master/src/test/java/com/albert/concurrent/book/chaptertwo/ThreadJoin_06.java" target="_blank" rel="noopener noreferrer">join 和 yeild 的练习<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <hr> <h3 id="volatile-关键字"><a href="#volatile-关键字" class="header-anchor">#</a> volatile 关键字</h3> <ul><li><code>volatile</code> 变量可保证可见性，但不保证原子性。<code>volatile</code> 修饰变量时，会把该线程本地内存中的该变量刷新到主存中。</li> <li><code>volatile</code> 变量会禁止指令重排。</li></ul> <p><strong>参考链接</strong></p> <ul><li><a href="https://gitee.com/zztiyjw/concurrent-practice/blob/master/src/test/java/com/albert/concurrent/book/chaptertwo/ThreadVolatile_07.java" target="_blank" rel="noopener noreferrer">volatile 关键字练习<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://blog.csdn.net/u012723673/article/details/80682208?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener noreferrer">Java volatile关键字最全总结：原理剖析与实例讲解(简单易懂)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <hr> <h3 id="线程组"><a href="#线程组" class="header-anchor">#</a> 线程组</h3> <p>可按照功能将不同线程进行分组。</p> <p>参考：<a href="https://gitee.com/zztiyjw/concurrent-practice/blob/master/src/test/java/com/albert/concurrent/book/chaptertwo/ThreadGroup_08.java" target="_blank" rel="noopener noreferrer">线程组的练习<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <hr> <h3 id="守护线程"><a href="#守护线程" class="header-anchor">#</a> 守护线程</h3> <p>守护线程是一种特殊的线程，会在所有的用户线程执行完成之后，随之结束。</p> <p>参考：<a href="https://gitee.com/zztiyjw/concurrent-practice/blob/master/src/test/java/com/albert/concurrent/book/chaptertwo/ThreadDaemon_09.java" target="_blank" rel="noopener noreferrer">守护线程的练习<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <hr> <h3 id="线程优先级"><a href="#线程优先级" class="header-anchor">#</a> 线程优先级</h3> <p>可以为线程设置优先级，在线程之间抢占资源时，线程优先级越高，机会越大。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code> <span class="token class-name">Thread</span> highThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HignPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token class-name">Thread</span> lowThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LowPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token comment">//设置优先级</span>
 highThread<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span>MAX_PRIORITY<span class="token punctuation">)</span><span class="token punctuation">;</span>
 lowThread<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span>MIN_PRIORITY<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>线程优先级默认为 5 ，最大为 10，最小为 1。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token comment">/**
     * The minimum priority that a thread can have.
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> MIN_PRIORITY <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

   <span class="token comment">/**
     * The default priority that is assigned to a thread.
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> NORM_PRIORITY <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * The maximum priority that a thread can have.
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">int</span> MAX_PRIORITY <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>参考：<a href="https://gitee.com/zztiyjw/concurrent-practice/blob/master/src/test/java/com/albert/concurrent/book/chaptertwo/ThreadPriority_10.java" target="_blank" rel="noopener noreferrer">线程优先级的练习<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <hr></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2021-03-05 16:09:48</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/blog/concurrent/threadpool/线程池概述.html">
        线程池概述
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.69fb67a1.js" defer></script><script src="/blog/assets/js/2.4016a2d7.js" defer></script><script src="/blog/assets/js/9.a57e59ce.js" defer></script>
  </body>
</html>
