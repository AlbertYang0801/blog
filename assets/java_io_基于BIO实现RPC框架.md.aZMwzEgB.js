import{_ as i,c as a,o as n,ag as l}from"./chunks/framework.D7pKEi_Q.js";const g=JSON.parse('{"title":"基于BIO实现RPC框架","description":"","frontmatter":{},"headers":[],"relativePath":"java/io/基于BIO实现RPC框架.md","filePath":"java/io/基于BIO实现RPC框架.md"}'),e={name:"java/io/基于BIO实现RPC框架.md"};function t(p,s,h,k,r,d){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="基于bio实现rpc框架" tabindex="-1">基于BIO实现RPC框架 <a class="header-anchor" href="#基于bio实现rpc框架" aria-label="Permalink to &quot;基于BIO实现RPC框架&quot;">​</a></h1><p><a href="https://blog.csdn.net/weixin_42161936/article/details/119919878" target="_blank" rel="noreferrer">基于bio手写实现简单的rpc_java 手写一个bio-CSDN博客</a></p><h2 id="rpc" tabindex="-1">RPC <a class="header-anchor" href="#rpc" aria-label="Permalink to &quot;RPC&quot;">​</a></h2><p><img src="https://s2.loli.net/2025/05/29/VBKQe5x3CLivlSc.png" alt=""></p><h3 id="rpc设计" tabindex="-1">RPC设计 <a class="header-anchor" href="#rpc设计" aria-label="Permalink to &quot;RPC设计&quot;">​</a></h3><p><img src="https://s2.loli.net/2025/05/29/4aowYkprR6FG2Ai.png" alt=""></p><p>RPC 的核心就是让客户端调用远程服务方法，就像调用本地方法一样。</p><ul><li>服务端将自己的类注册到远程服务。</li><li>客户端通过注册中心获取到服务端地址。 <ul><li>客户端调用服务端地址，传入类名，调用方法、入参</li><li>服务端收到方法信息后，本地通过<strong>反射</strong>执行方法，获取结果返回给客户端。</li></ul></li><li>客户端需要写一个需要调用的类，和服务端的类保持一致（方法名、入参类型、入参）。 <ul><li>客户端需要对这个类进行动态代理，实际访问的是该类的代理对象。 <ul><li>代理逻辑包括对获取方法信息（方法名、入参），然后调用远程服务，将远程服务返回结果返回。</li></ul></li></ul></li></ul><h3 id="代理问题" tabindex="-1">代理问题 <a class="header-anchor" href="#代理问题" aria-label="Permalink to &quot;代理问题&quot;">​</a></h3><p>RPC 的本质是让调用远程服务像调用本地方法一样简单。</p><p>调用者不关心内部实现，具体的远程调用由代理对象负责，这里就用到了代理模式。</p><h3 id="序列化问题" tabindex="-1">序列化问题 <a class="header-anchor" href="#序列化问题" aria-label="Permalink to &quot;序列化问题&quot;">​</a></h3><p>在网络传输过程中，将对象变为二进制串传输。通过对象的序列化和反序列化实现。</p><h3 id="通信问题" tabindex="-1">通信问题 <a class="header-anchor" href="#通信问题" aria-label="Permalink to &quot;通信问题&quot;">​</a></h3><p>可以通过 BIO 进行网络传输。</p><h2 id="注册中心" tabindex="-1">注册中心 <a class="header-anchor" href="#注册中心" aria-label="Permalink to &quot;注册中心&quot;">​</a></h2><p>注册中心只有两种请求</p><ul><li>服务注册</li><li>服务发现</li></ul><p>将服务注册到注册中心，注册中心其实通过一个 Map 保存实例信息，维护 serviceName 和 serviceAddress 的关系。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //注册服务名,支持多实例</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//注册加锁，查询不加</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Map&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, Set&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RegisterServiceVo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt; SERVICE_HOLDER </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HashMap&lt;&gt;();</span></span></code></pre></div><h2 id="服务端" tabindex="-1">服务端 <a class="header-anchor" href="#服务端" aria-label="Permalink to &quot;服务端&quot;">​</a></h2><ul><li>启动时需要将自己注册到注册中心</li><li>提供基于反射调用自己方法的能力</li></ul><h2 id="客户端" tabindex="-1">客户端 <a class="header-anchor" href="#客户端" aria-label="Permalink to &quot;客户端&quot;">​</a></h2><ul><li><p>从注册中心获取服务列表，获取服务真实地址。</p></li><li><p>添加远程服务接口。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> IStockService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * 获取商品的库存</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> skuId</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@return</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    long</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getStock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Integer </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">skuId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>基于远程服务接口进行 JDK 动态代理。</p><p>基于远程服务接口类，创建一个动态代理类并且放到 Spring 中。在使用的时候从 Spring 容器中获取该 Service，即可调用动态代理类的逻辑。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Configuration</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BeanConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    RpcClientFrame rpcClientFrame;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * 注册远程服务接口</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * 创建远程服务接口的代理对象，实现调用远程服务的逻辑</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@return</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Bean</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> IStockService </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">iStockService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rpcClientFrame.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRemoteProxyObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(IStockService.class);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>动态代理类的逻辑</p><ul><li><p>获取远程服务真实地址。</p></li><li><p>使用反射获取远程服务类、方法、入参等信息。</p></li><li><p>调用远程服务。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * 远程服务的代理对象，参数是客户端要调用的服务</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRemoteProxyObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">final</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Class</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> serviceInterface) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //从注册中心获取服务真实地址</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        InetSocketAddress serviceRealAddress </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> serviceDiscoveryHandler.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getServiceRealAddress</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(serviceInterface.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //获取服务代理对象，由代理对象进行实际的网络调用</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //对Class执行InvocationHandler的Invoke方法，即JDK动态代理</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (T) Proxy.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newProxyInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(serviceInterface.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getClassLoader</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Class&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;[]{serviceInterface},</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> DynProxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(serviceInterface,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                        serviceRealAddress));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre></div></li></ul></li></ul><h2 id="源码地址" tabindex="-1">源码地址 <a class="header-anchor" href="#源码地址" aria-label="Permalink to &quot;源码地址&quot;">​</a></h2><p><a href="https://gitee.com/zztiyjw/JavaAdvance/blob/master/moudle-netty/rpc-client/src/main/java/com/albert/rpc/bio/client/RpcClientFrame.java" target="_blank" rel="noreferrer">moudle-netty/rpc-client/src/main/java/com/albert/rpc/bio/client/RpcClientFrame.java · Albert.Yang/JavaAdvance - Gitee</a></p>`,26)]))}const E=i(e,[["render",t]]);export{g as __pageData,E as default};
