import{_ as a,c as s,o as e,ag as l}from"./chunks/framework.D7pKEi_Q.js";const c=JSON.parse('{"title":"MySQL基础架构","description":"","frontmatter":{},"headers":[],"relativePath":"database/mysql/MySQL基础架构.md","filePath":"database/mysql/MySQL基础架构.md"}'),t={name:"database/mysql/MySQL基础架构.md"};function h(n,i,p,r,k,d){return e(),s("div",null,i[0]||(i[0]=[l('<h1 id="mysql基础架构" tabindex="-1">MySQL基础架构 <a class="header-anchor" href="#mysql基础架构" aria-label="Permalink to &quot;MySQL基础架构&quot;">​</a></h1><p>MySQL是 <code>C/S（Client端 / Server端）</code> 架构。</p><h2 id="架构图" tabindex="-1">架构图 <a class="header-anchor" href="#架构图" aria-label="Permalink to &quot;架构图&quot;">​</a></h2><p><img src="https://s2.loli.net/2025/06/13/xLeckiQH49lnEum.png" alt=""></p><p><img src="https://s2.loli.net/2025/06/13/vGxZt3HAJRpXsnS.png" alt=""></p><p>MySQL架构包含 <code>Server层</code> 和 <code>存储引擎层</code> 。</p><ul><li>Server 层包含 <code>连接器</code> 、<code>分析器</code>、<code>优化器</code>、<code>执行器</code>。</li><li>存储引擎层包含 <code>引擎层</code>、<code>存储层</code>。</li></ul><h2 id="一、连接器" tabindex="-1">一、连接器 <a class="header-anchor" href="#一、连接器" aria-label="Permalink to &quot;一、连接器&quot;">​</a></h2><h3 id="连接器的作用" tabindex="-1">连接器的作用 <a class="header-anchor" href="#连接器的作用" aria-label="Permalink to &quot;连接器的作用&quot;">​</a></h3><ul><li>跟客户端建立连接。</li><li>维持和管理连接。</li><li><strong>校验用户和获取用户权限</strong>。</li></ul><hr><h3 id="校验用户" tabindex="-1">校验用户 <a class="header-anchor" href="#校验用户" aria-label="Permalink to &quot;校验用户&quot;">​</a></h3><p>客户端进行连接MySQL的命令如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mysql </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">h$ip </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">P$port </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">u$user </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p</span></span></code></pre></div><p>在网络连接 TCP 握手成功之后，连接器会校验用户名和密码。</p><ul><li>如果用户名或者密码错误，会直接返回错误提示<code>Access denied for user</code>。</li></ul><h3 id="获取用户权限" tabindex="-1">获取用户权限 <a class="header-anchor" href="#获取用户权限" aria-label="Permalink to &quot;获取用户权限&quot;">​</a></h3><p>用户名密码认证通过后，连接器会到权限表查询用户拥有的权限，并赋予对应操作权限。</p><blockquote><p>假如连接成功后修改用户权限，也不会影响已经建立连接过的用户。只有断开当前连接重新连接，权限才会生效。</p></blockquote><h3 id="数据库连接池" tabindex="-1">数据库连接池 <a class="header-anchor" href="#数据库连接池" aria-label="Permalink to &quot;数据库连接池&quot;">​</a></h3><p>客户端与数据库建立连接的过程是比较复杂的，流程如下：</p><ol><li>TCP建立连接的三次握手。</li><li>MySQL认证的认证校验。</li><li>真正的SQL执行。</li><li>MySQL的关闭。</li><li>TCP的四次挥手关闭连接。</li></ol><blockquote><p>数据库连接池能够维护一定的数据库长连接，方便客户端复用，当客户端需要连接数据库时，从连接池获取连接，用完归还即可。无需关心数据库连接池是如何管理这些连接的。</p></blockquote><p>在使用连接池后，除了首次需要进行 MySQL连接的初始化，后续使用只需要关注 执行SQL 这部分的开销。</p><p>常见的数据库连接池有：</p><ul><li>Druid</li><li>C3p0</li></ul><hr><h3 id="池化思想" tabindex="-1">池化思想 <a class="header-anchor" href="#池化思想" aria-label="Permalink to &quot;池化思想&quot;">​</a></h3><p>一般是对象的池化。核心思想是<code>空间换时间</code>。</p><p>使用预先创建好的对象来减少频繁创建对象的损失，重复利用对象，同时还能够对对象统一管理。</p><p>比如：<code>线程池</code>、<code>数据库连接池</code>、<code>字符串常量池</code>。</p><h3 id="sql接口" tabindex="-1">SQL接口 <a class="header-anchor" href="#sql接口" aria-label="Permalink to &quot;SQL接口&quot;">​</a></h3><p>SQL语句的入口，接受用户的SQL命令，支持接受 DMS，DDL语句，还支持视图、存储过程，并将最终结果返回给用户。</p><h2 id="二、查询缓存" tabindex="-1">二、查询缓存 <a class="header-anchor" href="#二、查询缓存" aria-label="Permalink to &quot;二、查询缓存&quot;">​</a></h2><p>在连接器建立连接之后，通过SQL接口接入的SQL语句，若执行的是 <code>select</code> 语句，则连接器会先查询缓存。</p><ul><li>查询缓存命中的话，会 <strong>判断用户是否有操作表的权限</strong>，符合权限会直接返回结果。</li><li>查询未命中，会继续后面的执行阶段。</li></ul><h3 id="缓存的原理" tabindex="-1">缓存的原理 <a class="header-anchor" href="#缓存的原理" aria-label="Permalink to &quot;缓存的原理&quot;">​</a></h3><p>之前查询的结果会以 K-V 结构存储在缓存中，其中 K 为执行的SQL，V为查询的结果。</p><p>当数据表记录更新删除的时候，要同步修改缓存中的数据。</p><h3 id="查询缓存的弊端" tabindex="-1">查询缓存的弊端 <a class="header-anchor" href="#查询缓存的弊端" aria-label="Permalink to &quot;查询缓存的弊端&quot;">​</a></h3><ol><li><p>查询缓存的 K 需要保证 SQL语句保持一致才会利用到缓存，这也导致查询缓存的场景有局限性。</p></li><li><p>若更新删除频繁，查询缓存的利用率会更低。</p><p>因为更新删除数据表后，该表在缓存中的记录要被全部删除。可能存在数据存入缓存还未利用，便被更新操作删除了。</p></li></ol><blockquote><p>查询缓存适用于不会频繁变动的数据表，比如配置信息表。</p></blockquote><h3 id="手动使用查询缓存" tabindex="-1">手动使用查询缓存 <a class="header-anchor" href="#手动使用查询缓存" aria-label="Permalink to &quot;手动使用查询缓存&quot;">​</a></h3><p>在 <code>select</code> 语句中，使用关键字 <code>SQL_CACHE</code> 可以手动指定查询缓存。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">select SQL_CACHE </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> from </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id =1</span></span></code></pre></div><p>MySQL8.0 删除了 <strong>查询缓存</strong> 这部分功能。</p><h2 id="三、分析器" tabindex="-1">三、分析器 <a class="header-anchor" href="#三、分析器" aria-label="Permalink to &quot;三、分析器&quot;">​</a></h2><p>分析器会解析传入的 SQL语句，进行语法分析。</p><h3 id="词法分析" tabindex="-1">词法分析 <a class="header-anchor" href="#词法分析" aria-label="Permalink to &quot;词法分析&quot;">​</a></h3><p>MySQL通过语法分析，能够知道 SQL 语句需要执行的功能。</p><p><code>解析 SQL 语句中的关键字</code>，比如 SELECT 关键字，表名等。</p><h3 id="语法分析" tabindex="-1">语法分析 <a class="header-anchor" href="#语法分析" aria-label="Permalink to &quot;语法分析&quot;">​</a></h3><p>语法分析的作用是 <code>校验 SQL 的合法性</code>。</p><p>若 SQL 语句不满足语法规定，会提示 <strong>语法错误</strong>。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mysql</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> elect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> from t where ID</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;ERROR </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1064</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> the right syntax to use near </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;elect * from t where ID=1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> at line </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span></code></pre></div><p>语法规定包括 <code>表名</code>、<code>字段名称</code>的校验，还有参数等的校验。</p><h2 id="四、查询优化器" tabindex="-1">四、查询优化器 <a class="header-anchor" href="#四、查询优化器" aria-label="Permalink to &quot;四、查询优化器&quot;">​</a></h2><p>SQL 语句在被执行之前，会被查询优化器进行优化。</p><p>优化器在以下情况下会被使用：</p><ol><li><p>操作的表包含多个索引。</p><p>优化器会选择合适的索引。</p></li><li><p>SQL 语句包含连接（JOIN）查询。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">select </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> from A join B </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ID) where A.c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> and B.d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span></span></code></pre></div><p>比如先查询 A 表，c=20的记录，再根据 ID 查询 B 表，d=20的记录。假如反过来先查询 B 表，再根据 ID 查询 A 表。</p><p>虽然查询结果一致，但是前后效率是不一致的。</p><p>优化器会选择先执行哪部分效率会更高。</p><hr></li></ol><h2 id="五、执行器" tabindex="-1">五、执行器 <a class="header-anchor" href="#五、执行器" aria-label="Permalink to &quot;五、执行器&quot;">​</a></h2><p>分析器使 MySQL 知道了 SQL语句要做什么，通过优化器对SQL 进行了优化。</p><p>最终需要执行器进行 SQL 执行。</p><hr><h3 id="权限校验" tabindex="-1">权限校验 <a class="header-anchor" href="#权限校验" aria-label="Permalink to &quot;权限校验&quot;">​</a></h3><p>在执行 SQL 语句之前，执行器会对 SQL 语句中涉及到的表进行 <strong>权限校验</strong>。</p><ol><li>如果没有操作表的权限，会提示权限不足。</li></ol><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mysql</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> select </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> from T where ID</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;ERROR </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1142</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">42000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SELECT command denied to user </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;b&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;localhost&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> table </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;T&#39;</span></span></code></pre></div><ol><li>如果权限校验通过，会进行 SQL 执行。</li></ol><h3 id="执行器的执行流程" tabindex="-1">执行器的执行流程 <a class="header-anchor" href="#执行器的执行流程" aria-label="Permalink to &quot;执行器的执行流程&quot;">​</a></h3><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Test </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ID</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>执行器会获取 SQL 语句中的数据表 <code>Test</code> 定义的引擎（InnoDB），再根据引擎的定义接口执行语句。</p><p>比如没有索引的情况，执行流程如下：</p><ol><li>调用 InnoDB引擎接口，获取 <code>Test</code>表的第一行，判断 ID = 10。 <ul><li>若不是则跳过，若是则将结果存到结果集中。</li></ul></li><li>调用引擎接口<code>取下一行</code>。重复第一步的逻辑，直到读到表的最后一行。</li><li>将结果集中所有满足条件的记录返回给客户端。</li><li>将 SQL语句与搜索结果以 K-V形式存入查询缓存。</li></ol><hr><h2 id="思考问题" tabindex="-1">思考问题 <a class="header-anchor" href="#思考问题" aria-label="Permalink to &quot;思考问题&quot;">​</a></h2><p>如果表 T 中没有字段 k，而你执行了这个语句 <code>select * from T where k=1</code> , 那肯定是会报“不存在这个列”的错误： “Unknown column ‘k’ in ‘where clause’”。你觉得这个错误是在我们上面提到的哪个阶段报出来的呢？</p><p>在分析器的语法分析阶段报出来。</p>',78)]))}const E=a(t,[["render",h]]);export{c as __pageData,E as default};
