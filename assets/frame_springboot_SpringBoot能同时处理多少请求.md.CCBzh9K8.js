import{_ as t,c as o,o as s,ag as e}from"./chunks/framework.D7pKEi_Q.js";const h=JSON.parse('{"title":"SpringBoot能同时处理多少请求","description":"","frontmatter":{},"headers":[],"relativePath":"frame/springboot/SpringBoot能同时处理多少请求.md","filePath":"frame/springboot/SpringBoot能同时处理多少请求.md"}'),n={name:"frame/springboot/SpringBoot能同时处理多少请求.md"};function p(l,a,i,c,r,m){return s(),o("div",null,a[0]||(a[0]=[e(`<h1 id="springboot能同时处理多少请求" tabindex="-1">SpringBoot能同时处理多少请求 <a class="header-anchor" href="#springboot能同时处理多少请求" aria-label="Permalink to &quot;SpringBoot能同时处理多少请求&quot;">​</a></h1><p>SpringBoot内置了Tomcat，处理请求是 Web 容器处理的。</p><ol><li><p>线程池线程数限制</p><p>而 Tomcat 的线程池默认最大线程池是 200，所以默认同时<strong>最多能处理 200 个请求</strong>。</p><blockquote><p>由于 Tomcat 线程池运行机制，核心线程用完之后，还是继续创建线程，直到最大线程数。</p></blockquote></li></ol><blockquote></blockquote><ol start="2"><li><p>连接数限制</p><p>达到连接池数时，会限制请求数。此时因连接数限制为准，而不是最大线程数。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#tomcat最大连接数限制</span></span>
<span class="line"><span>server.tomcat.max-connections=12</span></span></code></pre></div></li></ol><hr><h2 id="限制配置" tabindex="-1">限制配置 <a class="header-anchor" href="#限制配置" aria-label="Permalink to &quot;限制配置&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#tomcat最大连接数限制</span></span>
<span class="line"><span>server.tomcat.max-connections=12</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#线程池队列长度</span></span>
<span class="line"><span>server.tomcat.accept-count=100</span></span></code></pre></div><h2 id="tomcat的线程池运行机制" tabindex="-1">Tomcat的线程池运行机制 <a class="header-anchor" href="#tomcat的线程池运行机制" aria-label="Permalink to &quot;Tomcat的线程池运行机制&quot;">​</a></h2><p>当请求进入到 tomcat 容器时，会将请求提交到 tomcat的线程池。</p><h3 id="tomcat-的默认线程池参数" tabindex="-1">Tomcat 的默认线程池参数 <a class="header-anchor" href="#tomcat-的默认线程池参数" aria-label="Permalink to &quot;Tomcat 的默认线程池参数&quot;">​</a></h3><ul><li>核心线程数 - 25</li><li>最大线程数 - 200</li><li>队列长度 - Integer.MAX_VALUE</li></ul><p><img src="https://s2.loli.net/2025/05/30/EcT4hm5ikZnJdSF.png" alt=""></p><p><img src="https://s2.loli.net/2025/05/30/o9s7ZvV23kX8IJz.png" alt=""></p><p><img src="https://s2.loli.net/2025/05/30/b2KLyiusAwB1mqZ.png" alt=""></p><blockquote><p>tomcat 的线程池和 Jdk的线程池运行机制有差异。</p></blockquote><h3 id="线程池差异点" tabindex="-1">线程池差异点 <a class="header-anchor" href="#线程池差异点" aria-label="Permalink to &quot;线程池差异点&quot;">​</a></h3><p>当线程池中核心线程池用完之后，如何处理新来的任务。</p><ol><li><p>JDK</p><p>将任务放到队列中。</p></li><li><p>Tomcat</p><p><strong>核心线程数用完后，创建新线程，直到达到最大线程数，再将任务放到队列中</strong>。</p><ul><li><p>线程数 &lt; 最大线程数 ，返回false</p><p><img src="https://s2.loli.net/2025/05/30/y8Twt3zRNPkrAVE.png" alt=""></p></li><li><p>false 之后，到最后判断进入 <code>addWorker(command, false )</code> ，新增非核心线程。</p><p><img src="https://s2.loli.net/2025/05/30/3HcQ6s2SxXPNVOZ.png" alt=""></p></li></ul></li></ol><h3 id="为什么tomcat要改线程运行机制" tabindex="-1">为什么tomcat要改线程运行机制 <a class="header-anchor" href="#为什么tomcat要改线程运行机制" aria-label="Permalink to &quot;为什么tomcat要改线程运行机制&quot;">​</a></h3><p>Tomcat在核心线程数满了之后启用最大线程数的原因是<strong>为了应对高并发请求的情况</strong>。</p><p>当核心线程数无法满足请求的处理需求时，通过创建更多的线程来处理请求可以提高系统的并发处理能力。</p><p>但是需要注意的是，过多的线程创建可能会导致系统资源的消耗增加，因此在配置最大线程数时需要根据实际情况和系统资源来进行调整，以避免线程过多导致系统性能下降。</p>`,23)]))}const g=t(n,[["render",p]]);export{h as __pageData,g as default};
