import{_ as s,c as i,o as e,aN as l}from"./chunks/framework.A-MC8nKA.js";const g=JSON.parse('{"title":"索引","description":"","frontmatter":{},"headers":[],"relativePath":"database/mysql/索引.md","filePath":"database/mysql/索引.md","lastUpdated":1752827238000}'),n={name:"database/mysql/索引.md"};function t(p,a,h,r,d,k){return e(),i("div",null,a[0]||(a[0]=[l('<h1 id="索引" tabindex="-1">索引 <a class="header-anchor" href="#索引" aria-label="Permalink to &quot;索引&quot;">​</a></h1><p>在 MySQL 中，索引是在<strong>存储引擎层</strong>实现的，所以并没有统一的索引标准。</p><h2 id="innodb的索引模型" tabindex="-1">InnoDB的索引模型 <a class="header-anchor" href="#innodb的索引模型" aria-label="Permalink to &quot;InnoDB的索引模型&quot;">​</a></h2><h3 id="b-树" tabindex="-1">B+树 <a class="header-anchor" href="#b-树" aria-label="Permalink to &quot;B+树&quot;">​</a></h3><p><img src="https://s2.loli.net/2025/06/13/jU59Th4IAqxuWEa.png" alt="" loading="lazy"></p><p>B+树的每个叶子节点存放元素有限，每个叶子节点为一个 page，针对元素的数量会产生页分裂、页合并等现象。</p><p><a href="https://blog.csdn.net/weixin_52622200/article/details/118530154" target="_blank" rel="noreferrer">什么是B+树？_攻城狮百里的博客-CSDN博客_b+树</a></p><p><img src="https://s2.loli.net/2025/06/13/3htEkaHp2wZVDzR.png" alt="" loading="lazy"></p><h3 id="聚簇索引和二级索引" tabindex="-1">聚簇索引和二级索引 <a class="header-anchor" href="#聚簇索引和二级索引" aria-label="Permalink to &quot;聚簇索引和二级索引&quot;">​</a></h3><ul><li>主键索引的叶子结点存的是整行记录。InnoDB 引擎中主键索引又称为<strong>聚簇索引</strong>。</li><li>非主键索引的叶子结点存的是行记录的ID。在 InnoDB 引擎中非主键索引又称为<strong>二级索引</strong>。</li></ul><p><img src="https://s2.loli.net/2025/06/13/3htEkaHp2wZVDzR.png" alt="" loading="lazy"></p><h3 id="搜索方式" tabindex="-1">搜索方式 <a class="header-anchor" href="#搜索方式" aria-label="Permalink to &quot;搜索方式&quot;">​</a></h3><ul><li><p>根据主键搜索</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 500</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>根据 id = 500 从主键索引这个 B+树中查找对应记录。</p><ul><li>首先找到500对应的叶子节点所在的 page。</li><li>在 page 上通过二分法进行查找（page 内部维护了有序数组）数据所在分组。</li><li>分组单向链表，遍历查询链表获取数据。</li></ul></li><li><p>根据非主键搜索</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>根据 k =5 从非主键索引这个 B+树中查找对应记录，获取主键 id = 500。再根据 id =500 从主键索引获取对应行记录。这个过程叫做 <strong>回表</strong>。</p></li></ul><hr><blockquote><p>基于非主键字段进行搜索的时候，会进行回表操作。多扫描一次索引树。</p></blockquote><h3 id="索引维护" tabindex="-1">索引维护 <a class="header-anchor" href="#索引维护" aria-label="Permalink to &quot;索引维护&quot;">​</a></h3><p>B+树为了维护索引有序性，在插入新数据的时候要对顺序进行维护，<strong>调整插入数据的位置</strong>。</p><p>比如新插入的值为700的时候，需要在 R5 记录后面插入一条新纪录。</p><p>如果插入值为400，就需要在逻辑上挪动 R4、R5的位置，空出位置让400插入。</p><h3 id="页分裂" tabindex="-1">页分裂 <a class="header-anchor" href="#页分裂" aria-label="Permalink to &quot;页分裂&quot;">​</a></h3><p>如果在插入值 700 时，R5所在数据页满了，根据 B+树的算法，需要申请一个新的数据页面。并且挪动部分数据过去，这个过程称为<strong>页分裂</strong>。</p><p><strong>页分裂的过程会影响到性能和页面利用率。</strong></p><p>申请新的页面后，原本一页的数据，分到两个页面，会使页面的利用率降低到50%左右。</p><h3 id="页合并" tabindex="-1">页合并 <a class="header-anchor" href="#页合并" aria-label="Permalink to &quot;页合并&quot;">​</a></h3><p>当相邻两个页面，由于数据删除导致利用率很低的时候，会将数据页合并。</p><h3 id="为什么推荐使用自增id作为主键" tabindex="-1">为什么推荐使用自增Id作为主键 <a class="header-anchor" href="#为什么推荐使用自增id作为主键" aria-label="Permalink to &quot;为什么推荐使用自增Id作为主键&quot;">​</a></h3><p><strong>从插入方式考虑：</strong></p><p>在使用自增主键的场景下，新增数据时，会获取当前ID最大值+1，作为新增数据的主键。</p><p>此时，B+树中会递增插入，减少中间插入导致挪动的情况发生。</p><p>若选择业务字段作为主键，则无法保证插入的有序性。</p><p><em>使用自增ID可以保证插入的连续性，减少叶子节点的挪动。</em></p><p><strong>从存储空间考虑：</strong></p><p>非主键字段的索引的叶子节点，存储的都是主键。</p><p>假如用一个业务字段（身份证号）作为主键，占用约为20个字节。而用自增ID，整型类作为主键，则只占用4个字节。若为 bigint，则占用 8个字节。</p><p><em><strong>主键长度越小，非主键索引叶子节点越小，非主键索引占用空间越小。</strong></em></p><p>从插入性能和存储的情况考虑，主键使用自增ID比较合理。</p><h3 id="适合业务字段作为主键的场景" tabindex="-1">适合业务字段作为主键的场景 <a class="header-anchor" href="#适合业务字段作为主键的场景" aria-label="Permalink to &quot;适合业务字段作为主键的场景&quot;">​</a></h3><ol><li>只有一个索引。</li><li>该索引必须为唯一索引。</li></ol><p>将单独的业务字段作为主键，避免根据该字段查询的时候进行回表操作。只需要查一次索引即可。</p><h3 id="问题记录" tabindex="-1">问题记录 <a class="header-anchor" href="#问题记录" aria-label="Permalink to &quot;问题记录&quot;">​</a></h3><p><img src="https://s2.loli.net/2025/06/13/OJXLPhMvcHUD1dg.png" alt="" loading="lazy"></p><p><img src="https://s2.loli.net/2025/06/13/FEb1vh2XuS3ZtQs.png" alt="" loading="lazy"></p><p><img src="https://s2.loli.net/2025/06/13/EFU2W1RnKDmJ4ay.png" alt="" loading="lazy"></p><h2 id="覆盖索引" tabindex="-1">覆盖索引 <a class="header-anchor" href="#覆盖索引" aria-label="Permalink to &quot;覆盖索引&quot;">​</a></h2><p>在使用非主键索引时，找到了索引叶子节点上的主键后，要二次搜素主键索引获取记录，这个过程叫回表。</p><hr><p>有些情况可以避免回表，比如只查询主键，查找非主键索引就能获取主键信息，不需要回表操作。</p><p>即非主键索引已经覆盖了查询需求，称为<strong>覆盖索引</strong>。</p><p><img src="https://s2.loli.net/2025/06/13/3htEkaHp2wZVDzR.png" alt="" loading="lazy"></p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">between</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> and</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>执行该语句时。</p><ul><li>在 k 索引树找到 3，进行回表操作找到 R3。</li><li>按顺序继续找到 5，进行回表操作找到 R4。</li><li>按顺序找到 6，此时发现不匹配，结束查询。</li></ul><p>整个过程查询了3次 k 索引，进行了2次回表。将两条记录返回给 Server 层。</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ID </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">between</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> and</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>根据 k 查找 k索引的时候，<code>between 3 and 5</code> 会按顺序匹配 3、5、6。6发现不匹配，结束查找。将3、5返回给 Server 层的执行器。</p><p>整个过程查询了3次 k 索引，没有回表操作。将两条记录返回给 Server 层。</p><p>覆盖索引，可以降低查找索引的次数，减少回表，显著提高查询性能。所以使用覆盖索引是一种查询SQL语句的优化方式。</p><h2 id="联合索引" tabindex="-1">联合索引 <a class="header-anchor" href="#联合索引" aria-label="Permalink to &quot;联合索引&quot;">​</a></h2><p>假如存在 (name，age）联合索引。</p><p>索引会先按照 name 字段排序，相同 name 字段按照 age 字段排序。</p><p><img src="https://s2.loli.net/2025/06/13/j2cu1LJzYaEWxGr.png" alt="" loading="lazy"></p><h3 id="联合索引的覆盖索引情况" tabindex="-1">联合索引的覆盖索引情况 <a class="header-anchor" href="#联合索引的覆盖索引情况" aria-label="Permalink to &quot;联合索引的覆盖索引情况&quot;">​</a></h3><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> user </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;张三&#39;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>根据 name 查找 age 时，索引叶子节点包含了查询的结果，无需进行回表。</p><hr><p>但是根据 age 查找 name 的话，并不会利用到该索引。</p><h3 id="联合索引有效情况" tabindex="-1">联合索引有效情况 <a class="header-anchor" href="#联合索引有效情况" aria-label="Permalink to &quot;联合索引有效情况&quot;">​</a></h3><ol><li>根据 name 查找。</li><li>根据 name like ‘张%’ 进行模糊查找。</li></ol><hr><p>因为索引是按照前面的字段进行排序的，只有保证前面部分能匹配，就能保证有序性。进而利用到索引。</p><h2 id="最左前缀原则" tabindex="-1">最左前缀原则 <a class="header-anchor" href="#最左前缀原则" aria-label="Permalink to &quot;最左前缀原则&quot;">​</a></h2><p>在联合索引（name,age,address）情况下，满足以下规则，索引会生效。</p><ol><li><p>匹配索引最左的 N 个字段。</p><p>name = ’张三‘ and age = 10</p></li><li><p>匹配最左边字符串索引的最左 M 个字符。</p><p>name like ‘张%’</p></li></ol><hr><p>最左前缀原则，要求我们在建立联合索引的时候，要适当选择最左边的字段。</p><h2 id="索引下推" tabindex="-1">索引下推 <a class="header-anchor" href="#索引下推" aria-label="Permalink to &quot;索引下推&quot;">​</a></h2><p>联合索引（name，age）的情况下。</p><p>查询 name 时满足最左前缀原则，可以利用索引快速查询。但是根据 name 去查询 age 时，情况有所不同。</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tuser </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> like</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;张 %&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> and</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ismale</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>比如查询 name 姓张并且年龄10岁的男孩。</p><ul><li><p>在 MySQL 5.6 之前，在联合索引中根据 <code>name like &#39;张 %&#39;</code> 获取主键后，只能通过回表操作从主键索引中获取记录，再进行条件匹配。</p><p><img src="https://s2.loli.net/2025/06/13/18qzYcl2rFAUjnd.png" alt="" loading="lazy"></p></li><li><p>在 MySQL 5.6之后，引入了<strong>索引下推优化</strong>。<em><strong>在非主键索引遍历后，对索引包含的字段进行遍历，直接过滤掉不满足的记录行，减少回表的次数</strong></em>。</p><p><img src="https://s2.loli.net/2025/06/13/GAf3LJqjiUFm9e4.png" alt="" loading="lazy"></p><p>比如查询 ID3 时，age=30，直接过滤掉，不会进行回表操作。</p></li></ul>',81)]))}const c=s(n,[["render",t]]);export{g as __pageData,c as default};
