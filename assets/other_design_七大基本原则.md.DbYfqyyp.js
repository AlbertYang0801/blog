import{_ as l,c as e,o as i,aN as t}from"./chunks/framework.A-MC8nKA.js";const p=JSON.parse('{"title":"七大基本原则","description":"","frontmatter":{},"headers":[],"relativePath":"other/design/七大基本原则.md","filePath":"other/design/七大基本原则.md","lastUpdated":1755251095000}'),r={name:"other/design/七大基本原则.md"};function o(n,a,h,d,s,c){return i(),e("div",null,a[0]||(a[0]=[t('<h1 id="七大基本原则" tabindex="-1">七大基本原则 <a class="header-anchor" href="#七大基本原则" aria-label="Permalink to &quot;七大基本原则&quot;">​</a></h1><p><a href="https://gitee.com/zztiyjw/design-patterns-practice/tree/master/design-principle" target="_blank" rel="noreferrer">design-principle</a></p><h2 id="单一职责原则" tabindex="-1">单一职责原则 <a class="header-anchor" href="#单一职责原则" aria-label="Permalink to &quot;单一职责原则&quot;">​</a></h2><ol><li>一种类只能具有一种职责，降低类的复杂度。</li><li>提高类的可读性，可维护性。</li><li>降低变更引起的风险。</li><li>在类中的方法比较少的时候，可以在方法级别保持单一职责原则。其他情况下，都要保持类的类单一职责原则。</li></ol><h2 id="接口隔离原则" tabindex="-1">接口隔离原则 <a class="header-anchor" href="#接口隔离原则" aria-label="Permalink to &quot;接口隔离原则&quot;">​</a></h2><ol><li>客户端不应该依赖它不需要的接口。</li><li>一个类对另一个类的依赖应该建立在最小的接口上。</li></ol><h2 id="依赖倒置原则" tabindex="-1">依赖倒置原则 <a class="header-anchor" href="#依赖倒置原则" aria-label="Permalink to &quot;依赖倒置原则&quot;">​</a></h2><ol><li>依赖倒置原则的中心思想是面向接口编程。</li><li>抽象不应该依赖细节，细节应该依赖抽象。抽象是接口或者抽象类，细节即为实现类。</li><li>对于细节的多变性，抽象的东西要稳定的多。</li></ol><h2 id="里氏替换原则" tabindex="-1">里氏替换原则 <a class="header-anchor" href="#里氏替换原则" aria-label="Permalink to &quot;里氏替换原则&quot;">​</a></h2><ol><li>继承遵守里氏替换原则，子类尽量不要重写父类的方法。如果子类重写了父类的方法，实际上是增加了子类和父类之间的耦合度。</li><li>在引用父类的地方能直接使用其子类替换。</li><li>若子类需要修改父类的方法，可以通过组合、聚合、依赖等方法实现。</li></ol><h2 id="开闭原则" tabindex="-1">开闭原则 <a class="header-anchor" href="#开闭原则" aria-label="Permalink to &quot;开闭原则&quot;">​</a></h2><ol><li>对扩展开放。</li><li>对修改关闭。</li></ol><h2 id="迪米特法则" tabindex="-1">迪米特法则 <a class="header-anchor" href="#迪米特法则" aria-label="Permalink to &quot;迪米特法则&quot;">​</a></h2><ol><li>最少知道原则。一个类对自己依赖的类知道越少越好。</li><li>直接朋友。一个类作为成员变量、方法参数、方法返回值出现在另一个类。称该类为另一个类的直接朋友。</li><li>减少非直接朋友的耦合。不要以局部变量的形式出现在其他类。</li></ol><h2 id="合成复用法则-组合-聚合复用原则" tabindex="-1">合成复用法则（组合/聚合复用原则） <a class="header-anchor" href="#合成复用法则-组合-聚合复用原则" aria-label="Permalink to &quot;合成复用法则（组合/聚合复用原则）&quot;">​</a></h2><ol><li>在复用情况时，尽量使用组合和聚合的方式，减少继承的使用。</li><li>若使用继承，则必须严格遵守里式替换原则。</li><li>组合关系。另一个类随着当前类创建和销毁。 例如人和手的关系就是组合关系。</li><li>聚合关系。另一个类包含在当前类中，但另一个类不是当前类的组成部分，另一个类不会因为当前类的创建和销毁而去创建和销毁。 例如人和电脑的关系就是聚合关系。</li></ol>',16)]))}const u=l(r,[["render",o]]);export{p as __pageData,u as default};
