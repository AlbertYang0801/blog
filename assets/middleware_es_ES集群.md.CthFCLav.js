import{_ as l,c as i,o as e,aN as s}from"./chunks/framework.A-MC8nKA.js";const c=JSON.parse('{"title":"ES集群","description":"","frontmatter":{},"headers":[],"relativePath":"middleware/es/ES集群.md","filePath":"middleware/es/ES集群.md","lastUpdated":1752827238000}'),t={name:"middleware/es/ES集群.md"};function n(r,a,o,p,h,d){return e(),i("div",null,a[0]||(a[0]=[s(`<h1 id="es集群" tabindex="-1">ES集群 <a class="header-anchor" href="#es集群" aria-label="Permalink to &quot;ES集群&quot;">​</a></h1><h2 id="集群节点类型" tabindex="-1">集群节点类型 <a class="header-anchor" href="#集群节点类型" aria-label="Permalink to &quot;集群节点类型&quot;">​</a></h2><ol><li>Master Node - 主节点</li><li>DataNode - 数据节点</li><li>Coordinating Node - 协调节点</li></ol><h3 id="master-node" tabindex="-1">Master Node <a class="header-anchor" href="#master-node" aria-label="Permalink to &quot;Master Node&quot;">​</a></h3><ul><li>处理创建，删除索引等请求。</li><li>决定分片被分配到哪个节点。</li><li>维护并更新集群 state。</li></ul><h3 id="master-node节点最佳实践" tabindex="-1">Master Node节点最佳实践 <a class="header-anchor" href="#master-node节点最佳实践" aria-label="Permalink to &quot;Master Node节点最佳实践&quot;">​</a></h3><ul><li>Master节点非常重要，在部署上需要解决单点问题。</li><li>为一个集群设置多个Master节点，而且节点只承担 Master 角色。</li></ul><h3 id="data-node" tabindex="-1">Data Node <a class="header-anchor" href="#data-node" aria-label="Permalink to &quot;Data Node&quot;">​</a></h3><p>保存数据的节点，负责保存分片数据。</p><p>通过增加数据节点可以解决数据水平扩展和解决数据单点的问题。</p><h3 id="coordinating-node" tabindex="-1">Coordinating Node <a class="header-anchor" href="#coordinating-node" aria-label="Permalink to &quot;Coordinating Node&quot;">​</a></h3><ul><li>负责接收 Client 的请求，将请求分发到合适的节点，最终把查询结果汇总到一起。</li><li><strong>每个节点默认都是 Coordinating Node</strong>。</li></ul><h2 id="普通规模" tabindex="-1">普通规模 <a class="header-anchor" href="#普通规模" aria-label="Permalink to &quot;普通规模&quot;">​</a></h2><p>一般es集群是三个节点。三个分片，一个副本。</p><p>三个节点配置了都可以作为master节点，同时又是data节点。</p><ul><li>master节点会管理元数据操作，比如创建、删除索引，以及管理分片。</li><li>data节点会保存数据，master节点将索引按照分片划分到data节点上面。</li></ul><div class="language-yaml vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 指定集群名称3个节点必须一致</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">2 cluster.name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">es‐cluster</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> #指定节点名称，每个节点名字唯一</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">4 node.name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">node‐1</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> #是否有资格为master节点，默认为true</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">6 node.master</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> #是否为data节点，默认为true</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">8 node.data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>三个节点作为data节点，同时都可以竞争master。</li><li>一个集群只有一台活跃的主节点。</li><li>平均查询和写入流量。</li></ul><h2 id="大规模生产环境" tabindex="-1">大规模生产环境 <a class="header-anchor" href="#大规模生产环境" aria-label="Permalink to &quot;大规模生产环境&quot;">​</a></h2><ul><li>3个master节点</li><li>6个data节点</li><li>3个协调节点</li></ul><p>master和data节点要分开。</p><ul><li><p>master节点可以专注于元数据操作。</p></li><li><p>data节点则专注于数据存储和检索。</p><blockquote><p>注意data节点和分片数的关系。</p></blockquote></li><li><p>协调节点作为查询入口，汇总数据。</p></li></ul><p><img src="https://s2.loli.net/2025/06/26/rsN5YITVpugZbyJ.png" alt="image.png" loading="lazy"></p><ul><li>当磁盘容量不够，磁盘写入压力过大的时候，可以<strong>水平扩展data节点</strong>。</li><li>当系统中有大量复杂查询和聚合查询的时候，增加<strong>协调节点</strong>，提高查询的性能。</li></ul><h3 id="协调节点的问题" tabindex="-1">协调节点的问题 <a class="header-anchor" href="#协调节点的问题" aria-label="Permalink to &quot;协调节点的问题&quot;">​</a></h3><p>3master-6node这种高可用情况，master节点一般资源较少。</p><p>由于es默认请求打到哪台节点上面，哪台节点作为协调节点来查询数据，并做最终的汇总。所以master节点可能也会吃资源。</p><p>所以尽量避免master作为协调节点，可以配置专门的协调节点。一般要求CPU和内存高，提高查询和聚合的效率。</p><h3 id="集群脑裂问题" tabindex="-1">集群脑裂问题 <a class="header-anchor" href="#集群脑裂问题" aria-label="Permalink to &quot;集群脑裂问题&quot;">​</a></h3><p><a href="https://flowus.cn/c62b5414-0d4d-434e-9ee6-e136380c4cad" target="_blank" rel="noreferrer">集群脑裂-参数配置</a></p><h2 id="节点单一职责分离" tabindex="-1">节点单一职责分离 <a class="header-anchor" href="#节点单一职责分离" aria-label="Permalink to &quot;节点单一职责分离&quot;">​</a></h2><p>在大规模生产中，一个节点只承担一个角色。</p><p><img src="https://s2.loli.net/2025/06/26/r1ChbIK3UjVmyq4.png" alt="image.png" loading="lazy"></p><p><em>这种单一角色职责分离的好处：</em></p><ul><li><p>单一 master eligible nodes: 负责**集群状态(cluster state)**的管理</p><p><strong>使用低配置的CPU,RAM和磁盘</strong></p></li><li><p>单一 data nodes: 负责<strong>数据存储及处理客户端请求</strong></p><p><strong>使用高配置的CPU,RAM和磁盘</strong></p></li><li><p>单一Coordinating Only Nodes(Client Node):负责发起数据查询，汇总data上报的数据。</p><p>使用<strong>高配置CPU; 高配置的RAM</strong>; <strong>低配置的磁盘</strong></p></li><li><p>单一ingest nodes: 负责数据处理</p><p>使用高配置CPU; 中等配置的RAM; 低配置的磁盘</p><blockquote><p>数据前置处理转换节点，支持pipeline管道设置，可以使用 ingest 对数据进行过滤、转换等操作</p></blockquote></li></ul><h3 id="大集群单独设置协调节点" tabindex="-1">大集群单独设置协调节点 <a class="header-anchor" href="#大集群单独设置协调节点" aria-label="Permalink to &quot;大集群单独设置协调节点&quot;">​</a></h3><p>在大的集群中，为了降低master和data的负载，可以单独设置协调节点。</p><blockquote><p>如果不设置协调节点，默认每个节点都可以作为协调节点。但是master节点一般资源较低，不适合作为协调节点来使用，因为协调节点汇总数据比较耗内存。</p></blockquote><ul><li>Load Balancers</li><li>负责搜索结果的聚合和判定。</li><li>分离故障，避免请求占用大量内存导致oom影响其他节点。</li></ul><p><img src="https://s2.loli.net/2025/06/26/XbQDTdeHkClBYSg.png" alt="image.png" loading="lazy"></p><h2 id="架构" tabindex="-1">架构 <a class="header-anchor" href="#架构" aria-label="Permalink to &quot;架构&quot;">​</a></h2><h3 id="普通架构" tabindex="-1">普通架构 <a class="header-anchor" href="#普通架构" aria-label="Permalink to &quot;普通架构&quot;">​</a></h3><p><img src="https://s2.loli.net/2025/06/26/7BouGwRqslpCTQO.png" alt="image.png" loading="lazy"></p><h3 id="高可用" tabindex="-1">高可用 <a class="header-anchor" href="#高可用" aria-label="Permalink to &quot;高可用&quot;">​</a></h3><p><img src="https://s2.loli.net/2025/06/26/XbQDTdeHkClBYSg.png" alt="image.png" loading="lazy"></p><h3 id="读写分离" tabindex="-1">读写分离 <a class="header-anchor" href="#读写分离" aria-label="Permalink to &quot;读写分离&quot;">​</a></h3><p><img src="https://s2.loli.net/2025/06/26/VLqKDyfeFaZjWPb.png" alt="image.png" loading="lazy"></p><h3 id="hot-warm-冷热分离架构" tabindex="-1">Hot&amp;Warm 冷热分离架构 <a class="header-anchor" href="#hot-warm-冷热分离架构" aria-label="Permalink to &quot;Hot&amp;Warm 冷热分离架构&quot;">​</a></h3><ul><li>ES数据通常不会有update操作。</li><li>适合于 Time Based 索引数据，同时数据量比较大的情况。（比如监控数据）</li><li>Hot节点（通常使用SSD）：索引不断有新文档写入。</li><li>Warm节点（通常使用HHD）：存放不更新的数据，同时不存在大量的数据查询。</li></ul><p><img src="https://s2.loli.net/2025/06/26/7JSApzeKwdtQyv5.png" alt="image.png" loading="lazy"></p><p>冷热分离架构需要考虑数据是如何复制的。</p><p><img src="https://s2.loli.net/2025/06/26/EtxqjI4CUf7Rn38.png" alt="image.png" loading="lazy"></p><h2 id="分片设计" tabindex="-1">分片设计 <a class="header-anchor" href="#分片设计" aria-label="Permalink to &quot;分片设计&quot;">​</a></h2><h3 id="单个分片" tabindex="-1">单个分片 <a class="header-anchor" href="#单个分片" aria-label="Permalink to &quot;单个分片&quot;">​</a></h3><p>7.0开始，新建索引默认只有一个分片。</p><ul><li><p>单个分片，查询算分，聚合查询的问题可以得到避免。</p><p>聚合top是每个data Node取top数据然后计算。</p></li><li><p>但是单个分片，<strong>集群无法水平扩展</strong>。</p></li></ul><h3 id="多个分片" tabindex="-1">多个分片 <a class="header-anchor" href="#多个分片" aria-label="Permalink to &quot;多个分片&quot;">​</a></h3><p>es会自动进行分片的移动，类似Rebalance。</p><h3 id="算法不准" tabindex="-1">算法不准 <a class="header-anchor" href="#算法不准" aria-label="Permalink to &quot;算法不准&quot;">​</a></h3><p>多分片存在算法不准的问题。</p><p><strong>因为每个分片都是基于自己的分片上的数据进行相关度计算的。</strong></p><p>解决算法不准？</p><ol><li>单个分片</li><li>全部查询，整体计算。消耗CPU和内存，执行性能低下，一般不建议使用。</li></ol><h3 id="设计多分片的好处" tabindex="-1">设计多分片的好处 <a class="header-anchor" href="#设计多分片的好处" aria-label="Permalink to &quot;设计多分片的好处&quot;">​</a></h3><ul><li>一旦集群有新数据节点加入，分片就会自动进行分配。</li><li>分片重新分配时，系统不会有downtime。</li><li>查询可以并行查询。</li><li>数据可以分散到多个机器里。</li></ul><h3 id="多分片的缺点" tabindex="-1">多分片的缺点 <a class="header-anchor" href="#多分片的缺点" aria-label="Permalink to &quot;多分片的缺点&quot;">​</a></h3><ul><li>分片过多会导致额外的性能开销，因为需要维护分片。</li><li>每次搜索的请求，需要达到每个分片上。</li><li>分片的meta信息由master节点维护，过多的分片会增加管理的负担。</li></ul><blockquote><p>云监控索引三个分片，一个副本分片。单个索引就是6个分片，7天是42个，100个索引就是4200个分片。</p></blockquote><h3 id="如何确定分片数" tabindex="-1">如何确定分片数 <a class="header-anchor" href="#如何确定分片数" aria-label="Permalink to &quot;如何确定分片数&quot;">​</a></h3><h3 id="存储角度" tabindex="-1">存储角度 <a class="header-anchor" href="#存储角度" aria-label="Permalink to &quot;存储角度&quot;">​</a></h3><ul><li>搜索类应用，单个分片不要超过20GB</li><li>日志类应用，当分片不要超过50GB</li></ul><h3 id="为什么要控制分配存储大小" tabindex="-1">为什么要控制分配存储大小 <a class="header-anchor" href="#为什么要控制分配存储大小" aria-label="Permalink to &quot;为什么要控制分配存储大小&quot;">​</a></h3><ul><li>提高Update的性能。</li><li>进行Merge时，减少需要的资源。</li><li>丢失节点后，具备更快的恢复速度。</li><li>便于分片的Rebalance。</li></ul><h2 id="集群容量规划" tabindex="-1">集群容量规划 <a class="header-anchor" href="#集群容量规划" aria-label="Permalink to &quot;集群容量规划&quot;">​</a></h2><p>es总体来说是比较吃内存和磁盘的。</p><ul><li>磁盘表现在es数据压缩能力不好，以文档形式存放。</li><li>内存表现在： <ul><li>es的倒排索引、词典表和词典表的索引都在内存中。</li><li>协调节点在查询时，需要汇总node上报的数据。然后再做聚合等操作，也是耗内存的过程。</li></ul></li></ul><h3 id="注意点" tabindex="-1">注意点 <a class="header-anchor" href="#注意点" aria-label="Permalink to &quot;注意点&quot;">​</a></h3><ol><li><p>JVM内存配置为机器内存的一半。</p><p>因为lucene需要用到一半的堆外内存。</p></li><li><p>单节点数据量控制在2TB以内。</p></li><li><p>磁盘选择</p><ul><li>搜索场景高的情况，选择SSD。</li><li>日志和查询并发低的场景，考虑使用机械硬盘。</li></ul></li><li><p>内存和磁盘的比例</p><ul><li>搜索场景高，1:16</li><li>日志类或者查询不高的场景，1:48 ~ 1:96</li></ul><blockquote><p>齐商，16G1TB的es满足这个要求。</p></blockquote><p>假如32Ｇ内存，搜索类场景可以满足　<code>32*16=500G</code>的数据，加上预留空间，一个节点大概400G数据。</p><p>日志场景 <code>32*100=3200G</code>，一个节点大概3T的数据。</p></li></ol><h2 id="容量规划案例" tabindex="-1">容量规划案例 <a class="header-anchor" href="#容量规划案例" aria-label="Permalink to &quot;容量规划案例&quot;">​</a></h2><h3 id="信息库搜索" tabindex="-1">信息库搜索 <a class="header-anchor" href="#信息库搜索" aria-label="Permalink to &quot;信息库搜索&quot;">​</a></h3><p>这类数据特点</p><ol><li>和时间范围无关</li><li>不会有大量的写入。</li><li>关注查询的效率和准确性。</li></ol><p>按照索引数据量，确认分片的数量：</p><ol><li>单个分片数据最好不要超过20G。</li><li>可以通过增加副本分片，来提高查询的吞吐量。</li></ol><h3 id="基于时间序列的数据" tabindex="-1">基于时间序列的数据 <a class="header-anchor" href="#基于时间序列的数据" aria-label="Permalink to &quot;基于时间序列的数据&quot;">​</a></h3><ul><li>日志、指标等数据</li></ul><p>这类数据特点</p><ul><li>每条数据都有时间戳，数据基本不会被更新。</li><li>用户更多是查询近期的数据，对旧数据关注较少。</li><li>对数据写入性能要求过高。</li></ul><p>按照时间对索引进行划分。</p><ul><li>在索引名称中增加时间信息</li><li>可以按天、按周或者按月划分。</li><li>根据时间做冷热数据分离。</li></ul><blockquote><p>云监控数据就是这样做的。</p></blockquote><h2 id="查询优化" tabindex="-1">查询优化 <a class="header-anchor" href="#查询优化" aria-label="Permalink to &quot;查询优化&quot;">​</a></h2><h3 id="索引拆分" tabindex="-1">索引拆分 <a class="header-anchor" href="#索引拆分" aria-label="Permalink to &quot;索引拆分&quot;">​</a></h3><p>如果单个索引有大量的数据，可以考虑将索引拆分为多个索引。</p><ul><li>减少单个索引数据量，提高查询性能</li><li>可以同时对多个索引进行查询。</li></ul><h3 id="按照字段划分" tabindex="-1">按照字段划分 <a class="header-anchor" href="#按照字段划分" aria-label="Permalink to &quot;按照字段划分&quot;">​</a></h3><p>如果根据某字段进行查询较多，而且该字段是一个枚举值。比如地区。</p><p>可以按照地区拆分索引。</p><h3 id="按照时间划分" tabindex="-1">按照时间划分 <a class="header-anchor" href="#按照时间划分" aria-label="Permalink to &quot;按照时间划分&quot;">​</a></h3><p>比如将数据按天划分索引，提高并发查询的效率。</p><h3 id="提高分片查询效率" tabindex="-1">提高分片查询效率 <a class="header-anchor" href="#提高分片查询效率" aria-label="Permalink to &quot;提高分片查询效率&quot;">​</a></h3><p>在写入数据的时候，尽量将数据平均写到每个分片里面，这样在查询的时候能够提高并发查询效率。（类似kafka的paritationKey）</p><p>es分片路由的规则: <code>shard_num = hash(_routing) % num_primary_shards</code></p><p>_routing字段的取值，默认是_id字段，可以自定义。</p><div class="language-yaml vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">yaml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">POST /users/_create/1?routing=fox{    &quot;name&quot;:&quot;fox&quot;}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div>`,105)]))}const m=l(t,[["render",n]]);export{c as __pageData,m as default};
