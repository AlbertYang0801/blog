import{_ as a,c as i,o as n,aN as e}from"./chunks/framework.A-MC8nKA.js";const E=JSON.parse('{"title":"Reactor模式","description":"","frontmatter":{},"headers":[],"relativePath":"java/io/Reactor模式.md","filePath":"java/io/Reactor模式.md","lastUpdated":1751453543000}'),l={name:"java/io/Reactor模式.md"};function t(p,s,h,r,k,c){return n(),i("div",null,s[0]||(s[0]=[e(`<h1 id="reactor模式" tabindex="-1">Reactor模式 <a class="header-anchor" href="#reactor模式" aria-label="Permalink to &quot;Reactor模式&quot;">​</a></h1><p><a href="https://www.jianshu.com/p/188ef8462100" target="_blank" rel="noreferrer">Reactor模式详解＋源码实现</a></p><p>整个 reactor 模式解决的主要问题就是在接收到任务后根据分发器快速进行分发给相应的事件处理器，不需要从<strong>开始状态就阻塞</strong>。</p><p>基于事件驱动模型，当接收到请求后会<strong>将请求封装成事件</strong>，并将<strong>事件分发给相应处理事件的Handler</strong>，handler处理完成后将事件状态修改为下一个状态，再由Reactor将事件分发给能够处理下一个状态的handler进行处理。</p><p><img src="https://s2.loli.net/2025/05/29/Tut6MdNnG7Zlz8i.png" alt="" loading="lazy"></p><ol><li><p>EventHandler：事件处理器，可以根据事件的不同状态创建处理不同状态的处理器；</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EventHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * 事件处理</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> event</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Event </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><ul><li>ReadEventHandler</li><li>AcceptEventHandler</li></ul></li><li><p>Handle：可以理解为事件，在网络编程中就是一个Socket，在数据库操作中就是一个DBConnection；</p><ul><li>Event</li></ul></li><li><p>InitiationDispatcher：用于管理EventHandler，分发event的容器，也是一个事件处理调度器，Tomcat 的 Dispatcher 就是一个很好的实现，用于接收到网络请求后进行第一步的任务分发，分发给相应的处理器去异步处理，来保证吞吐量；</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handlerEvents</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        ExecutorService executorService </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ThreadUtil.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newExecutor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //同步非阻塞</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //线程池异步提交</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        executorService.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">execute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dispatch);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> dispatch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            //从 selector 中阻塞获取数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            List&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; events </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> selector.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">select</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (Event event </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> events) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                //分发处理</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                EventHandler eventHandler </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> eventHandlerMap.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOrDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getEventType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(),</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Objects.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isNull</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(eventHandler)){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                    continue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                //处理事件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                eventHandler.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">handle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div></li><li><p>Demultiplexer：阻塞等待一系列的 Handle 中的事件到来，如果阻塞等待返回，即表示在返回的 Handle 中可以不阻塞的执行返回的事件类型。这个模块一般使用操作系统的select来实现。在 Java NIO 中用 Selector 来封装，当 <code>Selector.select()</code> 返回时，可以调用 Selector的 <code>selectedKeys()</code> 方法获取 <code>Set&lt;SelectionKey&gt;</code>，一个SelectionKey 表达一个有事件发生的 Channel 以及该 Channel 上的事件类型。</p></li></ol><p><strong>源码</strong></p><p><a href="https://gitee.com/zztiyjw/JavaAdvance/tree/master/moudle-netty/netty-practice" target="_blank" rel="noreferrer">Albert.Yang/JavaAdvance</a></p><h2 id="单线程reactor" tabindex="-1">单线程Reactor <a class="header-anchor" href="#单线程reactor" aria-label="Permalink to &quot;单线程Reactor&quot;">​</a></h2><p><img src="https://s2.loli.net/2025/05/29/NP3aIjnBZrl62Fc.png" alt="" loading="lazy"></p><ul><li>Reactor是一个线程对象，它会开始事件循环，内部使用 Selector（JDK内部使用epoll） 实现 IO多路复用。</li><li>Dispatch事件分发器，负责 event 分发以及 eventHandler 的维护。</li><li>注册AcceptorEventHandler处理器到Reactor，负责处理Accept类型事件。</li><li>READ、WRITE有自己的事件处理器。</li></ul><blockquote><p>这里的单线程指的是IO操作都在一个线程上，比如accept、wirte、read、connect等操作。</p></blockquote><h3 id="工作者线程池" tabindex="-1">工作者线程池 <a class="header-anchor" href="#工作者线程池" aria-label="Permalink to &quot;工作者线程池&quot;">​</a></h3><p>将非IO操作放到线程池。</p><p><img src="https://s2.loli.net/2025/05/29/MiDOgCkPHtKNZBG.png" alt="" loading="lazy"></p><h3 id="多线程主从reactor模式" tabindex="-1">多线程主从Reactor模式 <a class="header-anchor" href="#多线程主从reactor模式" aria-label="Permalink to &quot;多线程主从Reactor模式&quot;">​</a></h3><p><img src="https://s2.loli.net/2025/05/29/8uWltxMVkL47T92.png" alt="" loading="lazy"></p><ul><li>mainReactor：由主线程接收客户端连接请求。</li><li>subReactor：连接建立之后将通信转给subReactor。</li><li>ThreadPool：非IO操作还是放到线程池。</li></ul>`,18)]))}const o=a(l,[["render",t]]);export{E as __pageData,o as default};
