import{_ as t,c as l,o as e,aN as n}from"./chunks/framework.A-MC8nKA.js";const g=JSON.parse('{"title":"拥塞控制","description":"","frontmatter":{},"headers":[],"relativePath":"other/network/拥塞控制.md","filePath":"other/network/拥塞控制.md","lastUpdated":1752827268000}'),o={name:"other/network/拥塞控制.md"};function r(i,a,s,p,d,h){return e(),l("div",null,a[0]||(a[0]=[n('<h1 id="拥塞控制" tabindex="-1">拥塞控制 <a class="header-anchor" href="#拥塞控制" aria-label="Permalink to &quot;拥塞控制&quot;">​</a></h1><p>流量控制是避免数据填满发送方的缓冲区。</p><p>而拥塞控制是避免发送方的数据填满整个网络。</p><blockquote><p>在网络拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢包等。这个时候就会重传数据，但是一旦重传就会导致网络负担变得更重。于是会导致更大的延迟以及更多的丢包。</p></blockquote><p>在⽹络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包时延、丢失等，这时 <strong>TCP</strong> 就会重传数据，但是⼀重传就会导致⽹络的负担更重，于是会导致更⼤的延迟以及更多的丢包，这个情况就会进⼊恶性循环被不断地放⼤….</p><p>所以，TCP 不能忽略整个网络中发⽣的事，它被设计成⼀个⽆私的协议，当⽹络发送拥塞时，TCP 会⾃我牺牲，降低发送的数据流。</p><h2 id="拥塞窗口" tabindex="-1">拥塞窗口 <a class="header-anchor" href="#拥塞窗口" aria-label="Permalink to &quot;拥塞窗口&quot;">​</a></h2><p>拥塞窗⼝ <strong>cwnd</strong>是发送⽅维护的⼀个的状态变量，它会根据⽹络的拥塞程度动态变化的。</p><p>发送窗⼝ swnd 和接收窗⼝ rwnd 是约等于的关系，那么由于加⼊了拥塞窗⼝的概念后，此时发送窗⼝的值是 <code>swnd = min(cwnd, rwnd)</code>，也就是拥塞窗⼝和接收窗⼝中的最⼩值。</p><p>拥塞窗⼝ cwnd 变化的规则：</p><ul><li>只要⽹络中没有出现拥塞， cwnd 就会增⼤；</li><li>但⽹络中出现了拥塞， cwnd 就减少；</li></ul><h2 id="拥塞控制算法" tabindex="-1">拥塞控制算法 <a class="header-anchor" href="#拥塞控制算法" aria-label="Permalink to &quot;拥塞控制算法&quot;">​</a></h2><p><img src="https://s2.loli.net/2025/07/17/PSehOlIoxsrtvXQ.png" alt="image.png" loading="lazy"></p><h3 id="慢启动" tabindex="-1">慢启动 <a class="header-anchor" href="#慢启动" aria-label="Permalink to &quot;慢启动&quot;">​</a></h3><p>TCP建立连接之后，一开始不要发送大量数据。先探测一下网络的拥塞程度。然后逐渐增大拥塞窗口的大小。</p><ul><li>如果没有发生丢包，每收到一个ACK，将拥塞窗口 cwnd 大小加1。</li><li>每轮次发送窗口增加一倍，呈指数增长。如果出现丢包，拥塞窗口就减半，进入<strong>拥塞避免</strong>阶段。</li></ul><p><img src="https://s2.loli.net/2025/07/17/8sYR4HIm1ir2c3O.png" alt="image.png" loading="lazy"></p><p>发包的个数呈<strong>指数级增强</strong>。</p><p><img src="https://s2.loli.net/2025/07/17/XpNQAojuf9PnW6z.png" alt="image.png" loading="lazy"></p><p>为了防止拥塞窗口无限增长，还需要设置一个<strong>慢启动阀值 ssthresh</strong>（slow start threshold）状态变量。</p><p>当到达该阈值后，即 <strong>cwnd &gt;ssthresh</strong> 时，进入了<strong>拥塞避免</strong>算法。</p><h3 id="拥塞避免" tabindex="-1">拥塞避免 <a class="header-anchor" href="#拥塞避免" aria-label="Permalink to &quot;拥塞避免&quot;">​</a></h3><p>一般来说，慢启动阀值 ssthresh 是 65535 字节，<code>cwnd</code>到达<strong>慢启动阀值</strong>后</p><ul><li>每收到一个 ACK 时，cwnd = cwnd + 1/cwnd</li><li>当每过一个 RTT 时，cwnd = cwnd + 1</li></ul><p>显然这是一个线性上升的算法，避免过快导致网络拥塞问题。</p><blockquote><p>由指数级增长变为线性增长。</p></blockquote><p>假设 ssthresh = 8 ，没收到一个ACK，增加1/8，收到8个ACK之后，cwnd+1。</p><p><img src="https://s2.loli.net/2025/07/17/VMPCrGtHvZo4Ean.png" alt="image.png" loading="lazy"></p><h3 id="拥塞发生" tabindex="-1">拥塞发生 <a class="header-anchor" href="#拥塞发生" aria-label="Permalink to &quot;拥塞发生&quot;">​</a></h3><p>如果网络拥塞发生丢包时，会有两种情况：</p><ul><li>RTO超时重传</li><li>快速重传</li></ul><h3 id="rto超时重传" tabindex="-1">RTO超时重传 <a class="header-anchor" href="#rto超时重传" aria-label="Permalink to &quot;RTO超时重传&quot;">​</a></h3><p>如果发生RTO超时重传，会使用<strong>拥塞发生</strong>算法。</p><ul><li>慢启动阈值 sshthresh = cwnd</li><li>重置cwnd=1</li><li>开始新一轮的慢启动过程</li></ul><p><img src="https://s2.loli.net/2025/07/17/VSBEObwgloIseZQ.png" alt="image.png" loading="lazy"></p><h3 id="快速重传" tabindex="-1">快速重传 <a class="header-anchor" href="#快速重传" aria-label="Permalink to &quot;快速重传&quot;">​</a></h3><p>发送方如果因为网络问题接收到3个连续重复的ACK时，就会触发快速重传。不必等待超时。</p><p>发⽣快速重传的拥塞发⽣算法：</p><ul><li>拥塞窗口大小 cwnd = cwnd / 2</li><li>慢启动阀值 ssthresh = cwnd</li><li>进入<strong>快速恢复算法</strong></li></ul><blockquote><p>调整拥塞窗口为一半，然后进入快速恢复算法。</p></blockquote><h3 id="快速恢复" tabindex="-1">快速恢复 <a class="header-anchor" href="#快速恢复" aria-label="Permalink to &quot;快速恢复&quot;">​</a></h3><p>快速重传一般和快速恢复同时使用。</p><blockquote><p>快速恢复算法认为，还有三个重复ACK收到，说明网络也没有那么糟糕。不需要像RTO超时重传一样直接进入慢启动阶段。</p></blockquote><ul><li>cwnd = sshthresh + 3（窗口扩大3个）</li><li>重传重复的那几个 ACK（即丢失的那几个数据包）</li><li>如果再收到重复的 ACK，那么 cwnd = cwnd +1</li><li>如果收到新数据的 ACK 后, cwnd = sshthresh。因为收到新数据的 ACK，表明恢复过程已经结束，可以再次进入了拥塞避免的算法了。</li></ul><p><img src="https://s2.loli.net/2025/07/17/Zrs5nEAYQLKUVRv.png" alt="image.png" loading="lazy"></p><p>避免直接进入慢启动阶段。</p>',46)]))}const u=t(o,[["render",r]]);export{g as __pageData,u as default};
