import{_ as e,c as a,o as l,aN as t}from"./chunks/framework.A-MC8nKA.js";const u=JSON.parse('{"title":"Netty常用组件","description":"","frontmatter":{},"headers":[],"relativePath":"frame/netty/Netty常用组件.md","filePath":"frame/netty/Netty常用组件.md","lastUpdated":1752827238000}'),p={name:"frame/netty/Netty常用组件.md"};function o(i,n,r,h,d,s){return l(),a("div",null,n[0]||(n[0]=[t('<h1 id="netty常用组件" tabindex="-1">Netty常用组件 <a class="header-anchor" href="#netty常用组件" aria-label="Permalink to &quot;Netty常用组件&quot;">​</a></h1><h2 id="bootstrap" tabindex="-1">Bootstrap <a class="header-anchor" href="#bootstrap" aria-label="Permalink to &quot;Bootstrap&quot;">​</a></h2><p>Netty的启动类</p><ul><li><p>Bootstrap</p><p>客户端启动类</p></li><li><p>ServerBootstrap</p><p>服务端启动类</p></li></ul><p><img src="https://s2.loli.net/2025/06/13/XHBZvTLrlwQxGj7.png" alt="image.png" loading="lazy"></p><h4 id="第一个区别" tabindex="-1">第一个区别 <a class="header-anchor" href="#第一个区别" aria-label="Permalink to &quot;第一个区别&quot;">​</a></h4><ul><li><p>客户端需要连接到远程主机和端口即可。</p></li><li><p>服务端需要绑定端口。</p></li></ul><h4 id="第二个区别" tabindex="-1">第二个区别 <a class="header-anchor" href="#第二个区别" aria-label="Permalink to &quot;第二个区别&quot;">​</a></h4><ul><li><p>服务端需要两个 EventLoopGroup。</p><p>原因是使用了多线程主从的Reactor模式。</p><ul><li><p>第一个EventLoopGroup，只有一个EventLoop，负责为传入的Accept请求建立连接。一旦建立连接后续，将该 Channel 放到第二个 Group中进行请求处理。</p></li><li><p>第二个EventLoopGroup，存在多个EventLoop，为每个Channel都分配了EventLoop。</p></li></ul></li></ul><h2 id="eventloopgroup" tabindex="-1">EventLoopGroup <a class="header-anchor" href="#eventloopgroup" aria-label="Permalink to &quot;EventLoopGroup&quot;">​</a></h2><ul><li><p>EventLoop 是线程</p><p>服务于Channel的 I/O 和事件。一个Channel会被分配一个 EventLoop，而EventLoop可以被同时分配多个Channel，一个线程可以处理多个Channel的数据。</p></li><li><p>EventLoopGroup 是线程组</p><ul><li><p>对于<code>bossGroup</code>，由于它只负责接收连接请求，所以线程数通常设置为1（<code>new NioEventLoopGroup(1)</code>）。</p></li><li><p>对于<code>workerGroup</code>，线程数的默认值依赖于CPU的核心数。考虑到IO密集型操作的特点，Netty通常将<code>workerGroup</code>的线程数设置为CPU核心数的两倍（即<code>2 * 处理器线程数</code>），以便充分利用多核CPU的并行处理能力，并且考虑到可能有线程会处于等待状态，而其他线程可以继续运行，从而避免CPU的空闲。</p></li></ul><p><img src="https://s2.loli.net/2025/06/13/tOFUTa1cVnbLYsP.png" alt="image.png" loading="lazy"></p></li></ul><h2 id="channelfuture" tabindex="-1">ChannelFuture <a class="header-anchor" href="#channelfuture" aria-label="Permalink to &quot;ChannelFuture&quot;">​</a></h2><p>Netty中所有IO都是异步的。</p><p>Netty自己实现了 ChannelFuture，在出站 I/O 时会返回一个 ChannelFuture。</p><h2 id="channel" tabindex="-1">Channel <a class="header-anchor" href="#channel" aria-label="Permalink to &quot;Channel&quot;">​</a></h2><p>基本的 I/O 操作 bind()、connect()、read()和 write(）依赖于底层网络传输所提供的原</p><p>语。在基于 Java 的网络编程中，其基本的构造是类 Socket。</p><p><strong>Netty 的 Channel 接口所提供的 API，被用于所有的 I/O 操作</strong>。大大地降低了直接使用 Socket 类的复杂性。</p><h2 id="channelpipline" tabindex="-1">ChannelPipline <a class="header-anchor" href="#channelpipline" aria-label="Permalink to &quot;ChannelPipline&quot;">​</a></h2><p>每个Channel都有自己的 ChannelPipline。</p><p>就是ChannelHandler的事件流。底层以双向链表维护Handler。</p><p><img src="https://s2.loli.net/2025/06/13/ANGdbHC7ao9EweF.png" alt="image.png" loading="lazy"></p><h2 id="channelhandler" tabindex="-1">ChannelHandler <a class="header-anchor" href="#channelhandler" aria-label="Permalink to &quot;ChannelHandler&quot;">​</a></h2><p>ChannelHandler 是用来处理入站和出站数据的，开发人员主要关注的是这个类。</p><p>因为这个类里面可以去写业务逻辑。</p><p>Netty 定义了下面两个重要的 ChannelHandler 子接口：</p><p>ChannelInboundHandler —— 处理入站数据以及各种状态变化；</p><p>ChannelOutboundHandler —— 处理出站数据并且允许拦截所有的操作。</p><h3 id="channelinboundhandler" tabindex="-1">ChannelInboundHandler <a class="header-anchor" href="#channelinboundhandler" aria-label="Permalink to &quot;ChannelInboundHandler&quot;">​</a></h3><ul><li><p>channelRegistered</p><p>当 Channel 已经注册到它的 EventLoop 并且能够处理 I/O 时被调用</p></li><li><p>channelUnregistered</p><p>当 Channel 从它的 EventLoop 注销并且无法处理任何 I/O 时被调用</p></li><li><p><strong>channelActive</strong></p><p>当 Channel 处于活动状态时被调用；Channel 已经连接/绑定并且已经就绪</p></li><li><p>channelInactive</p><p>当 Channel 离开活动状态并且不再连接它的远程节点时被调用</p></li><li><p>channelReadComplete</p><p>当 Channel 上的一个读操作完成时被调用</p></li><li><p><strong>channelRead</strong></p><p>当从 Channel 读取数据时被调用</p></li></ul><h2 id="channeloption" tabindex="-1">ChannelOption <a class="header-anchor" href="#channeloption" aria-label="Permalink to &quot;ChannelOption&quot;">​</a></h2><ul><li><p><strong>ChannelOption.SO_BACKLOG</strong></p><p>ChannelOption.SO_BACKLOG 对应的是 tcp/ip 协议 listen 函数中的 backlog 参数，服务端处理客户端连接请求是顺序处理的，所以同一时间只能处理一个客户端连接，多个客户端来的时候，服务端将不能处理的客户端连接请求放在队列中等待处理。所以操作系统里一般有两个队列，一个是 ACCEPT 队列，保存着已经完成了 TCP 的三次握手的连接，一个 SYN 队列，服务器正在等待 TCP 的三次握手完成的队列。</p><p>BSD派生系统里<strong>backlog指的就是SYN队列的大小</strong>，在Linux的实现里backlog相对来说，就含糊不清了，有些内核版本指的是 ACCEPT 队列+SYN 队列合起来的大小，有的是指 SYN队列的大小。</p><p>但是从 Linux 2.2 开始，backlog 的参数行为在 Linux 2.2 中发生了变化，现在它指定<strong>等待接受的完全建立的套接字的队列长度</strong>，而不是不完整的连接请求的数量。</p></li><li><p><strong>ChannelOption.SO_REUSEAD</strong></p><p>ChanneOption.SO_REUSEADDR 对应于套接字选项中的 SO_REUSEADDR，这个参数表示允许重复使用本地地址和端口，比如，多网卡（IP）绑定相同端口，比如某个进程非正常退出，该程序占用的端口可能要被占用一段时间才能允许其他进程使用，而且程序死掉以后，内核一需要一定的时间才能够释放此端口，不设置 SO_REUSEADDR 就无法正常使用该端口。</p><p>但是注意，这个参数无法做到让应用绑定完全相同 IP + Port 来重复启动。</p></li><li><p><strong>ChannelOption.SO_KEEPALIVE</strong></p><p>Channeloption.SO_KEEPALIVE 参数对应于套接字选项中的 SO_KEEPALIVE，该参数用于设置 TCP 连接，当设置该选项以后，连接会测试链接的状态，这个选项用于可能长时间没有数据交流的连接。当设置该选项以后，如果在两小时内没有数据的通信时，TCP 会自动发送一个活动探测数据报文。</p></li><li><p><strong>ChannelOption.SO_SNDBUF 和 ChannelOption.SO_RCVBUF</strong></p><p>ChannelOption.SO_SNDBUF 参数对应于套接字选项中的 SO_SNDBUF，</p><p>ChannelOption.SO_RCVBUF 参数对应于套接字选项中的 SO_RCVBUF 这两个参数用于操作接收缓冲区和发送缓冲区的大小，接收缓冲区用于保存网络协议站内收到的数据，直到应用程序读取成功，发送缓冲区用于保存发送数据，直到发送成功。</p></li><li><p><strong>ChannelOption.SO_LINGER</strong></p><p>ChannelOption.SO_LINGER 参数对应于套接字选项中的 SO_LINGER,Linux 内核默认的处理方式是当用户调用 close（）方法的时候，函数返回，在可能的情况下，尽量发送数据，不一定保证会发生剩余的数据，造成了数据的不确定性，使用 SO_LINGER 可以阻塞 close()的调用时间，直到数据完全发送</p></li><li><p><strong>ChannelOption.TCP_NODELAY</strong></p><p>ChannelOption.TCP_NODELAY 参数对应于套接字选项中的 TCP_NODELAY,该参数的使用与 Nagle 算法有关，Nagle 算法是将小的数据包组装为更大的帧然后进行发送，而不是输入一次发送一次,因此在数据包不足的时候会等待其他数据的到了，组装成大的数据包进行发送，虽然该方式有效提高网络的有效负载，但是却造成了延时，而该参数的作用就是禁止使用 Nagle 算法，使用于小数据即时传输，于 TCP_NODELAY 相对应的是 TCP_CORK，该选项是需要等到发送的数据量最大的时候，一次性发送数据，适用于文件传输。</p></li></ul>',32)]))}const C=e(p,[["render",o]]);export{u as __pageData,C as default};
