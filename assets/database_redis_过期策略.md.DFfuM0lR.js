import{_ as l,c as i,o as a,aN as t}from"./chunks/framework.A-MC8nKA.js";const u=JSON.parse('{"title":"过期策略","description":"","frontmatter":{},"headers":[],"relativePath":"database/redis/过期策略.md","filePath":"database/redis/过期策略.md","lastUpdated":1752827238000}'),r={name:"database/redis/过期策略.md"};function p(s,e,o,d,n,h){return a(),i("div",null,e[0]||(e[0]=[t('<h1 id="过期策略" tabindex="-1">过期策略 <a class="header-anchor" href="#过期策略" aria-label="Permalink to &quot;过期策略&quot;">​</a></h1><p>在 Redis 中设置了过期时间的 key，在一定时间后都会被删除。</p><h2 id="键的过期时间" tabindex="-1">键的过期时间 <a class="header-anchor" href="#键的过期时间" aria-label="Permalink to &quot;键的过期时间&quot;">​</a></h2><h3 id="配置过期时间" tabindex="-1">配置过期时间 <a class="header-anchor" href="#配置过期时间" aria-label="Permalink to &quot;配置过期时间&quot;">​</a></h3><ol><li><p><code>setex key seconds value</code></p><p>设置 key 时添加过期时间</p></li><li><p><code>expire key seconds</code></p><p>为某个 key 设置过期时间。</p></li><li><p>删除 key 的过期时间。</p><p><code>persist key</code></p></li><li><p>查看 key 的过期时间</p><p><code>ttl key</code></p></li></ol><h3 id="redis保存过期时间分析" tabindex="-1">redis保存过期时间分析 <a class="header-anchor" href="#redis保存过期时间分析" aria-label="Permalink to &quot;redis保存过期时间分析&quot;">​</a></h3><p><a href="https://blog.csdn.net/jiangchunhui2009/article/details/81504073" target="_blank" rel="noreferrer">版权声明：本文为CSDN博主「梦里寻乡」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/jiangchunhui2009/article/details/81504073</a></p><p><img src="https://s2.loli.net/2025/06/18/d6GYkf5WqyDgQU7.png" alt="" loading="lazy"></p><p><img src="https://s2.loli.net/2025/06/18/BNCFI79RrifmX2b.png" alt="" loading="lazy"></p><p><img src="https://s2.loli.net/2025/06/18/V4XwMZSOECUrzbd.png" alt="" loading="lazy"></p><p><img src="https://s2.loli.net/2025/06/18/UEGvso83b67tFkH.png" alt="" loading="lazy"></p><h2 id="三种过期策略" tabindex="-1">三种过期策略 <a class="header-anchor" href="#三种过期策略" aria-label="Permalink to &quot;三种过期策略&quot;">​</a></h2><ol><li><p>定时删除</p><ul><li><p>含义</p><p>设置 key 过期时间时，为 key 创建一个定时器，当这个 key 到达过期时间时，定时器会将其删除。</p></li><li><p>优点</p><p>保证过期的 key 能够及时被删除，释放内存空间。（以时间换空间）</p></li><li><p>缺点</p><ul><li>由于每个设置了过期时间的 key 都有一个定时器，会严重影响性能。</li><li>定时器删除 key 的操作会占用 CPU 资源，在高并发情况下影响 CPU 性能。</li></ul></li></ul></li><li><p>惰性删除</p><ul><li><p>含义</p><p>在 key 过期的时候不会主动删除，而是在使用 key 的时候，先检查 key 是否过期，若过期，则删除这个 key 并返回 null。</p></li><li><p>优点</p><p>key 过期后只有在再次使用的时候才会将其删除，大大减小了 CPU 资源的使用。（以空间换时间）</p></li><li><p>缺点</p><p>若大量的 key 过期之后，若很长时间不使用，则 key 在内存中无法被删除，容易造成内存泄露。</p></li></ul></li><li><p>定期删除</p><ul><li><p>含义</p><p>每隔一段时间主动执行删除过期 key 的操作。</p></li><li><p>优点</p><ul><li>定期删除过期 key，能保证内存泄露不会发生，解决了惰性删除的缺点。（时间和空间的折中）</li><li>通过定期来限制删除过期 key 的频率和时长，来减少 CPU 资源的使用。</li></ul></li><li><p>缺点</p><ul><li>在 CPU 时间优化，不如惰性删除。</li><li>在内存空间优化上，不如定时删除。</li></ul></li><li><p>难点</p><ul><li>合理的设置定期删除的执行时间和执行频率</li></ul></li></ul></li></ol><h2 id="redis采用的过期策略" tabindex="-1">redis采用的过期策略 <a class="header-anchor" href="#redis采用的过期策略" aria-label="Permalink to &quot;redis采用的过期策略&quot;">​</a></h2><p>redis 采用的是 <strong>定期删除 + 惰性删除</strong>。</p><h3 id="redis-的定期删除" tabindex="-1">redis 的定期删除 <a class="header-anchor" href="#redis-的定期删除" aria-label="Permalink to &quot;redis 的定期删除&quot;">​</a></h3><p>redis会将每个设置了过期时间的 key 放入独立的字典中，默认每隔 100 ms 进行一次扫描（1s 中执行 10 次），每次扫描的任务时间是 25ms 。</p><ol><li>遍历每个数据库（redis 默认数据库 16 个）。</li><li>从数据库随机抽取 20 个 key。</li><li>删除这 20 个 key 中过期的 key。</li><li>如果过期的 key 存在比例超过 1/4，重复步骤。</li><li>判断定期删除操作是否达到指定的操作时长，若达到，退出定期删除。</li></ol><p><img src="https://s2.loli.net/2025/06/18/gSZQ5XquCIYtosv.png" alt="" loading="lazy"></p><p><a href="https://zhuanlan.zhihu.com/p/91212102" target="_blank" rel="noreferrer"></a></p><h3 id="redis-的惰性删除" tabindex="-1">redis 的惰性删除 <a class="header-anchor" href="#redis-的惰性删除" aria-label="Permalink to &quot;redis 的惰性删除&quot;">​</a></h3><ul><li>在进行 get 或者 setnx 等操作时，会先检查 key 是否过期。</li><li>若过期，先删除 key ，再执行相应操作。</li><li>若未过期，执行相应操作。</li></ul><h3 id="rdb-对过期-key-的处理" tabindex="-1">RDB 对过期 key 的处理 <a class="header-anchor" href="#rdb-对过期-key-的处理" aria-label="Permalink to &quot;RDB 对过期 key 的处理&quot;">​</a></h3><ul><li><p>从 内存 -&gt; RDB 文件</p><p>持久化 key 之前，会判断 key 是否过期，过期的 key 不存入 RDB 文件。</p></li><li><p>从 RDB 文件 -&gt; 内存</p><p>数据存入内存数据库之前，会检查 key 是否过期，若过期，不导入内存数据库。（主库情况）</p></li></ul><h3 id="aof-对过期-key-的处理" tabindex="-1">AOF 对过期 key 的处理 <a class="header-anchor" href="#aof-对过期-key-的处理" aria-label="Permalink to &quot;AOF 对过期 key 的处理&quot;">​</a></h3><ul><li>从内存 -&gt; AOF 文件 <ul><li>当 key 过期后，还没被删除的话，此时进行执行持久化操作（该 key 没有 aof 文件，因为没有发生修改）。</li><li>当 key 过期后，在发生删除时，程序会向 AOF 文件追加一条 del 命令（在将来从 AOF 文件恢复数据时该过期键会被删除）。</li></ul></li><li>AOF 文件重写 <ul><li>重写时，会先判断 key 是否过期，已过期的 key 不会重写到 AOF 文件。</li></ul></li></ul>',26)]))}const c=l(r,[["render",p]]);export{u as __pageData,c as default};
