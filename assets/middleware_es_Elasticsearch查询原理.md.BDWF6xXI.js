import{_ as e,c as t,o as l,aN as i}from"./chunks/framework.A-MC8nKA.js";const m=JSON.parse('{"title":"Elasticsearch查询原理","description":"","frontmatter":{},"headers":[],"relativePath":"middleware/es/Elasticsearch查询原理.md","filePath":"middleware/es/Elasticsearch查询原理.md","lastUpdated":1752827238000}'),r={name:"middleware/es/Elasticsearch查询原理.md"};function s(o,a,c,d,n,p){return l(),t("div",null,a[0]||(a[0]=[i('<h1 id="elasticsearch查询原理" tabindex="-1">Elasticsearch查询原理 <a class="header-anchor" href="#elasticsearch查询原理" aria-label="Permalink to &quot;Elasticsearch查询原理&quot;">​</a></h1><h2 id="es查询原理" tabindex="-1">ES查询原理 <a class="header-anchor" href="#es查询原理" aria-label="Permalink to &quot;ES查询原理&quot;">​</a></h2><h3 id="查询方式" tabindex="-1">查询方式 <a class="header-anchor" href="#查询方式" aria-label="Permalink to &quot;查询方式&quot;">​</a></h3><ul><li>根据 doc_id 查询。</li></ul><p><img src="https://pic4.zhimg.com/v2-1289ee073a8f14b5aa57c3e715c685df_b.jpg" alt="" loading="lazy"></p><ul><li>根据条件查询</li></ul><p><img src="https://s2.loli.net/2025/06/26/YJa89sePfzlLIkE.jpg" alt="v2-1154c0210c32adc80122669d85f6f17e_b.jpeg" loading="lazy"></p><h3 id="倒排索引" tabindex="-1">倒排索引 <a class="header-anchor" href="#倒排索引" aria-label="Permalink to &quot;倒排索引&quot;">​</a></h3><p>根据文档中的每个字段建立倒排索引。</p><h3 id="倒排索引的查询流程" tabindex="-1">倒排索引的查询流程 <a class="header-anchor" href="#倒排索引的查询流程" aria-label="Permalink to &quot;倒排索引的查询流程&quot;">​</a></h3><p><img src="https://s2.loli.net/2025/06/26/NM9LbrgoVu4nF2S.png" alt="e0aab1ab4801427eb0b750753a64b6a1.png" loading="lazy"></p><ol><li>查询条件分词。</li><li>查询单词词典 （term dictionary）。</li><li>获取对应分词的 doc_id 列表。</li><li>将查询结果返回。</li></ol><blockquote><p>不需要分词的字段，直接使用 keyword 类型，查询的时候不需要分词，查询效率会更高。</p></blockquote><h3 id="倒排索引的组成" tabindex="-1">倒排索引的组成 <a class="header-anchor" href="#倒排索引的组成" aria-label="Permalink to &quot;倒排索引的组成&quot;">​</a></h3><ul><li><p><strong>postings list</strong></p><p>文档列表。</p></li><li><p><strong>term dictionary</strong></p><p>单词字典表。包含文档中所有的单词，es 会将单词排序。</p><blockquote><p>单词字典表为了快速查找，按照理论应该放到内存中。但是 es 默认可以对所有字段进行索引，单词 （term）的量会非常大，直接放到内存，内存肯定会爆的。所以需要引入其它数据结构来帮助查询单词字典表。</p></blockquote></li><li><p><strong>term index</strong></p><p>类似字典树，专门处理字符串匹配的数据结构。它里面存放的是 单词（term）的前缀，对应数据存放的是 term dictionary 中的对应前缀的第一个 offset，然后从该 offset 顺序查找即可快速查到对应的单词（term）。</p><p><img src="https://s2.loli.net/2025/06/26/egDOGZcyi64wKa7.jpg" alt="v2-6f9d8c077c8265bf0bf3b153fd62b2f9_b.jpg" loading="lazy"></p><p>当数据量不断增加时，内存中放不下 Term index。针对这种情况，es 采用了 FST 数据结构来压缩 Term index。</p></li></ul>',15)]))}const b=e(r,[["render",s]]);export{m as __pageData,b as default};
