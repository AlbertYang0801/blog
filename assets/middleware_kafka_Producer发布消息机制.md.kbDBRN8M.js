import{_ as a,c as r,o,aM as t}from"./chunks/framework.Du1sph90.js";const P=JSON.parse('{"title":"Producer发布消息机制","description":"","frontmatter":{},"headers":[],"relativePath":"middleware/kafka/Producer发布消息机制.md","filePath":"middleware/kafka/Producer发布消息机制.md","lastUpdated":1752827238000}'),i={name:"middleware/kafka/Producer发布消息机制.md"};function l(d,e,p,n,s,c){return o(),r("div",null,e[0]||(e[0]=[t('<h1 id="producer发布消息机制" tabindex="-1">Producer发布消息机制 <a class="header-anchor" href="#producer发布消息机制" aria-label="Permalink to &quot;Producer发布消息机制&quot;">​</a></h1><h2 id="写入机制" tabindex="-1">写入机制 <a class="header-anchor" href="#写入机制" aria-label="Permalink to &quot;写入机制&quot;">​</a></h2><p>Producer 通过<strong>push模式</strong>将消息发给 Broker，每条消息都被追加到对应的 Partition。而且是采用顺序写磁盘的方式（顺序写比随机写效率高，保障 Kafka 高吞吐量）。</p><h2 id="消息路由模式" tabindex="-1">消息路由模式 <a class="header-anchor" href="#消息路由模式" aria-label="Permalink to &quot;消息路由模式&quot;">​</a></h2><p>Producer 如何确认消息发到哪个 Partition 上？</p><ol><li><p>指定了 Partition，直接使用。</p></li><li><p>如果未指定 Partition，指定了 Key。根据 Key 的 Hash 值计算 Partition。</p><p>Hash(key) % num(Partition)</p></li><li><p>如果未指定 Partition，也未指定 key。则采用<strong>轮询策略</strong>选出一个 Partition**。**</p></li></ol><h2 id="写入流程" tabindex="-1">写入流程 <a class="header-anchor" href="#写入流程" aria-label="Permalink to &quot;写入流程&quot;">​</a></h2><p><img src="https://s2.loli.net/2025/06/26/gZ6jyFw2N45aWXq.png" alt="image.png" loading="lazy"></p><ol><li><p>Producerr 先从 zookeeper 的 “/brokers/…/state” 节点找到该 partition 的 leader。</p></li><li><p>Producer 将消息发给该 Leader。</p></li><li><p>Leader 将消息写入本地 Log。</p></li><li><p>Followers 从Leader 采用 pull 的方式同步消息，写入本地 log 后将 ACK 传给 Leader。</p></li><li><p>Leader 收到 LSR 中所有 Followers 的 ACK 标志后，增加 HW。然后向 Producer 发送 ACK。</p><blockquote><p>假如 acks=1，这个时候消息只发送给了 Leader，并不能确保每个 Follower同步了消息。如果 Leader 此时挂了，从 LSR中重新选举了 Leader，这部分消息就有可能丢失。</p></blockquote></li></ol>',9)]))}const _=a(i,[["render",l]]);export{P as __pageData,_ as default};
