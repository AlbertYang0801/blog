import{_ as a,c as i,o as n,ag as l}from"./chunks/framework.D7pKEi_Q.js";const c=JSON.parse('{"title":"synchronized原理","description":"","frontmatter":{},"headers":[],"relativePath":"java/concurrent/single/synchronized原理.md","filePath":"java/concurrent/single/synchronized原理.md"}'),e={name:"java/concurrent/single/synchronized原理.md"};function t(p,s,h,r,o,k){return n(),i("div",null,s[0]||(s[0]=[l(`<h1 id="synchronized原理" tabindex="-1">synchronized原理 <a class="header-anchor" href="#synchronized原理" aria-label="Permalink to &quot;synchronized原理&quot;">​</a></h1><p><a href="https://blog.csdn.net/qq_43061290/article/details/124187639" target="_blank" rel="noreferrer">synchronized原理详解（通俗易懂超级好）-CSDN博客</a></p><h2 id="特性" tabindex="-1">特性 <a class="header-anchor" href="#特性" aria-label="Permalink to &quot;特性&quot;">​</a></h2><ul><li><p>原子性</p><p>synchronized 修饰的对象或类所有操作都是原子性的。线程需要获取锁，保证整个操作过程的原子性。</p><p>比如 i++这种赋值操作。</p></li><li><p>可见性</p><p>一个线程如果要访问该类或对象必须先获得它的锁，而这个<strong>锁的状态对于其他任何线程都是可见</strong>的，并且在<strong>释放锁之前会将对变量的修改刷新到主存当中</strong>，<strong>保证资源变量的可见性。</strong></p><p>如果某个线程占用了该锁，其他线程就必须在锁池中等待锁的释放。</p></li><li><p>有序性</p><p>保证只有一个线程访问，确保了有序性。</p></li><li><p>可重入性</p><p>支持同一个线程对资源的重复加锁。</p></li></ul><h3 id="synchronized和volatile区别" tabindex="-1">synchronized和volatile区别 <a class="header-anchor" href="#synchronized和volatile区别" aria-label="Permalink to &quot;synchronized和volatile区别&quot;">​</a></h3><ol><li>都具备可见性。</li><li>都具备有序性。</li><li>synchronized 具备原子性，但是volatile 不具备原子性。</li></ol><hr><h3 id="volatile" tabindex="-1">volatile <a class="header-anchor" href="#volatile" aria-label="Permalink to &quot;volatile&quot;">​</a></h3><ul><li><p>可见性</p><p>被volatile修饰的变量，每当<strong>值需要修改时都会立即更新主存</strong>，<strong>主存是共享的</strong>，所有线程可见，所以确保了其他线程读取到的变量永远是最新值，保证可见性。</p></li><li><p>有序性</p><p><strong>禁止指令重排</strong>，保证指令有序性。</p></li></ul><h2 id="用法" tabindex="-1">用法 <a class="header-anchor" href="#用法" aria-label="Permalink to &quot;用法&quot;">​</a></h2><h3 id="同步代码块" tabindex="-1">同步代码块 <a class="header-anchor" href="#同步代码块" aria-label="Permalink to &quot;同步代码块&quot;">​</a></h3><p>重点是保证多个线程的锁对象是一致的。</p><ul><li>this作为锁对象</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//this的锁对象指当前类的实例</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>当前类作为锁对象</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//使用当前类作为锁对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (SynchrodizedCodebolck.class) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>不变对象作为锁对象</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object OBJECT </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//正确使用对象作为锁</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (OBJECT) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    n</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><hr><h3 id="同步方法" tabindex="-1">同步方法 <a class="header-anchor" href="#同步方法" aria-label="Permalink to &quot;同步方法&quot;">​</a></h3><p>synchronized 加在普通方法上或者静态方法上，可实现同步方法。</p><ul><li>同步普通方法 普通同步方法，锁对象为当前类的实例对象等同于this。</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> synchronized</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> increaseI</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    等价于</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> increase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre></div><ul><li>同步静态方法 静态同步方法，锁对象为当前类对象</li></ul><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> synchronized</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> increaseM</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        m</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    等价于</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> increase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        synchronized</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (NumberOperatingStatic.class) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            m</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre></div><h2 id="底层原理" tabindex="-1">底层原理 <a class="header-anchor" href="#底层原理" aria-label="Permalink to &quot;底层原理&quot;">​</a></h2><h3 id="实例对象头" tabindex="-1">实例对象头 <a class="header-anchor" href="#实例对象头" aria-label="Permalink to &quot;实例对象头&quot;">​</a></h3><p>堆里面的对象包含三部分：</p><ul><li><p>对象头</p><ol><li><p>Mark Word：存储的是对象的 hashCode、<strong>锁信息</strong>、或分代年龄、GC标注等信息。</p><p><img src="https://s2.loli.net/2025/05/28/wEZqSUj4CBtlibD.png" alt="image-20250528163142320"></p></li><li><p>Class Metadata Address： <strong>存储对象所属类(元数据) 的指针</strong>，JVM通过这个确定这个对象属于哪个类。</p></li></ol></li><li><p>对象实例数据</p></li><li><p>对齐填充</p><p><img src="https://s2.loli.net/2025/05/28/jIr2yAmUBJegiRc.png" alt="image-20250528163154481"></p></li></ul><h3 id="monitor对象-重量级锁" tabindex="-1">Monitor对象（重量级锁） <a class="header-anchor" href="#monitor对象-重量级锁" aria-label="Permalink to &quot;Monitor对象（重量级锁）&quot;">​</a></h3><p>每一个锁都对应一个<strong>Monitor对象</strong>，每个对象都有一个与之关联的Monitor对象，在HotSpot虚拟机中它是由ObjectMonitor实现的(C++实现)。</p><p>Monitor 对象<strong>存在于每个Java对象的对象头里</strong> (存储的指针的指向)。</p><blockquote><p>当一个线程执行synchronized(obj)这段代码时，obj对象就会与操作系统提供的Monitor对象相关联，即用一个指针指向Monitor 对象，其地址存储在MarkWord里。</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>//详细介绍重要变量的作用</span></span>
<span class="line"><span>ObjectMonitor() {</span></span>
<span class="line"><span>    _header       = NULL;</span></span>
<span class="line"><span>    _count        = 0;   // 重入次数</span></span>
<span class="line"><span>    _waiters      = 0,   // 等待线程数</span></span>
<span class="line"><span>    _recursions   = 0;</span></span>
<span class="line"><span>    _object       = NULL;</span></span>
<span class="line"><span>    _owner        = NULL;  // 当前持有锁的线程</span></span>
<span class="line"><span>    _WaitSet      = NULL;  // 调用了 wait 方法的线程被阻塞 放置在这里</span></span>
<span class="line"><span>    _WaitSetLock  = 0 ;</span></span>
<span class="line"><span>    _Responsible  = NULL ;</span></span>
<span class="line"><span>    _succ         = NULL ;</span></span>
<span class="line"><span>    _cxq          = NULL ;</span></span>
<span class="line"><span>    FreeNext      = NULL ;</span></span>
<span class="line"><span>    _EntryList    = NULL ; // 等待锁 处于block的线程 有资格成为候选资源的线程</span></span>
<span class="line"><span>    _SpinFreq     = 0 ;</span></span>
<span class="line"><span>    _SpinClock    = 0 ;</span></span>
<span class="line"><span>    OwnerIsThread = 0 ;</span></span>
<span class="line"><span>  }</span></span></code></pre></div><ul><li><p><code>_owner</code>：指向获得 <code>ObjectMonitor</code> 对象的线程。（即获得锁的线程）</p></li><li><p><code>_EntryList</code>：处于等待锁 <code>block</code> 状态的线程，会被加入到这里。</p></li><li><p><code>_WaitSet</code>：处理 <code>wait</code> 状态的线程，会被加入到这里。（调用同步对象 <code>wait</code> 方法）</p><blockquote><p>wati状态线程已经获取锁然后主动等待，在业务完成后，等待 notify 唤醒。block 是阻塞状态，指的是没获取到锁。</p></blockquote></li></ul><blockquote><p>这里 synchronized 是以 monitor 对象为基础实现的同步，加锁的对象里面存了指向 monitor 对象的指针。而在并发情况下时，线程会竞争 monitor，只有竞争到monitor 的才持有锁。其它线程会进入 wait 或者 block 状态。</p></blockquote><h2 id="锁升级" tabindex="-1">锁升级 <a class="header-anchor" href="#锁升级" aria-label="Permalink to &quot;锁升级&quot;">​</a></h2><p>无锁 &lt; 偏向锁 &lt; 轻量级锁 &lt; 重量级锁</p><p><img src="https://s2.loli.net/2025/05/28/CQpo2cP4rubh3kN.png" alt="image-20250528163326356"></p><h3 id="重量级锁" tabindex="-1">重量级锁 <a class="header-anchor" href="#重量级锁" aria-label="Permalink to &quot;重量级锁&quot;">​</a></h3><p>monitor 是互斥锁，持有锁线程会阻塞其它线程。是一个重量级锁。</p><p><strong>缺点是线程开销很大。</strong></p><blockquote><p>在线程获取锁之后，会阻塞其它需要锁的线程。线程阻塞情况下是不消耗资源的，但是将线程阻塞和将线程唤醒的过程是比较消耗资源的。因为线程是系统资源，需要从用户态切换到用户态执行阻塞和唤醒。</p></blockquote><p>原理就是依赖锁的 moniotr对象来保证只有一个线程能获取锁，而且会阻塞其它线程。</p><h3 id="偏向锁" tabindex="-1">偏向锁 <a class="header-anchor" href="#偏向锁" aria-label="Permalink to &quot;偏向锁&quot;">​</a></h3><p>偏向锁假定将来只有第一个申请锁的线程会使用锁。</p><p>只需要在对象头的 Mark Word 中进行一次 CAS 记录 owner。</p><p>如果记录成功，则偏向锁获取成功，记录<strong>锁状态为偏向锁</strong>，以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，升级<strong>为轻量级锁</strong>。</p><h3 id="为什么要引入偏向锁" tabindex="-1">为什么要引入偏向锁 <a class="header-anchor" href="#为什么要引入偏向锁" aria-label="Permalink to &quot;为什么要引入偏向锁&quot;">​</a></h3><p>引入偏向锁是为了在<strong>无多线程竞争的情况下尽量减少不必要</strong>的CAS 操作，因为轻量级锁的获取及释放<strong>依赖多次 CAS 原子指令</strong>，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令，代价就是一旦出现多线程竞争的情况就必须撤销偏向锁。</p><h3 id="轻量级锁" tabindex="-1">轻量级锁 <a class="header-anchor" href="#轻量级锁" aria-label="Permalink to &quot;轻量级锁&quot;">​</a></h3><p>当有别的线程参与到偏向锁的竞争中时，会先判断 markword 中的线程ID与这个线程是否一致，如果不一致，则会立即撤销偏向锁，升级为<strong>轻量级锁</strong>。</p><h3 id="加锁原理" tabindex="-1">加锁原理 <a class="header-anchor" href="#加锁原理" aria-label="Permalink to &quot;加锁原理&quot;">​</a></h3><p>每个线程都会在自己的栈中维护一个 <code>LockRecord(LR)</code>，然后每个线程在竞争锁时，都试图将锁对象头中的<code>markword</code> 设置为指向自己LR的指针，哪个线程设置成功，则意味着哪个线程成功获取到锁。</p><p><strong>Lock record就是栈中的锁记录。</strong></p><p>轻量级锁是多线程并发的，如果获取锁失败，表示有其他线程竞争锁，当前线程便<strong>尝试使用自旋来获取锁</strong>。如果在<strong>自旋一定次数后仍未获得锁，那么轻量级锁将会升级成重量级锁</strong>。</p><blockquote><p>当线程的自旋次数过长依旧没获取到锁，为避免CPU无端耗费，锁由轻量级锁升级为重量级锁。</p></blockquote><p><img src="https://s2.loli.net/2025/05/28/wEZqSUj4CBtlibD.png" alt="image-20250528163340960"></p><h2 id="可见性" tabindex="-1">可见性 <a class="header-anchor" href="#可见性" aria-label="Permalink to &quot;可见性&quot;">​</a></h2><h3 id="synchronized怎么保证可见性" tabindex="-1">synchronized怎么保证可见性 <a class="header-anchor" href="#synchronized怎么保证可见性" aria-label="Permalink to &quot;synchronized怎么保证可见性&quot;">​</a></h3><p>在Java内存模型（JMM）中，每个线程都有自己的工作内存，里面保存了使用变量的副本。</p><p>主内存保存着原始变量。</p><p>当代码进入 synchronized 快时，会从主内存加载最新变量到工作内存。而结束之后会把工作内存的变量刷新回主内存。</p><p>这样就保证了可见性。</p>`,64)]))}const g=a(e,[["render",t]]);export{c as __pageData,g as default};
