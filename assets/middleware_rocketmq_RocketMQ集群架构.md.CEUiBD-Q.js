import{_ as r,c as a,o,aN as t}from"./chunks/framework.A-MC8nKA.js";const k=JSON.parse('{"title":"RocketMQ集群架构","description":"","frontmatter":{},"headers":[],"relativePath":"middleware/rocketmq/RocketMQ集群架构.md","filePath":"middleware/rocketmq/RocketMQ集群架构.md","lastUpdated":1752827238000}'),l={name:"middleware/rocketmq/RocketMQ集群架构.md"};function c(i,e,p,m,n,d){return o(),a("div",null,e[0]||(e[0]=[t('<h1 id="rocketmq集群架构" tabindex="-1">RocketMQ集群架构 <a class="header-anchor" href="#rocketmq集群架构" aria-label="Permalink to &quot;RocketMQ集群架构&quot;">​</a></h1><p><img src="https://s2.loli.net/2025/06/27/6bzUj2mgCl8NJxH.png" alt="image.png" loading="lazy"></p><p>NameServer：提供Broker的路由服务</p><p>Broker：负责接收Producer的消息，存储消息，将消息投递给Consumer。</p><ul><li>Broker需要管理数据，频繁处理数据，所以需要G1、ZGC这种更先进的垃圾回收器。</li><li>而NameServer类似于Broker的注册中心，提供路由功能，只需要简单的垃圾回收算法就可以，比如CMS。</li></ul><p>Producer：生产者</p><p>Consumer：消费者</p><h2 id="集群架构说明" tabindex="-1">集群架构说明 <a class="header-anchor" href="#集群架构说明" aria-label="Permalink to &quot;集群架构说明&quot;">​</a></h2><p>整个RocketMQ集群里面主要分为两部分，Broker和NameServer。</p><p>整个RocketMQ遵循的是AP架构，追求可用性。</p><h3 id="nameserver" tabindex="-1">NameServer <a class="header-anchor" href="#nameserver" aria-label="Permalink to &quot;NameServer&quot;">​</a></h3><p>NameServer 作为注册中心，主要提供路有能力。只需要简单的集群架构提高并发能力即可。</p><p>NameServer 之间不进行数据同步，允许 NameServer 之间的数据不一致出现，等待 Borker 心跳上报数据，实现最终一致性即可。</p><h3 id="broker" tabindex="-1">Broker <a class="header-anchor" href="#broker" aria-label="Permalink to &quot;Broker&quot;">​</a></h3><p>Broker作为数据存储，具有频繁读写的特性。</p><p>按照读写分离架构设计集群，</p>',16)]))}const _=r(l,[["render",c]]);export{k as __pageData,_ as default};
