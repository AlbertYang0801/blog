import{_ as l,c as e,o as t,aM as i}from"./chunks/framework.Du1sph90.js";const B=JSON.parse('{"title":"B树和B+树","description":"","frontmatter":{},"headers":[],"relativePath":"database/mysql/B树和B+树.md","filePath":"database/mysql/B树和B+树.md","lastUpdated":1752827238000}'),o={name:"database/mysql/B树和B+树.md"};function r(p,a,n,s,d,h){return t(),e("div",null,a[0]||(a[0]=[i('<h1 id="b树和b-树" tabindex="-1">B树和B+树 <a class="header-anchor" href="#b树和b-树" aria-label="Permalink to &quot;B树和B+树&quot;">​</a></h1><h2 id="b树" tabindex="-1">B树 <a class="header-anchor" href="#b树" aria-label="Permalink to &quot;B树&quot;">​</a></h2><p><img src="https://s2.loli.net/2025/06/13/TkBtqpCgMW3wl7X.png" alt="" loading="lazy"></p><p>每个节点是一个磁盘快。每个磁盘快有固定大小，可以存储多个K-V键值对。</p><p>每个磁盘快包含指向下层节点的指针，方便查找。</p><p><em>由于每个节点存储了更多的键值对数据，可以有效降低查找树的次数，并减少查询磁盘。</em></p><ul><li></li></ul><h2 id="b-树" tabindex="-1">B+树 <a class="header-anchor" href="#b-树" aria-label="Permalink to &quot;B+树&quot;">​</a></h2><p><img src="https://s2.loli.net/2025/06/13/EFOX5ywcgCAjNWk.png" alt="" loading="lazy"></p><h3 id="存储空间" tabindex="-1">存储空间 <a class="header-anchor" href="#存储空间" aria-label="Permalink to &quot;存储空间&quot;">​</a></h3><p>B+树是在B树的基础上演进的。</p><p>B+树的非叶子结点是不保存数据的，仅保存键值。</p><p>在 InnoDB中页大小是固定的，在只保存键值的情况下，同一个数据页能保存更多的键值。这样就能保证整个树的层级大大降低，减少向下搜索时候的磁盘IO次数，会提高数据的查询效率。</p><p><strong>InnoDB 中页的默认大小是 16KB。</strong></p><p>假如每页能存储1000个数据，3层B+树就可以保存 1000<em>1000</em>1000 = 10亿条数据。</p><p>由于根结点的数据常驻内存，那么查询10亿条以内的数据只需要进行2次磁盘IO，就能找到数据所在的页。</p><hr><h3 id="有序存储" tabindex="-1">有序存储 <a class="header-anchor" href="#有序存储" aria-label="Permalink to &quot;有序存储&quot;">​</a></h3><p>数据都保存在B+树的叶子节点上，而每个叶子节点对应一个页（磁盘快）。</p><p>每个单独的页会对数据进行分组，分组时选出记录最小值，维护到<code>有序数组</code>。每一组都是一个<code>单向链表</code>。</p><p><strong>索引定位到page后，如何定位数据？</strong></p><ol><li>根据有序数组，通过<code>二分法</code>查找到对应的分组。</li><li>根据分组中的最小记录，按照单向链表去查找数据，直到查到为止。</li></ol><p><img src="https://s2.loli.net/2025/06/13/fKm9Ji6uQbZxnCa.png" alt="" loading="lazy"></p><hr><p>由于叶子节点数据的有序性，在顺序查找，排序，范围查找场景时，B+树效率会很高。</p><h3 id="链表" tabindex="-1">链表 <a class="header-anchor" href="#链表" aria-label="Permalink to &quot;链表&quot;">​</a></h3><ul><li><p>不同页之间双向链表连接。</p><p>方便跨页操作，比如范围查询。</p></li><li><p>叶子节点的数据通过单向链表连接。</p><p>保证有序性，方便插入和删除。</p></li></ul><h2 id="不同点" tabindex="-1">不同点 <a class="header-anchor" href="#不同点" aria-label="Permalink to &quot;不同点&quot;">​</a></h2><ul><li>存储数据方式 <ul><li>B树每个节点都存放数据。</li><li>B+树只有叶子结点存放数据。</li></ul></li><li>存储数据层级 <ul><li>相同数量数据，B树的层级会比B+树深。</li></ul></li><li>数据查找效率 <ul><li>由于B+树的层级会小于B树，意味着磁盘IO次数会减少。进而提高了查找速率。</li></ul></li></ul>',29)]))}const u=l(o,[["render",r]]);export{B as __pageData,u as default};
