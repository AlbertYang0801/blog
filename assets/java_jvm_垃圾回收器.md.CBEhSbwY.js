import{_ as a,c as e,o as p,ag as o}from"./chunks/framework.D7pKEi_Q.js";const u=JSON.parse('{"title":"垃圾回收器","description":"","frontmatter":{},"headers":[],"relativePath":"java/jvm/垃圾回收器.md","filePath":"java/jvm/垃圾回收器.md"}'),t={name:"java/jvm/垃圾回收器.md"};function i(r,l,n,s,h,c){return p(),e("div",null,l[0]||(l[0]=[o('<h1 id="垃圾回收器" tabindex="-1">垃圾回收器 <a class="header-anchor" href="#垃圾回收器" aria-label="Permalink to &quot;垃圾回收器&quot;">​</a></h1><h2 id="垃圾回收类型" tabindex="-1">垃圾回收类型 <a class="header-anchor" href="#垃圾回收类型" aria-label="Permalink to &quot;垃圾回收类型&quot;">​</a></h2><ol><li><p>串行</p><ul><li><p>单线程</p></li><li><p>适合堆内存小的时候。</p></li><li><p>STW</p><p>Stop The World 的简称。这是因为串行的机制，在垃圾回收的线程运行的时候，其它工作线程都要阻塞。</p><p><em>在垃圾回收过程中，对象的地址会发生改变。如果其它线程不阻塞，则可能会发生对象引用错误的问题。</em></p></li></ul></li><li><p>吞吐量优先</p><ul><li>多线程</li><li>适合堆内存较大，且多核CPU的情况。</li><li>在单位时间内，STW时间最短。</li></ul></li><li><p>响应时间优先</p><ul><li><p>多线程</p></li><li><p>适合堆内存较大，且多核CPU的情况。</p></li><li><p>尽可能让单次 STW 时间最短。</p><blockquote><p>比如 1小时，垃圾回收两次，每次10分钟。（吞吐量优先）</p></blockquote><blockquote><p>和每5分种垃圾回收一次，1小时内回收4次。（响应时间优先）</p></blockquote></li></ul></li></ol><h2 id="垃圾收集器" tabindex="-1">垃圾收集器 <a class="header-anchor" href="#垃圾收集器" aria-label="Permalink to &quot;垃圾收集器&quot;">​</a></h2><h3 id="serial-收集器" tabindex="-1">Serial 收集器 <a class="header-anchor" href="#serial-收集器" aria-label="Permalink to &quot;Serial 收集器&quot;">​</a></h3><ul><li><strong>XX:+UseSerialGC -XX:+UseSerialOldGC</strong></li></ul><p>使用串行回收器进行回收，这个参数会使新生代和老年代都采用串行回收器。SerialOld是Serial的老年代版本。</p><p><strong>新生代使用复制算法，老年代使用标记-整理算法</strong>。</p><p>Serial收集器是最基本、历史最悠久的收集器。它是一个单线程收集器，一旦收集器工作，系统会停止。</p><p><img src="https://s2.loli.net/2025/05/29/NAsBLC1KnJfuvEi.png" alt=""></p><p><strong>在垃圾回收线程运行时，其它工作线程都要阻塞。</strong></p><p>优点是简单而高效，单线程没有线程开销，有很高的单线程收集效率。</p><h3 id="parallel-scavenge收集器" tabindex="-1">Parallel Scavenge收集器 <a class="header-anchor" href="#parallel-scavenge收集器" aria-label="Permalink to &quot;Parallel Scavenge收集器&quot;">​</a></h3><ul><li><strong>XX:+UseParallelGC(年轻代) -XX:+UseParallelOldGC(老年代)</strong></li></ul><p>Parallel收集器其实就是 <strong><code>Serial收集器的多线程版本</code></strong>。</p><p>默认的收集线程数与 CPU 核数一致。(可以修改线程数，但是为了吞吐量不建议修改)</p><p><img src="https://s2.loli.net/2025/05/29/zh2klcoQjWgxqyd.png" alt=""></p><p>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用CPU）。</p><p>CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。</p><p>所谓吞吐量就是<strong>CPU中用于运行用户代码的时间与CPU总消耗时间的比值。</strong></p><p><strong>Parallel Scavenge收集器和Parallel Old收集器 是JDK8默认的新生代和老年代收集器。</strong></p><h3 id="parnew-收集器" tabindex="-1">ParNew 收集器 <a class="header-anchor" href="#parnew-收集器" aria-label="Permalink to &quot;ParNew 收集器&quot;">​</a></h3><ul><li>XX:+UseParNewGC</li></ul><p>ParNew收集器其实跟 Parallel 收集器很类似，区别主要在于它<code>可以和CMS收集器配合使用</code>。</p><h3 id="cms收集器" tabindex="-1">CMS收集器 <a class="header-anchor" href="#cms收集器" aria-label="Permalink to &quot;CMS收集器&quot;">​</a></h3><ul><li><strong>XX:+UseConcMarkSweepGC(old)</strong></li></ul><p>CMS（Concurrent Mark Sweep）收集器是一种<strong>以获取最短回收停顿时间为目标</strong>的收集器。它非常符合在注重用户体验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让<strong>垃圾收集线程与用户线程</strong>（基本上）同时工作。</p><p>使用 <strong><code>标记-清除</code></strong> 算法。</p><h3 id="标记-清除过程" tabindex="-1">标记-清除过程 <a class="header-anchor" href="#标记-清除过程" aria-label="Permalink to &quot;标记-清除过程&quot;">​</a></h3><ul><li><p>初始标记</p><p><strong>暂停用户线程（STW）</strong>，记录下GC Roots 能<code>直接引用</code>的对象。</p></li><li><p>并发标记</p><p>开始遍历 GC Roots 能直接引用的对象。</p><blockquote><p>比如 GC Roots → A → B，开始从 A 遍历，遍历整个对象图。</p></blockquote><p><strong>不需要暂停用户线程</strong>，这个过程耗时较长，用户线程可以与垃圾回收线程一起运行。</p><p><em>但是因为用户线程继续运行，可能导致已标记的对象状态发生变化。</em></p></li><li><p>重新标记</p><p><strong>需要暂停用户线程（STW）</strong>，重新标记阶段就是为了修复并发标记阶段，对象状态产生变化的对象。</p><p><strong>这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。主要用到三色标记里的增量更新算法 (见下面详解) 做重新标记。</strong></p></li><li><p>并发清理</p><p><strong>开启用户线程</strong>，同时GC线程开始对未标记的区域做清扫。这个阶段<strong>如果有新增对象会被标记为黑色不做任何处理</strong>(见下面三色标记算法详解)。</p></li><li><p>并发重置</p><p>重置本次GC过程中的标记数据。</p></li></ul><p><img src="https://s2.loli.net/2025/05/29/UkB8GuzYfaAdxCR.png" alt=""></p><h3 id="cms收集器的特点" tabindex="-1">CMS收集器的特点 <a class="header-anchor" href="#cms收集器的特点" aria-label="Permalink to &quot;CMS收集器的特点&quot;">​</a></h3><p><strong>优点</strong></p><ul><li>并发收集</li><li>低停顿</li></ul><p><strong>缺点</strong></p><ul><li><p>CPU 资源敏感（GC线程会抢占资源）</p></li><li><p>无法处理GC过程中新产生的垃圾</p><blockquote><p>并发标记和并发清理阶段产生的新垃圾不做操作，只能等到下次 GC。</p></blockquote></li><li><p>标记-清除算法会导致大量内存碎片</p><p>可以通过参数<code>XX:+UseCMSCompactAtFullCollection</code> 让jvm在执行完标记清除后再做整理。</p></li><li><p>执行过程不确定</p><p>可能在本次 GC还未完成的时候，由于用户线程的原因，触发新一次的 GC。</p></li></ul><hr><h2 id="三色标记法" tabindex="-1">三色标记法 <a class="header-anchor" href="#三色标记法" aria-label="Permalink to &quot;三色标记法&quot;">​</a></h2><p>垃圾回收算法判断对象是否需要被回收时，一般采用可达性分析算法。</p><p>而在以减少系统停顿时间为目的的 CMS 收集器中，<code>标记-清除</code>过程中存在垃圾回收线程和用户线程并发的情况，可能导致对象状态发生变化。</p><p>三色标记法将对象的状态按照三种颜色划分，不仅能解决和用户线程并发的问题，还能缩短 STW 的时间。</p><ul><li><p>白色</p><p>没有被 GC 扫描到的节点都是白色，意味着可以被回收。</p><p><em>在初始标记开始前，所有节点的状态都是白色。</em></p></li><li><p>灰色</p><p>该节点表示正在标记的节点，至少存在一个引用没有被扫描到。<strong>是一种中间状态。</strong></p><blockquote><p>最终节点状态只会停留在黑色或者白色。</p></blockquote></li><li><p>黑色</p><p>被 GC 扫描过的节点标记为黑色，表示节点是安全的。</p></li></ul><h3 id="标记过程" tabindex="-1">标记过程 <a class="header-anchor" href="#标记过程" aria-label="Permalink to &quot;标记过程&quot;">​</a></h3><ol><li><p>初始标记阶段。从虚拟机栈中 GC Roots 开始扫描直接引用对象，找到 Node1 和 Node5，将 Node1 和 Node5 标记为灰色。</p><p><img src="https://s2.loli.net/2025/05/29/YjdU4ck7w6nqxas.png" alt=""></p></li><li><p>并发标记阶段。</p><p>从 Node1 和 Node5 开始遍历，查到 Node2 和 Node6，此时将 Node2 和 Node6 标记为灰色。同时将 Node1 和 Node5 标记为黑色。</p><p><img src="https://s2.loli.net/2025/05/29/djrN9QTzlLtvYk3.png" alt=""></p><p><img src="https://s2.loli.net/2025/05/29/XMsDeP5OaYV8FRZ.png" alt=""></p></li><li><p>并发清除阶段。</p><p>经历过标记阶段之后，只剩下Node4 和 Node7 两个节点没有被引用，可以被回收。</p><p><img src="https://s2.loli.net/2025/05/29/in2qw7Ndm4e519B.png" alt=""></p><p>将白色阶段回收之后，剩下的就都是黑色节点。</p><p><img src="https://s2.loli.net/2025/05/29/nieSQC1oN8fHxKR.png" alt=""></p></li></ol><h3 id="标记问题" tabindex="-1">标记问题 <a class="header-anchor" href="#标记问题" aria-label="Permalink to &quot;标记问题&quot;">​</a></h3><h3 id="多标-浮动垃圾" tabindex="-1">多标 - 浮动垃圾 <a class="header-anchor" href="#多标-浮动垃圾" aria-label="Permalink to &quot;多标 - 浮动垃圾&quot;">​</a></h3><ul><li><p>在并发-标记过程中，如果运行的方法被销毁。该方法作为 GC Roots 引用的对象，之前如果已经被扫描过标记为黑色了。那么本轮 GC不会再回收这些对象，<strong>这些本该被回收的垃圾对象成为浮动垃圾</strong>。</p></li><li><p>在并发-标记（并发-清理）过程中，如果产生了新对象，通常做法直接设置为黑色。本轮也不会进行垃圾回收，放到下一轮回收。</p><blockquote><p>如果这部分对象在本次 GC 有垃圾对象产生，也是浮动垃圾。</p></blockquote></li></ul><hr><p>浮动垃圾并不会影响垃圾回收的正确性，只需要等到下一次垃圾回收就可以被清除。</p><h3 id="漏标" tabindex="-1">漏标 <a class="header-anchor" href="#漏标" aria-label="Permalink to &quot;漏标&quot;">​</a></h3><p>应该被标记为黑色回收的对象，漏标。导致存活对象被垃圾回收，严重影响程序功能。</p><p><strong>漏标必须满足的条件</strong></p><p>漏标只有在以下两个条件都满足的情况下才会产生：</p><p>条件 1：有至少一个黑色对象在自己被标记之后指向了这个白色对象。（黑色对象本身不会被再次扫描）</p><p>条件 2：灰色对象在自己引用扫描完成之前删除了对白色对象的引用。</p><p><img src="https://s2.loli.net/2025/05/29/YTHLohUwnjFe8mK.png" alt=""></p><blockquote><p>只有同时满足两个条件才会发生漏标的情况，所以只要破坏其中一个条件，就能解决漏标问题。</p></blockquote><h3 id="漏标解决方案" tabindex="-1">漏标解决方案 <a class="header-anchor" href="#漏标解决方案" aria-label="Permalink to &quot;漏标解决方案&quot;">​</a></h3><h3 id="增量更新" tabindex="-1">增量更新 <a class="header-anchor" href="#增量更新" aria-label="Permalink to &quot;增量更新&quot;">​</a></h3><p><em>破坏条件 1（有至少一个黑色对象在自己被标记之后指向了这个白色对象）。</em></p><p>在并发标记阶段当我们黑色对象（B）引用关联白色对象（E），记录下B黑色对象。</p><p>在重复标记阶段，将 B黑色对象变为灰色对象，然后扫描 B 的整个引用链。</p><blockquote><p>记录黑色对象的过程结合了写屏障来实现的。</p></blockquote><blockquote><p>增量更新指的是保存引用关系，在重复标记阶段再次更新。</p></blockquote><p><img src="https://s2.loli.net/2025/05/29/8Zde5slrOh6pDBK.png" alt=""></p><ul><li>在并发-标记阶段，当 Node5 引用 Node3 时，记录 q 指针的引用关系。</li><li>在重复标记阶段，将q 指针对应的 Node5 变为灰色对象，然后扫描 Node5 的整个调用链。最终将 Node3 标记为黑色，不被清除。</li></ul><h3 id="原始快照" tabindex="-1">原始快照 <a class="header-anchor" href="#原始快照" aria-label="Permalink to &quot;原始快照&quot;">​</a></h3><p><em>破坏条件 2（灰色对象在自己引用扫描完成之前删除了对白色对象的引用）</em></p><p>当灰色对象要删除指向白色对象的引用关系时， 就将这个要删除的引用记录下来。</p><p>在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根， 重新扫描一次。这样就能扫描到白色的对象，将白色对象直接标记为黑色 (目的就是让这种对象在本轮gc清理中能存活下来，待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾)。</p><blockquote><p>原始快照指的是保留删除前的引用关系，将要被删除的引用对象标记为黑色，下次 GC 再重新扫描。</p></blockquote><p><img src="https://s2.loli.net/2025/05/29/mOJKy4wB9njiu7H.png" alt=""></p><ul><li><p>当 p 指针引用关系要被删除时，记录下 p 指针。</p></li><li><p>在重复扫描过程中，以灰色对象为根，重新扫描一次。</p></li><li><p>将扫描到的白色对象直接标记为黑色。</p><p>这样做的目的是让对象在本轮 GC 中能够存活下来，等到下次 GC时再重新扫描。</p></li></ul><h3 id="写屏障" tabindex="-1">写屏障 <a class="header-anchor" href="#写屏障" aria-label="Permalink to &quot;写屏障&quot;">​</a></h3><p>写屏障的主要作用是确保在并发编程环境中，对共享数据的写操作能够被正确地同步和管理。</p><p>特别是在垃圾回收过程中，<strong>确保对象状态的改变能够被垃圾回收器感知</strong>。</p><p>当应用程序的线程对一个对象进行写操作时，写屏障会被触发，通知垃圾回收器对象的状态变化，从而避免漏标等问题。</p><h3 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h3><ul><li>CMS 收集器 <ul><li>写屏障 + 增量更新</li></ul></li><li>G1 收集器 <ul><li>写屏障 - 原始快照（SATB）</li></ul></li><li>ZGC： <ul><li>读屏障</li></ul></li></ul>',79)]))}const g=a(t,[["render",i]]);export{u as __pageData,g as default};
