import{_ as e,c as t,o as r,aN as i}from"./chunks/framework.A-MC8nKA.js";const s=JSON.parse('{"title":"二叉树","description":"","frontmatter":{},"headers":[],"relativePath":"other/datastructure/二叉树.md","filePath":"other/datastructure/二叉树.md","lastUpdated":1752827268000}'),l={name:"other/datastructure/二叉树.md"};function o(n,a,p,E,h,d){return r(),t("div",null,a[0]||(a[0]=[i('<h1 id="二叉树" tabindex="-1">二叉树 <a class="header-anchor" href="#二叉树" aria-label="Permalink to &quot;二叉树&quot;">​</a></h1><p>推荐一个练习数据结构的网站</p><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noreferrer">Data Structure Visualization</a></p><h2 id="二叉树的遍历-重要" tabindex="-1">二叉树的遍历（重要） <a class="header-anchor" href="#二叉树的遍历-重要" aria-label="Permalink to &quot;二叉树的遍历（重要）&quot;">​</a></h2><p>以图示二叉树为例。</p><p><img src="https://s2.loli.net/2025/07/18/ONlto9pBH72cRvW.png" alt="image.png" loading="lazy"></p><h3 id="中序遍历" tabindex="-1"><a href="https://baike.baidu.com/item/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86" target="_blank" rel="noreferrer">中序遍历</a> <a class="header-anchor" href="#中序遍历" aria-label="Permalink to &quot;[中序遍历](https://baike.baidu.com/item/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86)&quot;">​</a></h3><p>简化为每个树，都是左中右即可。</p><p>中序遍历（LDR）是<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/9796049" target="_blank" rel="noreferrer">二叉树遍历</a>的一种，也叫做<a href="https://baike.baidu.com/item/%E4%B8%AD%E6%A0%B9%E9%81%8D%E5%8E%86/1703566" target="_blank" rel="noreferrer">中根遍历</a>、中序周游。在二叉树中，中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。</p><p><em>左子树 → 根节点 → 右子树</em></p><p>图示二叉树中序遍历结果为：<code>3、5、6、10、14、15、17、20</code>；</p><p>参考代码：<a href="https://gitee.com/zztiyjw/JavaAdvance/blob/master/moudle-javase/leetcode-practice/src/main/java/com/albert/leetcode/tree/MiddleTraverse.java" target="_blank" rel="noreferrer">Java实现中序遍历</a></p><h3 id="前序遍历" tabindex="-1"><a href="https://baike.baidu.com/item/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86" target="_blank" rel="noreferrer">前序遍历</a> <a class="header-anchor" href="#前序遍历" aria-label="Permalink to &quot;[前序遍历](https://baike.baidu.com/item/%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86)&quot;">​</a></h3><p>前序遍历（VLR）， [1] 是<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/9796049" target="_blank" rel="noreferrer">二叉树遍历</a>的一种，也叫做<a href="https://baike.baidu.com/item/%E5%85%88%E6%A0%B9%E9%81%8D%E5%8E%86/1315509" target="_blank" rel="noreferrer">先根遍历</a>、先序遍历、前序周游，可记做根左右。前序遍历首先访问<a href="https://baike.baidu.com/item/%E6%A0%B9%E7%BB%93%E7%82%B9/9795570" target="_blank" rel="noreferrer">根结点</a>然后<a href="https://baike.baidu.com/item/%E9%81%8D%E5%8E%86/9796023" target="_blank" rel="noreferrer">遍历</a>左子树，最后遍历右子树。</p><p><em>根节点 -&gt; 左子树 -&gt; 右子树</em></p><p>图示二叉树前序遍历结果为：<code>10、5、3、6、15、14、20、17</code>；</p><h3 id="后序遍历" tabindex="-1">后序遍历 <a class="header-anchor" href="#后序遍历" aria-label="Permalink to &quot;后序遍历&quot;">​</a></h3><p>后序遍历（LRD）是<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/9796049" target="_blank" rel="noreferrer">二叉树遍历</a>的一种，也叫做<a href="https://baike.baidu.com/item/%E5%90%8E%E6%A0%B9%E9%81%8D%E5%8E%86/8545391" target="_blank" rel="noreferrer">后根遍历</a>、后序周游，可记做左右根。后序遍历有<a href="https://baike.baidu.com/item/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/4323575" target="_blank" rel="noreferrer">递归算法</a>和非递归算法两种。在二叉树中，先左后右再根，即首先遍历左子树，然后遍历右子树，最后访问根结点。</p><p>左子树 -&gt; 右子树 -&gt; 根节点</p><p>图示二叉树后序遍历结果为：<code>3、6、5、14、17、20、15、10</code>；</p><h3 id="层序遍历" tabindex="-1"><a href="https://baike.baidu.com/item/%E9%80%90%E5%B1%82%E9%81%8D%E5%8E%86" target="_blank" rel="noreferrer">层序遍历</a> <a class="header-anchor" href="#层序遍历" aria-label="Permalink to &quot;[层序遍历](https://baike.baidu.com/item/%E9%80%90%E5%B1%82%E9%81%8D%E5%8E%86)&quot;">​</a></h3><p>二叉树的层次遍历 ，顾名思义就是指从二叉树的第一层（根节点）开始，从上至下逐层遍历，在同一层中，则按照从左到右的顺序对节点逐个访问。在逐层遍历过程中，按从顶层到底层的次序访问树中元素，在同一层中，从左到右进行访问。</p><p>图示二叉树层序遍历结果为：<code>10、5、15、3、6、14、20、17</code>；</p><hr><h2 id="满二叉树" tabindex="-1"><a href="https://baike.baidu.com/item/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91/7773283" target="_blank" rel="noreferrer">满二叉树</a> <a class="header-anchor" href="#满二叉树" aria-label="Permalink to &quot;[满二叉树](https://baike.baidu.com/item/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91/7773283)&quot;">​</a></h2><p>除最后一层无任何子<a href="https://baike.baidu.com/item/%E8%8A%82%E7%82%B9/865052" target="_blank" rel="noreferrer">节点</a>外，每一层上的所有结点都有两个子结点的二叉树。</p><p><img src="https://s2.loli.net/2025/07/18/HVtrniGdpWOjT5A.png" alt="image.png" loading="lazy"></p><h2 id="完全二叉树" tabindex="-1"><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin" target="_blank" rel="noreferrer">完全二叉树</a> <a class="header-anchor" href="#完全二叉树" aria-label="Permalink to &quot;[完全二叉树](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin)&quot;">​</a></h2><p>一棵深度为k的有n个结点的<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91/1602879" target="_blank" rel="noreferrer">二叉树</a>，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与<a href="https://baike.baidu.com/item/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91/7773283" target="_blank" rel="noreferrer">满二叉树</a>中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树</p><p><img src="https://s2.loli.net/2025/07/18/BFR4YiG9VetAUoZ.png" alt="image.png" loading="lazy"></p><h2 id="二叉查找树-重要" tabindex="-1"><a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/10905079?fromtitle=%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91&amp;fromid=7077965&amp;fr=aladdin" target="_blank" rel="noreferrer">二叉查找树（重要）</a> <a class="header-anchor" href="#二叉查找树-重要" aria-label="Permalink to &quot;[二叉查找树（重要）](https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/10905079?fromtitle=%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91&amp;fromid=7077965&amp;fr=aladdin)&quot;">​</a></h2><p><strong>特点</strong></p><ul><li>任何节点的左节点都小于该节点。</li><li>任何节点的右节点都大于该节点。</li><li>查找速率高于链表。</li></ul><p><img src="https://s2.loli.net/2025/07/18/TCkXB8gtluL2VSN.png" alt="image.png" loading="lazy"></p><p><strong>缺点</strong></p><p>二叉查找树在特定情况下会退化成链表，若插入的元素是连续的，则会形成一个链表。</p><p><img src="https://s2.loli.net/2025/07/18/34ZvOUrtBFTpJoy.png" alt="image.png" loading="lazy"></p><h2 id="平衡二叉树-重要" tabindex="-1"><a href="https://baike.baidu.com/item/AVL%E6%A0%91/10986648?fr=aladdin" target="_blank" rel="noreferrer">平衡二叉树（重要）</a> <a class="header-anchor" href="#平衡二叉树-重要" aria-label="Permalink to &quot;[平衡二叉树（重要）](https://baike.baidu.com/item/AVL%E6%A0%91/10986648?fr=aladdin)&quot;">​</a></h2><p>平衡二叉树又称 AVL Tree ，平衡二叉树是自平衡的，保证任何节点左右子树的高度差不能大于1。</p><p>优化了二叉查找树退化成链表的现象。</p><p>定义：任意节点的左右子树深度不能超过 1。</p><p><img src="https://s2.loli.net/2025/07/18/R9Tm5ZkCHuB2dMx.png" alt="image.png" loading="lazy"></p><p>参考链接：<a href="https://juejin.cn/post/6844903653795430413#heading-0" target="_blank" rel="noreferrer">看图轻松理解数据结构与算法系列(AVL树)</a></p><p>二叉树的刷题框架。</p><p>二叉树基本和递归有关，不要跳进递归的细节。</p><ol><li>明确根节点要做什么</li><li>套用前序/中序/后序的遍历框架。</li></ol>',46)]))}const b=e(l,[["render",o]]);export{s as __pageData,b as default};
