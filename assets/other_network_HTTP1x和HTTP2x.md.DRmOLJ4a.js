import{_ as l,c as t,o as e,aN as i}from"./chunks/framework.A-MC8nKA.js";const d=JSON.parse('{"title":"HTTP1x和HTTP2.x","description":"","frontmatter":{},"headers":[],"relativePath":"other/network/HTTP1x和HTTP2x.md","filePath":"other/network/HTTP1x和HTTP2x.md","lastUpdated":1752827268000}'),o={name:"other/network/HTTP1x和HTTP2x.md"};function r(p,a,n,T,h,s){return e(),t("div",null,a[0]||(a[0]=[i('<h1 id="http1x和http2-x" tabindex="-1">HTTP1x和HTTP2.x <a class="header-anchor" href="#http1x和http2-x" aria-label="Permalink to &quot;HTTP1x和HTTP2.x&quot;">​</a></h1><h2 id="http1-x" tabindex="-1">HTTP1.x <a class="header-anchor" href="#http1-x" aria-label="Permalink to &quot;HTTP1.x&quot;">​</a></h2><h3 id="数据格式" tabindex="-1">数据格式 <a class="header-anchor" href="#数据格式" aria-label="Permalink to &quot;数据格式&quot;">​</a></h3><p>HTTP1.x基于<strong>文本传输</strong>。</p><ul><li>请求行</li><li>请求头</li><li>请求体</li></ul><p><img src="https://s2.loli.net/2025/07/17/wWzDgukEScHKXNG.png" alt="image.png" loading="lazy"></p><p><img src="https://s2.loli.net/2025/07/17/fInWoDa5RHKqCmh.png" alt="image.png" loading="lazy"></p><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ol><li><p><strong>占用字节</strong>：在HTTP请求中，包含很多空格和换行符。</p></li><li><p><strong>头部不能压缩</strong>：在HTTP1.x中，请求头不能压缩。所以存在请求头比较大的问题，出现大头儿子。</p><blockquote><p>可以在请求头中指定请求体的压缩算法。但是无法指定请求头的。</p></blockquote></li><li><p><strong>传输效率低</strong>：同一个链接（<code>Keep-Alive</code>的情况）同时只能处理一个请求，收到响应才会开始发送下一个请求。</p><ul><li>如果不设置 <code>Keep-Alive</code>，则每一次HTTP请求都会新建一个TCP链接。</li></ul><blockquote><p>为提高效率，浏览器等应用层软件会选择同时与服务器建立多个TCP链接（一般上限是6个）。</p></blockquote></li></ol><h3 id="浏览器的域名限制" tabindex="-1">浏览器的域名限制 <a class="header-anchor" href="#浏览器的域名限制" aria-label="Permalink to &quot;浏览器的域名限制&quot;">​</a></h3><p>在Http1.x中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制，而超过限制数目的请求会被阻塞。</p><p>比如Chrome3 对 HTTP1.1 的限制是 4个。</p><p><img src="https://s2.loli.net/2025/07/17/kuyBCi24vsOLrTw.png" alt="image.png" loading="lazy"></p><h2 id="http2-x" tabindex="-1">HTTP2.x <a class="header-anchor" href="#http2-x" aria-label="Permalink to &quot;HTTP2.x&quot;">​</a></h2><h3 id="长连接" tabindex="-1">长连接 <a class="header-anchor" href="#长连接" aria-label="Permalink to &quot;长连接&quot;">​</a></h3><ul><li>HTTP1.0：<strong>基本上都是短连接</strong>，每个请求响应完成后立即关闭连接。</li><li>HTTP2.0：<strong>支持长连接</strong>，即一个TCP连接可以承载多个请求和响应，减少了连接的建立和关闭次数，提高了性能。</li></ul><h3 id="帧" tabindex="-1">帧 <a class="header-anchor" href="#帧" aria-label="Permalink to &quot;帧&quot;">​</a></h3><p>帧是HTTP/2通信的最小单位。</p><ul><li><p>二进制，计算机传输效率高。</p></li><li><p>帧都有边界。</p></li><li><p>基于流发送。</p><p>一次请求可以分为多个帧，HEADERS和DATA。在接收端组合。</p></li></ul><p>HTTP/2 采用二进制传输数据，而非文本格式，大大提高了传输效率。引入了流控制和帧压缩等机制，进一步提升了数据传输的性能。</p><h3 id="流控制" tabindex="-1">流控制 <a class="header-anchor" href="#流控制" aria-label="Permalink to &quot;流控制&quot;">​</a></h3><p>在HTTP/2的数据格式里面，按帧划分。</p><p>每个帧的格式如下：</p><ul><li>帧长度：标识当前帧实际传输的数据大小。</li><li>帧类型 <ul><li>数据帧：HEADERS和DATAS，用来传输请求头和请求体。</li><li>控制帧：PING、SETTINGS，用来管理的。</li></ul></li><li>标志位：标识当前帧是请求的最后一帧。</li></ul><p><img src="https://s2.loli.net/2025/07/17/L8nxbGPlVWgkdB2.png" alt="image.png" loading="lazy"></p><p>客户端在一个TCP连接上，可以并发的给服务端同时发送多个帧，比如同时发送多个HEADERS帧（请求头），多个DATA 帧（请求体）。每个帧有自己的 StreamID。</p><p>而服务端接受的时候会按照 StreamID 组合在一起处理单次请求。</p><h3 id="头部压缩问题" tabindex="-1">头部压缩问题 <a class="header-anchor" href="#头部压缩问题" aria-label="Permalink to &quot;头部压缩问题&quot;">​</a></h3><p><strong>HTTP 1.1请求的大小变得越来越大</strong>，有时甚至会大于TCP窗口的初始大小，因为它们需要等待带着ACK的响应回来以后才能继续被发送。</p><p>HTTP/2对消息头采用HPACK（专为HTTP/2头部设计的压缩格式）进行压缩传输，能够节省消息头占用的网络的流量。</p><p><em>而HTTP/1.x每次请求，都会携带大量冗余头信息，浪费了很多带宽资源。像cookie这些信息，每个请求都会附带，产生了很多不必要的资源消耗。为了减少这块的资源消耗并提升性能， HTTP/2对这些首部采取了压缩策略：</em></p><h3 id="传输问题-多路复用" tabindex="-1">传输问题-多路复用 <a class="header-anchor" href="#传输问题-多路复用" aria-label="Permalink to &quot;传输问题-多路复用&quot;">​</a></h3><p>HTTP2.0采用多路复用，将多个资源请求同时发给同一个TCP连接，实现<strong>单个连接并发发送请求</strong>。</p><ul><li><p>HTTP2.0用一条长链接，能实现并发处理请求。</p><blockquote><p>避免了重复创建TCP连接带来的网络问题，同时还能够提高吞吐效率。</p></blockquote></li></ul><p>由于浏览器限制的原因，HTTP1.x的吞吐率不会太高。而HTTP2.0引入了多路复用后，能够将吞吐率提高数量级增长。</p><p><img src="https://s2.loli.net/2025/07/17/z5UvP1aGfy24YWL.png" alt="image.png" loading="lazy"></p><h3 id="滑动窗口问题" tabindex="-1">滑动窗口问题 <a class="header-anchor" href="#滑动窗口问题" aria-label="Permalink to &quot;滑动窗口问题&quot;">​</a></h3><blockquote><p>TCP滑动窗口是由发送者和接受者来控制，能限制发送者的发送速率。窗口大小会根据数据大小进行动态调整。</p></blockquote><ul><li>HTTP1.x的请求一般都是短链接，复用率很低。刚创建的TCP连接的滑动窗口一般会很小（慢启动），由于复用率低，窗口大小一般都不会过度增长，导致发送速率会收到限制。</li><li>而 HTTP2.x 基于同一个连接采用多路复用，在请求数据不断发送成功的情况，滑动窗口大小会逐渐增大，进而提高发送效率。</li></ul><h3 id="数据格式-1" tabindex="-1">数据格式 <a class="header-anchor" href="#数据格式-1" aria-label="Permalink to &quot;数据格式&quot;">​</a></h3><ul><li>HEADERS帧</li><li>DATA帧</li></ul><p><img src="https://s2.loli.net/2025/07/17/iW4JaYdIxZnKP2t.png" alt="image.png" loading="lazy"></p><p><img src="https://s2.loli.net/2025/07/17/iJuA8QNl41bGPcp.png" alt="image.png" loading="lazy"></p><p>在客户端和服务器交互时，可以将帧并发发送，在服务器端组合。</p><p>每个帧都带有请求ID，根据请求ID即可组合为单次请求详情。</p><h3 id="帧格式" tabindex="-1">帧格式 <a class="header-anchor" href="#帧格式" aria-label="Permalink to &quot;帧格式&quot;">​</a></h3><p><img src="https://s2.loli.net/2025/07/17/5ye2oYNLCukPtdv.png" alt="image.png" loading="lazy"></p>',47)]))}const c=l(o,[["render",r]]);export{d as __pageData,c as default};
