import{_ as t,c as o,o as e,aN as l}from"./chunks/framework.A-MC8nKA.js";const g=JSON.parse('{"title":"Kakfa和RocketMQ的区别","description":"","frontmatter":{},"headers":[],"relativePath":"middleware/rocketmq/Kakfa和RocketMQ的区别.md","filePath":"middleware/rocketmq/Kakfa和RocketMQ的区别.md","lastUpdated":1752827238000}'),i={name:"middleware/rocketmq/Kakfa和RocketMQ的区别.md"};function r(n,a,s,p,k,c){return e(),o("div",null,a[0]||(a[0]=[l('<h1 id="kakfa和rocketmq的区别" tabindex="-1">Kakfa和RocketMQ的区别 <a class="header-anchor" href="#kakfa和rocketmq的区别" aria-label="Permalink to &quot;Kakfa和RocketMQ的区别&quot;">​</a></h1><h2 id="消费者组" tabindex="-1">消费者组 <a class="header-anchor" href="#消费者组" aria-label="Permalink to &quot;消费者组&quot;">​</a></h2><p>RocketMQ和Kafka虽然都使用了Consumer Group的概念来实现消息的分发和负载均衡，但两者在具体实现和一些特性上存在一些差异：</p><ol><li><strong>Rebalance机制</strong>： <ul><li><strong>RocketMQ</strong>：RocketMQ的Consumer Group在成员增减或Topic队列发生变化时会触发Rebalance，旨在重新分配队列到各个消费者实例，确保消息的公平消费。RocketMQ的Rebalance更加灵活，支持多种分配策略，例如平均分配、广播消费等，可以根据业务需求进行配置。</li><li><strong>Kafka</strong>：Kafka同样在Consumer Group中进行Rebalance，当有新的消费者加入或离开时，或订阅的Topic分区发生变化时，Kafka会通过Coordinator进行协调重平衡。Kafka的Rebalance机制在较新版本中得到了改进，提高了效率和稳定性，但也存在一定的延迟问题，尤其是在消费者组成员频繁变化时。</li></ul></li><li><strong>消费模式</strong>： <ul><li><strong>RocketMQ</strong>：支持多种消费模式，包括集群消费（Clustering）和广播消费（Broadcasting）。 <ul><li>集群消费模式下，相同Consumer Group内的消费者共同消费Topic的所有消息，每条消息只被消费一次；</li><li>而在广播消费模式下，每个消费者实例都会收到全部消息，适用于需要对每条消息进行独立处理的场景。</li></ul></li><li><strong>Kafka</strong>：主要采用分区消费模型，即每个分区的消息只能被一个Consumer Group内的一个消费者消费，但不直接支持广播消费模式。<strong>若需类似广播的效果，需要为每个消费者单独创建Consumer Group。</strong></li></ul></li><li><strong>消息顺序性</strong>： <ul><li><p><strong>RocketMQ</strong>：在单个队列（Queue）或主题（Topic）下，RocketMQ原生支持顺序消息，保证消息的严格顺序传递，这对于某些需要严格顺序处理的业务场景（如金融交易）非常重要。</p><blockquote><p>MessageQueue是一个FIFO队列，所以是顺序消费。</p></blockquote></li><li><p><strong>Kafka</strong>：Kafka保证了在<strong>单个分区内的消息顺序（offset）</strong>，但跨分区则无法保证消息的全局顺序。这意味着，如果一个Topic设置了多个分区，消息的顺序性将依赖于消息是如何被分区的（消息根据ParitationKey路由到不同的Paritation）。</p></li></ul></li><li><strong>可靠性保障</strong>： <ul><li><strong>RocketMQ</strong>：在可靠性方面，RocketMQ提供了更丰富的选项，如<strong>同步刷盘、同步复制</strong>等，这使得RocketMQ在单机可靠性上往往被认为比Kafka更优，尤其是在金融等对数据安全要求极高的场景中。 <ul><li>同步刷盘：消息写到内存之后，直接写到磁盘。等待磁盘写完之后再响应客户端。</li><li>异步刷盘：消息写到内存之后直接响应客户端，等待内存缓冲区满或者到达指定时间后再落磁盘。</li></ul></li><li><strong>Kafka</strong>：虽然Kafka也提供了高可用性方案，如副本机制，但其默认采用<strong>异步刷盘和复制</strong>，这在某些情况下<strong>可能会导致数据丢失</strong>的风险。</li></ul></li></ol><h3 id="架构" tabindex="-1">架构 <a class="header-anchor" href="#架构" aria-label="Permalink to &quot;架构&quot;">​</a></h3><h3 id="kafka" tabindex="-1">kafka <a class="header-anchor" href="#kafka" aria-label="Permalink to &quot;kafka&quot;">​</a></h3><p><img src="https://s2.loli.net/2025/06/27/ZCBjlgtupMfWJ8w.jpg" alt="Screenshot_20240701_234230_tv.danmaku.bili.jpg" loading="lazy"></p><h3 id="rocketmq" tabindex="-1">RocketMQ <a class="header-anchor" href="#rocketmq" aria-label="Permalink to &quot;RocketMQ&quot;">​</a></h3><p><img src="https://s2.loli.net/2025/06/27/IKhMuYl6jrkOwN4.jpg" alt="Screenshot_20240701_234009_tv.danmaku.bili.jpg" loading="lazy"></p><p><img src="https://s2.loli.net/2025/06/27/YJT8WfAZ9PgaV54.jpg" alt="Screenshot_20240701_234219_tv.danmaku.bili.jpg" loading="lazy"></p><h3 id="partition和queue" tabindex="-1">Partition和Queue <a class="header-anchor" href="#partition和queue" aria-label="Permalink to &quot;Partition和Queue&quot;">​</a></h3><p>kafka的Partition上有完整数据。</p><p>而RocketMQ的Queue上是简要信息，比如offset，更类似于一个索引文件。</p><p><img src="https://s2.loli.net/2025/06/27/QdyiqSgmKsx3NCv.jpg" alt="Screenshot_20240701_233712_tv.danmaku.bili.jpg" loading="lazy"></p><p><img src="https://s2.loli.net/2025/06/27/YEKnWXTfVCuIgDB.jpg" alt="Screenshot_20240701_233727_tv.danmaku.bili.jpg" loading="lazy"></p><h3 id="写数据问题" tabindex="-1">写数据问题 <a class="header-anchor" href="#写数据问题" aria-label="Permalink to &quot;写数据问题&quot;">​</a></h3><h3 id="kafka-1" tabindex="-1">Kafka <a class="header-anchor" href="#kafka-1" aria-label="Permalink to &quot;Kafka&quot;">​</a></h3><p>Kafka的效率高的一点就是写Partition的log文件是并发顺序写的，但是当Partition数量多之后。</p><ul><li><p>磁盘IO瓶颈。</p></li><li><p>多Partition同时写磁盘，退化为磁盘随机写。</p><p>每个Partition写自己的，数量上来之后在磁盘上就不是顺序写了。</p></li></ul><p><img src="https://s2.loli.net/2025/06/27/pGM5oBj4gDnbPtV.jpg" alt="Screenshot_20240701_233855_tv.danmaku.bili.jpg" loading="lazy"></p><h3 id="rocketmq-1" tabindex="-1">RocketMQ <a class="header-anchor" href="#rocketmq-1" aria-label="Permalink to &quot;RocketMQ&quot;">​</a></h3><ul><li><p>同一个Borker所有数据顺序写commitLog。</p><p>同步写效率低。</p></li><li><p>Topic的Queue保存offset，类似索引的回表查询。</p><p>多进行一次回表操作。</p></li></ul><p><img src="https://s2.loli.net/2025/06/27/YMpCj8lS3cOWPqo.jpg" alt="Screenshot_20240701_233921_tv.danmaku.bili.jpg" loading="lazy"></p><p><img src="https://s2.loli.net/2025/06/27/6xVs8D7a1pfRHtU.jpg" alt="Screenshot_20240701_233747_tv.danmaku.bili.jpg" loading="lazy"></p><h3 id="事务消息" tabindex="-1">事务消息 <a class="header-anchor" href="#事务消息" aria-label="Permalink to &quot;事务消息&quot;">​</a></h3><h3 id="kafka-2" tabindex="-1">Kafka <a class="header-anchor" href="#kafka-2" aria-label="Permalink to &quot;Kafka&quot;">​</a></h3><p>kafka的事务消息，指的是生产者发消息，保证同一批数据的原子性。</p><p>而不是本地事务和生产者消息的结合。</p><p><img src="https://s2.loli.net/2025/06/27/xwoUPasVkgHtOMI.jpg" alt="Screenshot_20240701_234416_tv.danmaku.bili.jpg" loading="lazy"></p><p><img src="https://s2.loli.net/2025/06/27/vNLzxOJWFsSXnBR.jpg" alt="Screenshot_20240701_234352_tv.danmaku.bili.jpg" loading="lazy"></p><h3 id="rocketmq-2" tabindex="-1">RocketMQ <a class="header-anchor" href="#rocketmq-2" aria-label="Permalink to &quot;RocketMQ&quot;">​</a></h3><p>RocketMQ的事务消息能够保证本地事务和kafka事务的一致性。</p><p>本质上用到了二阶段提交。</p>',33)]))}const h=t(i,[["render",r]]);export{g as __pageData,h as default};
