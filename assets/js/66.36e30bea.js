(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{380:function(e,t,v){"use strict";v.r(t);var n=v(18),_=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"bytebuf"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bytebuf"}},[e._v("#")]),e._v(" ByteBuf")]),e._v(" "),t("p",[e._v("ByteBuf是Netty中用于表示字节序列的数据容器。它是Netty对Java NIO中的ByteBuffer的改进和增强。ByteBuf提供了更灵活、更强大的API，具有许多优势，使得它在网络编程中更加方便和高效。")]),e._v(" "),t("p",[e._v("以下是ByteBuf的主要优势：")]),e._v(" "),t("ol",[t("li",[t("strong",[e._v("灵活的容量管理")]),e._v("： ByteBuf支持动态扩容和收缩，相比Java NIO的ByteBuffer，ByteBuf的容量可以根据实际需求自动调整，无需手动扩容。")]),e._v(" "),t("li",[t("strong",[e._v("更丰富的API")]),e._v("： ByteBuf提供了丰富的操作API，包括读取、写入、复制、切片、合并等操作。这些API使得对字节数据的操作更加便利，同时提供了更多的功能。")]),e._v(" "),t("li",[t("strong",[e._v("池化支持")]),e._v("： Netty中的"),t("strong",[e._v("ByteBuf支持内存池化，可以通过池化的方式重用内存，减少内存分配和释放的开销，提高性能")]),e._v("。")]),e._v(" "),t("li",[t("strong",[e._v("零拷贝")]),e._v("： "),t("strong",[e._v("ByteBuf的设计允许进行零拷贝操作")]),e._v("，例如，可以直接将ByteBuf的底层字节数组传递给其他组件，避免了中间的数据拷贝，提高了数据传输的效率。")]),e._v(" "),t("li",[t("strong",[e._v("自动释放")]),e._v("： ByteBuf支持引用计数，可以追踪对ByteBuf的引用情况，当引用计数为零时自动释放内存，防止内存泄漏。")]),e._v(" "),t("li",[t("strong",[e._v("更强大的ByteBuf类型")]),e._v("： Netty提供了不同类型的ByteBuf，如Heap ByteBuf、Direct ByteBuf等，可以根据实际场景选择合适的类型，以满足性能和使用需求。")])]),e._v(" "),t("p",[e._v("ByteBuf的优势在于其灵活性、功能丰富性以及对性能的优化，使得Netty在处理大量数据传输时更加高效和易用。")]),e._v(" "),t("h3",{attrs:{id:"引用计数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引用计数"}},[e._v("#")]),e._v(" 引用计数")]),e._v(" "),t("p",[e._v("ByteBuf支持引用计数，可以追踪对ByteBuf的引用情况，当"),t("strong",[e._v("引用计数为零时自动释放内存，防止内存泄漏")]),e._v("。")]),e._v(" "),t("h3",{attrs:{id:"资源释放"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#资源释放"}},[e._v("#")]),e._v(" 资源释放")]),e._v(" "),t("p",[e._v("当某个 ChannelInboundHandler 的实现重写 channelRead()方法时，它要负责显式地释放与池化的 ByteBuf 实例相关的内存。Netty 为此提供了一个实用方法"),t("code",[e._v("ReferenceCountUtil.release()")])]),e._v(" "),t("p",[e._v("一个更加简单的方式是使用SimpleChannelInboundHandler，SimpleChannelInboundHandler 会自动释放资源。")]),e._v(" "),t("ol",[t("li",[e._v("对于"),t("strong",[e._v("入站请求")]),e._v("，Netty 的 EventLoo 在处理 Channel 的读操作时进行分配 ByteBuf，对于这类 ByteBuf，需要我们自行进行释放，有三种方式：\n"),t("ul",[t("li",[e._v("使用 SimpleChannelInboundHandler；")]),e._v(" "),t("li",[e._v("在重写 channelRead()方法使用 "),t("code",[e._v("ReferenceCountUtil.release()")]),e._v(" 释放资源;")]),e._v(" "),t("li",[e._v("在重写 channelRead()方法使用使用 "),t("code",[e._v("ctx.fireChannelRead")]),e._v(" 继续"),t("strong",[e._v("向后传递")]),e._v("；")])])])]),e._v(" "),t("p",[e._v("2、对于"),t("strong",[e._v("出站请求")]),e._v("，不管 ByteBuf 是否由我们的业务创建的，当调用了 write 或者writeAndFlush 方法后，Netty 会自动替我们释放，不需要我们业务代码自行释放。")])])}),[],!1,null,null,null);t.default=_.exports}}]);