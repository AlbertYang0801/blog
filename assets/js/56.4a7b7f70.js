(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{369:function(t,v,_){"use strict";_.r(v);var a=_(18),s=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"七大基本原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#七大基本原则"}},[t._v("#")]),t._v(" 七大基本原则")]),t._v(" "),v("h2",{attrs:{id:"单一职责原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则"}},[t._v("#")]),t._v(" 单一职责原则")]),t._v(" "),v("ol",[v("li",[t._v("一种类只能具有一种职责，降低类的复杂度。")]),t._v(" "),v("li",[t._v("提高类的可读性，可维护性。")]),t._v(" "),v("li",[t._v("降低变更引起的风险。")]),t._v(" "),v("li",[t._v("在类中的方法比较少的时候，可以在方法级别保持单一职责原则。其他情况下，都要保持类的类单一职责原则。")])]),t._v(" "),v("h2",{attrs:{id:"接口隔离原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#接口隔离原则"}},[t._v("#")]),t._v(" 接口隔离原则")]),t._v(" "),v("ol",[v("li",[t._v("客户端不应该依赖它不需要的接口。")]),t._v(" "),v("li",[t._v("一个类对另一个类的依赖应该建立在最小的接口上。")])]),t._v(" "),v("h2",{attrs:{id:"依赖倒置原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#依赖倒置原则"}},[t._v("#")]),t._v(" 依赖倒置原则")]),t._v(" "),v("ol",[v("li",[t._v("依赖倒置原则的中心思想是面向接口编程。")]),t._v(" "),v("li",[t._v("抽象不应该依赖细节，细节应该依赖抽象。抽象是接口或者抽象类，细节即为实现类。")]),t._v(" "),v("li",[t._v("对于细节的多变性，抽象的东西要稳定的多。")])]),t._v(" "),v("h2",{attrs:{id:"里氏替换原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#里氏替换原则"}},[t._v("#")]),t._v(" 里氏替换原则")]),t._v(" "),v("ol",[v("li",[t._v("继承遵守里氏替换原则，子类尽量不要重写父类的方法。如果子类重写了父类的方法，实际上是增加了子类和父类之间的耦合度。")]),t._v(" "),v("li",[t._v("在引用父类的地方能直接使用其子类替换。")]),t._v(" "),v("li",[t._v("若子类需要修改父类的方法，可以通过组合、聚合、依赖等方法实现。")])]),t._v(" "),v("h2",{attrs:{id:"开闭原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#开闭原则"}},[t._v("#")]),t._v(" 开闭原则")]),t._v(" "),v("ol",[v("li",[t._v("对扩展开放。")]),t._v(" "),v("li",[t._v("对修改关闭。")])]),t._v(" "),v("h2",{attrs:{id:"迪米特法则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#迪米特法则"}},[t._v("#")]),t._v(" 迪米特法则")]),t._v(" "),v("ol",[v("li",[t._v("最少知道原则。一个类对自己依赖的类知道越少越好。")]),t._v(" "),v("li",[t._v("直接朋友。一个类作为成员变量、方法参数、方法返回值出现在另一个类。称该类为另一个类的直接朋友。")]),t._v(" "),v("li",[t._v("减少非直接朋友的耦合。不要以局部变量的形式出现在其他类。")])]),t._v(" "),v("h2",{attrs:{id:"合成复用法则-组合-聚合复用原则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#合成复用法则-组合-聚合复用原则"}},[t._v("#")]),t._v(" 合成复用法则（组合/聚合复用原则）")]),t._v(" "),v("ol",[v("li",[t._v("在复用情况时，尽量使用组合和聚合的方式，减少继承的使用。")]),t._v(" "),v("li",[t._v("若使用继承，则必须严格遵守里式替换原则。")]),t._v(" "),v("li",[t._v("组合关系。另一个类随着当前类创建和销毁。\n例如人和手的关系就是组合关系。")]),t._v(" "),v("li",[t._v("聚合关系。另一个类包含在当前类中，但另一个类不是当前类的组成部分，另一个类不会因为当前类的创建和销毁而去创建和销毁。\n例如人和电脑的关系就是聚合关系。")])])])}),[],!1,null,null,null);v.default=s.exports}}]);