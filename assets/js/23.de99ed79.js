(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{337:function(v,_,t){"use strict";t.r(_);var a=t(18),s=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"b树和b-树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#b树和b-树"}},[v._v("#")]),v._v(" B树和B+树")]),v._v(" "),_("h2",{attrs:{id:"b树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#b树"}},[v._v("#")]),v._v(" B树")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://s2.loli.net/2025/06/13/TkBtqpCgMW3wl7X.png",alt:""}})]),v._v(" "),_("p",[v._v("每个节点是一个磁盘快。每个磁盘快有固定大小，可以存储多个K-V键值对。")]),v._v(" "),_("p",[v._v("每个磁盘快包含指向下层节点的指针，方便查找。")]),v._v(" "),_("p",[_("em",[v._v("由于每个节点存储了更多的键值对数据，可以有效降低查找树的次数，并减少查询磁盘。")])]),v._v(" "),_("ul",[_("li")]),v._v(" "),_("h2",{attrs:{id:"b-树"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#b-树"}},[v._v("#")]),v._v(" B+树")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://s2.loli.net/2025/06/13/EFOX5ywcgCAjNWk.png",alt:""}})]),v._v(" "),_("h3",{attrs:{id:"存储空间"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#存储空间"}},[v._v("#")]),v._v(" 存储空间")]),v._v(" "),_("p",[v._v("B+树是在B树的基础上演进的。")]),v._v(" "),_("p",[v._v("B+树的非叶子结点是不保存数据的，仅保存键值。")]),v._v(" "),_("p",[v._v("在 InnoDB中页大小是固定的，在只保存键值的情况下，同一个数据页能保存更多的键值。这样就能保证整个树的层级大大降低，减少向下搜索时候的磁盘IO次数，会提高数据的查询效率。")]),v._v(" "),_("p",[_("strong",[v._v("InnoDB 中页的默认大小是 16KB。")])]),v._v(" "),_("p",[v._v("假如每页能存储1000个数据，3层B+树就可以保存 1000"),_("em",[v._v("1000")]),v._v("1000 = 10亿条数据。")]),v._v(" "),_("p",[v._v("由于根结点的数据常驻内存，那么查询10亿条以内的数据只需要进行2次磁盘IO，就能找到数据所在的页。")]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"有序存储"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#有序存储"}},[v._v("#")]),v._v(" 有序存储")]),v._v(" "),_("p",[v._v("数据都保存在B+树的叶子节点上，而每个叶子节点对应一个页（磁盘快）。")]),v._v(" "),_("p",[v._v("每个单独的页会对数据进行分组，分组时选出记录最小值，维护到"),_("code",[v._v("有序数组")]),v._v("。每一组都是一个"),_("code",[v._v("单向链表")]),v._v("。")]),v._v(" "),_("p",[_("strong",[v._v("索引定位到page后，如何定位数据？")])]),v._v(" "),_("ol",[_("li",[v._v("根据有序数组，通过"),_("code",[v._v("二分法")]),v._v("查找到对应的分组。")]),v._v(" "),_("li",[v._v("根据分组中的最小记录，按照单向链表去查找数据，直到查到为止。")])]),v._v(" "),_("p",[_("img",{attrs:{src:"https://s2.loli.net/2025/06/13/fKm9Ji6uQbZxnCa.png",alt:""}})]),v._v(" "),_("hr"),v._v(" "),_("p",[v._v("由于叶子节点数据的有序性，在顺序查找，排序，范围查找场景时，B+树效率会很高。")]),v._v(" "),_("h3",{attrs:{id:"链表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[v._v("#")]),v._v(" 链表")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("不同页之间双向链表连接。")]),v._v(" "),_("p",[v._v("方便跨页操作，比如范围查询。")])]),v._v(" "),_("li",[_("p",[v._v("叶子节点的数据通过单向链表连接。")]),v._v(" "),_("p",[v._v("保证有序性，方便插入和删除。")])])]),v._v(" "),_("h2",{attrs:{id:"不同点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#不同点"}},[v._v("#")]),v._v(" 不同点")]),v._v(" "),_("ul",[_("li",[v._v("存储数据方式\n"),_("ul",[_("li",[v._v("B树每个节点都存放数据。")]),v._v(" "),_("li",[v._v("B+树只有叶子结点存放数据。")])])]),v._v(" "),_("li",[v._v("存储数据层级\n"),_("ul",[_("li",[v._v("相同数量数据，B树的层级会比B+树深。")])])]),v._v(" "),_("li",[v._v("数据查找效率\n"),_("ul",[_("li",[v._v("由于B+树的层级会小于B树，意味着磁盘IO次数会减少。进而提高了查找速率。")])])])])])}),[],!1,null,null,null);_.default=s.exports}}]);