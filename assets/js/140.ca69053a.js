(window.webpackJsonp=window.webpackJsonp||[]).push([[140],{453:function(t,v,e){"use strict";e.r(v);var _=e(18),o=Object(_.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"bio"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#bio"}},[t._v("#")]),t._v(" BIO")]),t._v(" "),v("p",[t._v("JDK 网络编程 BIO，意为阻塞的 IO。")]),t._v(" "),v("p",[t._v("BIO 的阻塞体现在两个方面：")]),t._v(" "),v("ol",[v("li",[t._v("若一个服务端的服务绑定端口启动后，主线程就会一直等待客户端的连接。")]),t._v(" "),v("li",[t._v("客户端和服务端 Socket 端口建立连接之后，在读取到 Socket 信息之前，线程一直处于等待，一直处于阻塞状态。")])]),t._v(" "),v("p",[t._v("典型的 "),v("strong",[t._v("请求 -应答模型")])]),t._v(" "),v("p",[t._v("由一个独立的 "),v("code",[t._v("Acceptor")]),t._v(" 模型监听客户端的请求，收到请求后为每一个客户端创建一个线程去处理，处理完成后将结果返回给客户端。")]),t._v(" "),v("p",[t._v("Java BIO：传统的网络通讯模型，就是BIO，同步阻塞IO。")]),t._v(" "),v("p",[t._v("其实就是服务端创建一个ServerSocket， 然后就是客户端用一个 Socket 去连接服务端的那个ServerSocket， ServerSocket接收到了一个的连接请求就创建一个Socket和一个线程去跟那个Socket进行通讯。")]),t._v(" "),v("p",[t._v("接着客户端和服务端就进行阻塞式的通信，客户端发送一个请求，服务端Socket进行处理后返回响应，在响应返回前，客户端那边就阻塞等待，什么事情也做不了。")]),t._v(" "),v("p",[t._v("这种方式的缺点， 每次一个客户端接入，都需要在服务端创建一个线程来服务这个客户端，"),v("strong",[t._v("这样大量客户端来的时候，就会造成服务端的线程数量可能达到了几千甚至几万，这样就可能会造成服务端过载过高，最后崩溃死掉")]),t._v("。")]),t._v(" "),v("h3",{attrs:{id:"伪异步io模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#伪异步io模型"}},[t._v("#")]),t._v(" 伪异步IO模型")]),t._v(" "),v("p",[t._v("用线程池管理服务端的线程，实现异步处理Socket请求。")]),t._v(" "),v("p",[t._v("但是底层还是使用同步阻塞IO，所以叫伪异步。")])])}),[],!1,null,null,null);v.default=o.exports}}]);