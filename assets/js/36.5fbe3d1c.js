(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{349:function(s,a,t){"use strict";t.r(a);var e=t(18),r=Object(e.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引"}},[s._v("#")]),s._v(" 索引")]),s._v(" "),a("p",[s._v("在 MySQL 中，索引是在"),a("strong",[s._v("存储引擎层")]),s._v("实现的，所以并没有统一的索引标准。")]),s._v(" "),a("h2",{attrs:{id:"innodb的索引模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#innodb的索引模型"}},[s._v("#")]),s._v(" InnoDB的索引模型")]),s._v(" "),a("h3",{attrs:{id:"b-树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#b-树"}},[s._v("#")]),s._v(" B+树")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://s2.loli.net/2025/06/13/jU59Th4IAqxuWEa.png",alt:""}})]),s._v(" "),a("p",[s._v("B+树的每个叶子节点存放元素有限，每个叶子节点为一个 page，针对元素的数量会产生页分裂、页合并等现象。")]),s._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/weixin_52622200/article/details/118530154",target:"_blank",rel:"noopener noreferrer"}},[s._v("什么是B+树？_攻城狮百里的博客-CSDN博客_b+树"),a("OutboundLink")],1)]),s._v(" "),a("p",[a("img",{attrs:{src:"https://s2.loli.net/2025/06/13/3htEkaHp2wZVDzR.png",alt:""}})]),s._v(" "),a("h3",{attrs:{id:"聚簇索引和二级索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#聚簇索引和二级索引"}},[s._v("#")]),s._v(" 聚簇索引和二级索引")]),s._v(" "),a("ul",[a("li",[s._v("主键索引的叶子结点存的是整行记录。InnoDB 引擎中主键索引又称为"),a("strong",[s._v("聚簇索引")]),s._v("。")]),s._v(" "),a("li",[s._v("非主键索引的叶子结点存的是行记录的ID。在 InnoDB 引擎中非主键索引又称为"),a("strong",[s._v("二级索引")]),s._v("。")])]),s._v(" "),a("p",[a("img",{attrs:{src:"https://s2.loli.net/2025/06/13/3htEkaHp2wZVDzR.png",alt:""}})]),s._v(" "),a("h3",{attrs:{id:"搜索方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#搜索方式"}},[s._v("#")]),s._v(" 搜索方式")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("根据主键搜索")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" id "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("500")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("根据 id = 500 从主键索引这个 B+树中查找对应记录。")]),s._v(" "),a("ul",[a("li",[s._v("首先找到500对应的叶子节点所在的 page。")]),s._v(" "),a("li",[s._v("在 page 上通过二分法进行查找（page 内部维护了有序数组）数据所在分组。")]),s._v(" "),a("li",[s._v("分组单向链表，遍历查询链表获取数据。")])])]),s._v(" "),a("li",[a("p",[s._v("根据非主键搜索")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" k "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("根据 k =5 从非主键索引这个 B+树中查找对应记录，获取主键 id = 500。再根据 id =500 从主键索引获取对应行记录。这个过程叫做 "),a("strong",[s._v("回表")]),s._v("。")])])]),s._v(" "),a("hr"),s._v(" "),a("blockquote",[a("p",[s._v("基于非主键字段进行搜索的时候，会进行回表操作。多扫描一次索引树。")])]),s._v(" "),a("h3",{attrs:{id:"索引维护"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引维护"}},[s._v("#")]),s._v(" 索引维护")]),s._v(" "),a("p",[s._v("B+树为了维护索引有序性，在插入新数据的时候要对顺序进行维护，"),a("strong",[s._v("调整插入数据的位置")]),s._v("。")]),s._v(" "),a("p",[s._v("比如新插入的值为700的时候，需要在 R5 记录后面插入一条新纪录。")]),s._v(" "),a("p",[s._v("如果插入值为400，就需要在逻辑上挪动 R4、R5的位置，空出位置让400插入。")]),s._v(" "),a("h3",{attrs:{id:"页分裂"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#页分裂"}},[s._v("#")]),s._v(" 页分裂")]),s._v(" "),a("p",[s._v("如果在插入值 700 时，R5所在数据页满了，根据 B+树的算法，需要申请一个新的数据页面。并且挪动部分数据过去，这个过程称为"),a("strong",[s._v("页分裂")]),s._v("。")]),s._v(" "),a("p",[a("strong",[s._v("页分裂的过程会影响到性能和页面利用率。")])]),s._v(" "),a("p",[s._v("申请新的页面后，原本一页的数据，分到两个页面，会使页面的利用率降低到50%左右。")]),s._v(" "),a("h3",{attrs:{id:"页合并"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#页合并"}},[s._v("#")]),s._v(" 页合并")]),s._v(" "),a("p",[s._v("当相邻两个页面，由于数据删除导致利用率很低的时候，会将数据页合并。")]),s._v(" "),a("h3",{attrs:{id:"为什么推荐使用自增id作为主键"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么推荐使用自增id作为主键"}},[s._v("#")]),s._v(" 为什么推荐使用自增Id作为主键")]),s._v(" "),a("p",[a("strong",[s._v("从插入方式考虑：")])]),s._v(" "),a("p",[s._v("在使用自增主键的场景下，新增数据时，会获取当前ID最大值+1，作为新增数据的主键。")]),s._v(" "),a("p",[s._v("此时，B+树中会递增插入，减少中间插入导致挪动的情况发生。")]),s._v(" "),a("p",[s._v("若选择业务字段作为主键，则无法保证插入的有序性。")]),s._v(" "),a("p",[a("em",[s._v("使用自增ID可以保证插入的连续性，减少叶子节点的挪动。")])]),s._v(" "),a("p",[a("strong",[s._v("从存储空间考虑：")])]),s._v(" "),a("p",[s._v("非主键字段的索引的叶子节点，存储的都是主键。")]),s._v(" "),a("p",[s._v("假如用一个业务字段（身份证号）作为主键，占用约为20个字节。而用自增ID，整型类作为主键，则只占用4个字节。若为 bigint，则占用 8个字节。")]),s._v(" "),a("p",[a("em",[a("strong",[s._v("主键长度越小，非主键索引叶子节点越小，非主键索引占用空间越小。")])])]),s._v(" "),a("p",[s._v("从插入性能和存储的情况考虑，主键使用自增ID比较合理。")]),s._v(" "),a("h3",{attrs:{id:"适合业务字段作为主键的场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#适合业务字段作为主键的场景"}},[s._v("#")]),s._v(" 适合业务字段作为主键的场景")]),s._v(" "),a("ol",[a("li",[s._v("只有一个索引。")]),s._v(" "),a("li",[s._v("该索引必须为唯一索引。")])]),s._v(" "),a("p",[s._v("将单独的业务字段作为主键，避免根据该字段查询的时候进行回表操作。只需要查一次索引即可。")]),s._v(" "),a("h3",{attrs:{id:"问题记录"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题记录"}},[s._v("#")]),s._v(" 问题记录")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://s2.loli.net/2025/06/13/OJXLPhMvcHUD1dg.png",alt:""}})]),s._v(" "),a("p",[a("img",{attrs:{src:"https://s2.loli.net/2025/06/13/FEb1vh2XuS3ZtQs.png",alt:""}})]),s._v(" "),a("p",[a("img",{attrs:{src:"https://s2.loli.net/2025/06/13/EFU2W1RnKDmJ4ay.png",alt:""}})]),s._v(" "),a("h2",{attrs:{id:"覆盖索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#覆盖索引"}},[s._v("#")]),s._v(" 覆盖索引")]),s._v(" "),a("p",[s._v("在使用非主键索引时，找到了索引叶子节点上的主键后，要二次搜素主键索引获取记录，这个过程叫回表。")]),s._v(" "),a("hr"),s._v(" "),a("p",[s._v("有些情况可以避免回表，比如只查询主键，查找非主键索引就能获取主键信息，不需要回表操作。")]),s._v(" "),a("p",[s._v("即非主键索引已经覆盖了查询需求，称为"),a("strong",[s._v("覆盖索引")]),s._v("。")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://s2.loli.net/2025/06/13/3htEkaHp2wZVDzR.png",alt:""}})]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" T "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" k "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("between")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("and")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("执行该语句时。")]),s._v(" "),a("ul",[a("li",[s._v("在 k 索引树找到 3，进行回表操作找到 R3。")]),s._v(" "),a("li",[s._v("按顺序继续找到 5，进行回表操作找到 R4。")]),s._v(" "),a("li",[s._v("按顺序找到 6，此时发现不匹配，结束查询。")])]),s._v(" "),a("p",[s._v("整个过程查询了3次 k 索引，进行了2次回表。将两条记录返回给 Server 层。")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" ID "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" T "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" k "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("between")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("and")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("根据 k 查找 k索引的时候，"),a("code",[s._v("between 3 and 5")]),s._v(" 会按顺序匹配 3、5、6。6发现不匹配，结束查找。将3、5返回给 Server 层的执行器。")]),s._v(" "),a("p",[s._v("整个过程查询了3次 k 索引，没有回表操作。将两条记录返回给 Server 层。")]),s._v(" "),a("p",[s._v("覆盖索引，可以降低查找索引的次数，减少回表，显著提高查询性能。所以使用覆盖索引是一种查询SQL语句的优化方式。")]),s._v(" "),a("h2",{attrs:{id:"联合索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#联合索引"}},[s._v("#")]),s._v(" 联合索引")]),s._v(" "),a("p",[s._v("假如存在 (name，age）联合索引。")]),s._v(" "),a("p",[s._v("索引会先按照 name 字段排序，相同 name 字段按照 age 字段排序。")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://s2.loli.net/2025/06/13/j2cu1LJzYaEWxGr.png",alt:""}})]),s._v(" "),a("h3",{attrs:{id:"联合索引的覆盖索引情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#联合索引的覆盖索引情况"}},[s._v("#")]),s._v(" 联合索引的覆盖索引情况")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" age "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("user")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'张三'")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("根据 name 查找 age 时，索引叶子节点包含了查询的结果，无需进行回表。")]),s._v(" "),a("hr"),s._v(" "),a("p",[s._v("但是根据 age 查找 name 的话，并不会利用到该索引。")]),s._v(" "),a("h3",{attrs:{id:"联合索引有效情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#联合索引有效情况"}},[s._v("#")]),s._v(" 联合索引有效情况")]),s._v(" "),a("ol",[a("li",[s._v("根据 name 查找。")]),s._v(" "),a("li",[s._v("根据 name like ‘张%’ 进行模糊查找。")])]),s._v(" "),a("hr"),s._v(" "),a("p",[s._v("因为索引是按照前面的字段进行排序的，只有保证前面部分能匹配，就能保证有序性。进而利用到索引。")]),s._v(" "),a("h2",{attrs:{id:"最左前缀原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最左前缀原则"}},[s._v("#")]),s._v(" 最左前缀原则")]),s._v(" "),a("p",[s._v("在联合索引（name,age,address）情况下，满足以下规则，索引会生效。")]),s._v(" "),a("ol",[a("li",[a("p",[s._v("匹配索引最左的 N 个字段。")]),s._v(" "),a("p",[s._v("name = ’张三‘ and age = 10")])]),s._v(" "),a("li",[a("p",[s._v("匹配最左边字符串索引的最左 M 个字符。")]),s._v(" "),a("p",[s._v("name like ‘张%’")])])]),s._v(" "),a("hr"),s._v(" "),a("p",[s._v("最左前缀原则，要求我们在建立联合索引的时候，要适当选择最左边的字段。")]),s._v(" "),a("h2",{attrs:{id:"索引下推"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#索引下推"}},[s._v("#")]),s._v(" 索引下推")]),s._v(" "),a("p",[s._v("联合索引（name，age）的情况下。")]),s._v(" "),a("p",[s._v("查询 name 时满足最左前缀原则，可以利用索引快速查询。但是根据 name 去查询 age 时，情况有所不同。")]),s._v(" "),a("div",{staticClass:"language-sql line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("select")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("from")]),s._v(" tuser "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("where")]),s._v(" name "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("like")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'张 %'")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("and")]),s._v(" age"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("and")]),s._v(" ismale"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("比如查询 name 姓张并且年龄10岁的男孩。")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("在 MySQL 5.6 之前，在联合索引中根据 "),a("code",[s._v("name like '张 %'")]),s._v(" 获取主键后，只能通过回表操作从主键索引中获取记录，再进行条件匹配。")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://s2.loli.net/2025/06/13/18qzYcl2rFAUjnd.png",alt:""}})])]),s._v(" "),a("li",[a("p",[s._v("在 MySQL 5.6之后，引入了"),a("strong",[s._v("索引下推优化")]),s._v("。"),a("em",[a("strong",[s._v("在非主键索引遍历后，对索引包含的字段进行遍历，直接过滤掉不满足的记录行，减少回表的次数")])]),s._v("。")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://s2.loli.net/2025/06/13/GAf3LJqjiUFm9e4.png",alt:""}})]),s._v(" "),a("p",[s._v("比如查询 ID3 时，age=30，直接过滤掉，不会进行回表操作。")])])])])}),[],!1,null,null,null);a.default=r.exports}}]);