import{_ as a,c as i,o as s,ag as l}from"./chunks/framework.D7pKEi_Q.js";const k=JSON.parse('{"title":"一条更新SQL的执行过程","description":"","frontmatter":{},"headers":[],"relativePath":"database/mysql/一条更新SQL的执行过程.md","filePath":"database/mysql/一条更新SQL的执行过程.md"}'),t={name:"database/mysql/一条更新SQL的执行过程.md"};function o(d,e,p,n,r,h){return s(),i("div",null,e[0]||(e[0]=[l('<h1 id="一条更新sql的执行过程" tabindex="-1">一条更新SQL的执行过程 <a class="header-anchor" href="#一条更新sql的执行过程" aria-label="Permalink to &quot;一条更新SQL的执行过程&quot;">​</a></h1><p><a href="https://juejin.cn/post/6920076107609800711#heading-9" target="_blank" rel="noreferrer">juejin.cn</a></p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mysql</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> update T set c</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">c</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> where ID</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h2 id="执行流程" tabindex="-1">执行流程 <a class="header-anchor" href="#执行流程" aria-label="Permalink to &quot;执行流程&quot;">​</a></h2><ol><li><p>执行器先找引擎取出 ID=2 这一行记录。</p><ul><li>如果该行记录在 <code>Buffer Pool</code> 中存在，会直接返回数据给执行器。</li><li>如果该行记录不存在，则会先进行如下操作，再返回数据给执行器。 <ul><li>从磁盘中查找数据。</li><li>将数据写入内存 <code>Buffer Pool</code> 中。</li><li>将数据写入 <code>undo.log</code>（记录 insert、update、delete等修改数据的操作）。</li></ul></li></ul></li><li><p>执行器获取到引擎给的行数据，把这条数据更新 c+1，得到新的一行数据，再调用引擎接口写入新数据。</p></li><li><p>引擎会将新数据写入<code>Buffer Pool</code> 中，同时将更新的操作记录写入<code>redo log buffer</code>中。然后告知执行器更新完成，可以提交事务。</p><p>此时 <code>redo log</code> 处于 <code>prepare</code>阶段（一阶段提交）。</p></li><li><p>执行器生成更新操作的 <code>bin.log</code> 记录，并将 <code>bin.log</code> 追加到磁盘文件中。</p></li><li><p>执行器调用引擎的提交事务接口。</p><p>引擎把刚才写入到 <code>redo.log</code> 的状态改为 <code>commit</code> 状态（二阶段提交），至此更新完成。</p></li></ol><p><img src="https://s2.loli.net/2025/06/13/B7FTunfIVkCcdjR.png" alt=""></p><hr><h3 id="执行流程图" tabindex="-1">执行流程图 <a class="header-anchor" href="#执行流程图" aria-label="Permalink to &quot;执行流程图&quot;">​</a></h3><p><img src="https://s2.loli.net/2025/06/13/jsGzBW5hlZyrfPU.png" alt=""></p>',9)]))}const g=a(t,[["render",o]]);export{k as __pageData,g as default};
