import{_ as t,c as a,o as r,aN as o}from"./chunks/framework.A-MC8nKA.js";const d=JSON.parse('{"title":"零拷贝","description":"","frontmatter":{},"headers":[],"relativePath":"frame/netty/零拷贝.md","filePath":"frame/netty/零拷贝.md","lastUpdated":1752827238000}'),p={name:"frame/netty/零拷贝.md"};function n(f,e,l,_,s,i){return r(),a("div",null,e[0]||(e[0]=[o('<h1 id="零拷贝" tabindex="-1">零拷贝 <a class="header-anchor" href="#零拷贝" aria-label="Permalink to &quot;零拷贝&quot;">​</a></h1><ol><li><p>ByteBuf 可以直接使用直接内存。</p><p>Socket 通信如果采用堆内存的话，需要将堆里的对象拷贝到堆外，进行一次对象拷贝。</p><blockquote><p>原因是因为堆里面的对象可能会随着垃圾回收改变对象地址，所以对该对象的引用更新地址。</p></blockquote><p>但是 Socket 没有更新对象地址动作，需要的是一个固定的地址。所以堆内存不适合 Socket 使用。只能将对象拷贝到直接内存然后使用。</p><p>而 <strong>ByteBuf 直接使用直接内存，减少了对象拷贝</strong>。</p></li><li><p>Netty 提供了组合 Buffer，可以将多个 Buffer 合并为一个。</p><p>传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。</p><p>而 Netty 无需内存拷贝就可以聚合 Buffer。</p></li><li><p>Netty 的文件传输采用transferTo，直接发给 Channel，避免进行内存拷贝。</p></li></ol>',2)]))}const u=t(p,[["render",n]]);export{d as __pageData,u as default};
