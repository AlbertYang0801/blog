import{_ as i,c as a,o as e,ag as t}from"./chunks/framework.D7pKEi_Q.js";const o=JSON.parse('{"title":"ClickHouse高级","description":"","frontmatter":{},"headers":[],"relativePath":"database/clickhouse/ClickHouse高级.md","filePath":"database/clickhouse/ClickHouse高级.md"}'),l={name:"database/clickhouse/ClickHouse高级.md"};function n(p,s,h,k,r,d){return e(),a("div",null,s[0]||(s[0]=[t('<h1 id="clickhouse高级" tabindex="-1">ClickHouse高级 <a class="header-anchor" href="#clickhouse高级" aria-label="Permalink to &quot;ClickHouse高级&quot;">​</a></h1><h2 id="mergetree" tabindex="-1">MergeTree <a class="header-anchor" href="#mergetree" aria-label="Permalink to &quot;MergeTree&quot;">​</a></h2><p>ClickHouse 中最强大的表引擎当属 MergeTree（合并树）引擎及该系列（MergeTree）中的其他引擎，支持索引和分区，地位可以相当于 innodb 之于 Mysql。而且基于 MergeTree，还衍生除了很多小弟，也是非常有特色的引擎。</p><p><strong>建表语句</strong></p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">create</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> table</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> t_order_mt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id UInt32,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sku_id String,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> total_amount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Decimal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> create_time </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Datetime</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) engine </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> MergeTree</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> partition</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> toYYYYMMDD(create_time)</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> primary key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (id)</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> order by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (id,sku_id);</span></span></code></pre></div><h3 id="partition-分区" tabindex="-1">partition - 分区 <a class="header-anchor" href="#partition-分区" aria-label="Permalink to &quot;partition - 分区&quot;">​</a></h3><p>分区的目的主要是降低扫描的范围，优化查询速度。</p><ul><li><p>并行</p><p>分区后，面对涉及跨分区的查询统计，ClickHouse 会以分区为单位并行处理。</p></li><li><p>分区目录</p><p>MergeTree 是以列文件 + 索引文件 + 表定义文件组成的，但是如果设定了分区那么这些文件就会保存到不同的分区目录中。</p></li><li><p>数据写入</p><p>任何一个批次的数据写入都会产生一个临时分区，不会纳入任何一个已有的分区。</p></li><li><p>分区合并</p><p>写入后的某个时刻（大概 10-15 分钟后）ClickHouse 会自动执行合并操作（等不及也可以手动通过 optimize 执行），把临时分区的数据，合并到已有分区中。</p></li></ul><h3 id="primary-key-主键" tabindex="-1">primary key - 主键 <a class="header-anchor" href="#primary-key-主键" aria-label="Permalink to &quot;primary key - 主键&quot;">​</a></h3><p>ClickHouse 中的主键，和其他数据库不太一样，它只提供了数据的一级索引，但是却不是唯一约束。这就意味着是<strong>可以存在相同 primary key 的数据</strong>的。</p><p>主键的设定主要依据是查询语句中的 where 条件。</p><p>根据条件通过对 <strong>主键进行某种形式的二分查找</strong>，能够定位到对应的 index granularity , 避免了全表扫描。（稀疏索引二分查找）</p><h3 id="索引粒度-index-granularity" tabindex="-1">索引粒度 - index granularity <a class="header-anchor" href="#索引粒度-index-granularity" aria-label="Permalink to &quot;索引粒度 - index granularity&quot;">​</a></h3><p>指在稀疏索引中两个相邻索引对应数据的间隔。</p><p>ClickHouse 中的 MergeTree 默认是 <code>8192</code>。官方不建议修改这个值，除非该列存在大量重复值，比如在一个分区中几万行才有一个不同数据。</p><p><img src="https://s2.loli.net/2025/06/24/eDJNTVM9HS3bcyu.png" alt="image.png"></p><h3 id="order-by-必选" tabindex="-1">order by - 必选 <a class="header-anchor" href="#order-by-必选" aria-label="Permalink to &quot;order by - 必选&quot;">​</a></h3><p>order by 设置了分区里面数据按照哪些字段有序保存，是 MergeTree 必填的。</p><p>如果没有设置主键，那么就会按照 order by 的前几个字段作为主键。</p><blockquote><p>order by 前面的字段，必须按照主键的意义设置。</p></blockquote><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">order by</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id,sku_id,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">name</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">//</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">主键 必须是 id，或者 id,sku_id</span></span></code></pre></div><h3 id="ttl" tabindex="-1">TTL <a class="header-anchor" href="#ttl" aria-label="Permalink to &quot;TTL&quot;">​</a></h3><h3 id="表级别-ttl" tabindex="-1">表级别 TTL <a class="header-anchor" href="#表级别-ttl" aria-label="Permalink to &quot;表级别 TTL&quot;">​</a></h3><p>可以设置表数据按照某个字段过期，过期后数据会被删除。</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">alter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> table</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t_order_mt3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">MODIFY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> TTL create_time </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> INTERVAL </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> SECOND</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ReplicatedMergeTree(</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">	&#39;/clickhouse/tables/eeeaebb1-3f5b-4d86-bcc5-e6feeb50babe/{shard}&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">	 &#39;{replica}&#39;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">PARTITION</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> BY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (toDate(ts), </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`0_masterip`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">PRIMARY KEY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (toStartOfHour(ts), </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`0_masterip`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`0_ns`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`0_wkd_type`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`0_wkd`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`1_masterip`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`1_ns`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`1_wkd_type`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`1_wkd`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ORDER BY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (toStartOfHour(ts), </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`0_masterip`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`0_ns`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`0_wkd_type`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`0_wkd`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`1_masterip`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`1_ns`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`1_wkd_type`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`1_wkd`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ts) </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TTL toDateTime(ts) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> toIntervalDay(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SETTINGS index_granularity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8192</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ttl_only_drop_parts </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span></code></pre></div><p>设置 TTL 根据 ts 的时间 7 天后过期（分区字段 ts）。</p><p>涉及判断的字段必须是 Date 或者 Datetime 类型，推荐使用分区的日期字段。</p><h2 id="replacingmergetree" tabindex="-1">ReplacingMergeTree <a class="header-anchor" href="#replacingmergetree" aria-label="Permalink to &quot;ReplacingMergeTree&quot;">​</a></h2><p>继承于 MergeTree，多了<strong>去重</strong>的功能。</p><blockquote><p>Merge 虽然可以设置主键，但是主键不具备唯一约束的功能。可以通过 ReplacingMergeTree 实现去重。</p></blockquote><h3 id="去重机制" tabindex="-1">去重机制 <a class="header-anchor" href="#去重机制" aria-label="Permalink to &quot;去重机制&quot;">​</a></h3><ul><li><p>去重时机</p><p>在分区 Merge 的时候去重。</p></li><li><p>去重范围</p><p>如果表经过了分区，去重只能在单个分区里面进行。并不能跨分区去重。</p><blockquote><p>所以 ReplacingMergeTree 并不能保证数据完全不重复，只是单个分区里面去重。</p></blockquote></li><li><p>去重作用</p><p>ReplcaingMergeTree 并不能保证数据完全去重，只能减少分区的磁盘占用空间。</p></li></ul><ol><li>使用 order by 作为唯一键</li><li>去重不能跨分区</li><li>只有同一批插入的数据和合并的时候才会触发去重。</li></ol><h2 id="sql-操作" tabindex="-1">SQL 操作 <a class="header-anchor" href="#sql-操作" aria-label="Permalink to &quot;SQL 操作&quot;">​</a></h2><h3 id="删除操作" tabindex="-1">删除操作 <a class="header-anchor" href="#删除操作" aria-label="Permalink to &quot;删除操作&quot;">​</a></h3><p>ClickHouse 的删除和更新操作比较重。</p><p>“重”的原因主要是<strong>每次修改或者删除都会导致放弃目标数据的原有分区</strong>，重建新分区。</p><p>所以尽量做批量的变更，不要进行频繁小数据的操作。</p><p>Mutation 语句分两步执行，同步执行的。</p><ul><li><strong>进行新增数据新增分区</strong></li><li><strong>旧分区打上逻辑上的失效标记</strong>。</li></ul><p><strong>直到触发分区合并的时候，才会删除旧数据释放磁盘空间，一般不会开放这样的功能给用户，由管理员完成。</strong></p><h2 id="副本" tabindex="-1">副本 <a class="header-anchor" href="#副本" aria-label="Permalink to &quot;副本&quot;">​</a></h2><p>副本的目的主要是保证数据的高可用性，即使一台节点宕机，通过其它节点副本也可以恢复数据。</p><h3 id="副本写入流程" tabindex="-1">副本写入流程 <a class="header-anchor" href="#副本写入流程" aria-label="Permalink to &quot;副本写入流程&quot;">​</a></h3><p><img src="https://s2.loli.net/2025/06/24/dFNEWg6bQZq8Tfu.png" alt="image.png"></p><h2 id="分片" tabindex="-1">分片 <a class="header-anchor" href="#分片" aria-label="Permalink to &quot;分片&quot;">​</a></h2><p>引入分片将数据水平切分分布到多个节点上，再通过 Distributed 进行逻辑聚合。查询的时候就可以查到全量的数据了。</p><p>类似 es 的分片机制。</p><h3 id="逻辑表引擎-distributed" tabindex="-1">逻辑表引擎-Distributed <a class="header-anchor" href="#逻辑表引擎-distributed" aria-label="Permalink to &quot;逻辑表引擎-Distributed&quot;">​</a></h3><p>Distributed 表引擎本身不存储数据。</p><p>通过分布式逻辑表来写入、分发、路由来操作多个节点不同分片的分布式数据。</p><ul><li>写入流程</li></ul><p><img src="https://s2.loli.net/2025/06/24/U58WE3qGojrO2Ke.png" alt="image.png"></p><ul><li><p>读取流程</p><p>由 distribute 发送读命令，发送读取命令到各个分片，选择 errors_count 小的副本。</p></li></ul><p><img src="https://s2.loli.net/2025/06/24/IeXBt6S2ZKdlOLs.png" alt="image.png"></p><h3 id="表设计" tabindex="-1">表设计 <a class="header-anchor" href="#表设计" aria-label="Permalink to &quot;表设计&quot;">​</a></h3><ul><li><p>entity 的 distributed 引擎设计</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Distributed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;{cluster}&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;ebpf&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;entity_detail_local&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">rand</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div></li><li><p>ReplicatedMergeTree 表设计</p><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ReplicatedMergeTree(</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;/clickhouse/tables/f1e4f1d1-cfb0-4a70-83b4-642702ec302e/{shard}&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;{replica}&#39;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">PARTITION</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> BY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (toDate(ts), masterip) </span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">PRIMARY KEY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (toStartOfHour(ts), masterip, ns, wkd_type, wkd, pod) </span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ORDER BY</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (toStartOfHour(ts), masterip, ns, wkd_type, wkd, pod, ts)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">TTL toDateTime(ts) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> toIntervalDay(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SETTINGS index_granularity </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 8192</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ttl_only_drop_parts </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span></code></pre></div></li></ul><h3 id="联表查询-global" tabindex="-1">联表查询-GLOBAL <a class="header-anchor" href="#联表查询-global" aria-label="Permalink to &quot;联表查询-GLOBAL&quot;">​</a></h3><p>两张分布式表的 IN 或者 JOIN 必须加上 <code>GLOBAL</code> 关键字。</p><ul><li>如果加上，只会在分配到的节点上联表查询一次，并把查询结果发给其它节点。</li><li>如果不加上，每个节点都要联表查询一次。</li></ul>',61)]))}const g=i(l,[["render",n]]);export{o as __pageData,g as default};
