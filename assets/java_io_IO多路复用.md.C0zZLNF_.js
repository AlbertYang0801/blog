import{_ as a,c as p,o as e,aN as s}from"./chunks/framework.A-MC8nKA.js";const b=JSON.parse('{"title":"IO多路复用","description":"","frontmatter":{},"headers":[],"relativePath":"java/io/IO多路复用.md","filePath":"java/io/IO多路复用.md","lastUpdated":1751453543000}'),n={name:"java/io/IO多路复用.md"};function t(i,l,o,r,c,d){return e(),p("div",null,l[0]||(l[0]=[s(`<h1 id="io多路复用" tabindex="-1">IO多路复用 <a class="header-anchor" href="#io多路复用" aria-label="Permalink to &quot;IO多路复用&quot;">​</a></h1><p><a href="https://www.bilibili.com/video/BV1r54y1f7bU/?spm_id_from=333.337.search-card.all.click&amp;vd_source=e98aef20b1bd281c1b564fb64680bdbc" target="_blank" rel="noreferrer">小白也看得懂的 I/O 多路复用解析（超详细案例）_哔哩哔哩_bilibili</a></p><h2 id="基础概念" tabindex="-1">基础概念 <a class="header-anchor" href="#基础概念" aria-label="Permalink to &quot;基础概念&quot;">​</a></h2><p><img src="https://s2.loli.net/2025/05/29/ZFcCgP9ytOh4mTi.png" alt="" loading="lazy"></p><ol><li><p>Socket</p><p>套接字，在网络通信中，就是客户端和服务端的出入口。</p><blockquote><p>套接字看作不同主机间的进程进行双间通信的端点。是计算机之间进行通信的一种约定或一种方式，用于描述IP地址和端口。</p></blockquote></li></ol><blockquote></blockquote><ol start="2"><li><p>fd</p><p>文件描述符，是指向资源文件的索引。</p></li></ol><h3 id="socket通讯的过程" tabindex="-1">Socket通讯的过程 <a class="header-anchor" href="#socket通讯的过程" aria-label="Permalink to &quot;Socket通讯的过程&quot;">​</a></h3><p><img src="https://s2.loli.net/2025/05/29/qsfa1ncBJWr47Xw.png" alt="" loading="lazy"></p><ol><li>服务端通过 bind 绑定机器的端口号， 进程 listen 某个端口。</li><li>客户端和服务端通过 tcp 三次握手建联。</li><li>进行数据交互，</li><li>最后通过 close 断开连接。</li></ol><h2 id="io模型" tabindex="-1">IO模型 <a class="header-anchor" href="#io模型" aria-label="Permalink to &quot;IO模型&quot;">​</a></h2><p><img src="https://s2.loli.net/2025/05/29/inahdX3PRfgQBT7.png" alt="" loading="lazy"></p><h3 id="同步阻塞io-bio" tabindex="-1">同步阻塞IO - BIO <a class="header-anchor" href="#同步阻塞io-bio" aria-label="Permalink to &quot;同步阻塞IO - BIO&quot;">​</a></h3><ul><li><p>单线程</p><p>单线程情况下，Socket 会阻塞其它 Socket，直到 当前 Socket 结束。</p></li><li><p>多线程</p><p>多线程情况下，假如每个客户端分一个线程，容易造成资源浪费。</p><p>比如不同时刻就绪的四个 Scoket，原本一个线程就能执行完。</p><p><img src="https://s2.loli.net/2025/05/29/qGUzi3YOZyQJ92p.png" alt="" loading="lazy"></p></li></ul><h3 id="同步非阻塞io-nio" tabindex="-1">同步非阻塞IO - NIO <a class="header-anchor" href="#同步非阻塞io-nio" aria-label="Permalink to &quot;同步非阻塞IO - NIO&quot;">​</a></h3><blockquote><p>阻塞 IO 在处理多个 Scoket 时，如果当前 Socket 无数据发送，会一直等待。</p></blockquote><p>而非阻塞 IO 就是操作系统为了解决阻塞问题做出的优化。</p><hr><p>非阻塞 IO 在处理多个 Socket 时，如果当前 Socket 无数据到达，会继续检查下一个 Socket。<strong>不会阻塞在当前 Socket</strong>。</p><p><img src="https://s2.loli.net/2025/05/29/WJK8qzUoHr7Qjap.png" alt="" loading="lazy"></p><p>当前 Socket 数据到达之后，进行数据交互。</p><blockquote><p>数据处理也可以采用异步方式，即开启一个新线程去处理该 Socket 请求。主线程继续判断其它 Socket。</p></blockquote><p><img src="https://s2.loli.net/2025/05/29/Trnk7xXsRIKw2CU.png" alt="" loading="lazy"></p><h3 id="优缺点" tabindex="-1">优缺点 <a class="header-anchor" href="#优缺点" aria-label="Permalink to &quot;优缺点&quot;">​</a></h3><ul><li><p>优点</p><p>解决了Socket 阻塞问题。</p></li><li><p>缺点</p><p>需要不停的轮询，过程中的系统调用、用户态和系统态的切换都是不小的开销。</p><blockquote><p>read 函数 从用户态将 fd 拷贝到内核态。</p></blockquote></li></ul><blockquote></blockquote><h2 id="io多路复用-1" tabindex="-1">IO多路复用 <a class="header-anchor" href="#io多路复用-1" aria-label="Permalink to &quot;IO多路复用&quot;">​</a></h2><p>多路复用就是使用<code>一个或一组线程（线程池）处理多个TCP连接</code>。</p><ul><li>select/poll/epoll 核心是可以同时处理多个connection，而不是更快，所以连接数不高的话，性能不一定比多线程+阻塞IO 好。</li></ul><h3 id="select" tabindex="-1">select <a class="header-anchor" href="#select" aria-label="Permalink to &quot;select&quot;">​</a></h3><p>为了解决用户态和内核态的频繁切换，select 函数将 fd 整体拷贝到内核态，在内核态进行轮询。</p><p>而轮询过程select 函数是阻塞的，直到以下条件达成。</p><ol><li>有监测事件发生，此时select函数返回大于0的值。</li><li>超时，此时select函数返回0。</li><li>select函数发生错误，此时返回-1。</li></ol><p><img src="https://s2.loli.net/2025/05/29/VU852b9NovWFqth.png" alt="" loading="lazy"></p><p>使用 fd_set 表示监听的文件 fd。</p><p><img src="https://s2.loli.net/2025/05/29/sfCeluJjg9WpxQi.png" alt="" loading="lazy"></p><p><strong>fd_set</strong></p><ul><li><p>入参</p><p>指定需要监听的 fd，数据长度限制了监听的 fd 个数。</p></li><li><p>出参</p><p>直接修改指定位上的值，表示该位代表的 fd 是否就绪。</p></li></ul><p><img src="https://s2.loli.net/2025/05/29/Y7tedJvkwg5b4xz.png" alt="" loading="lazy"></p><p><img src="https://s2.loli.net/2025/05/29/Oyqxw4SrIGgmNs8.png" alt="" loading="lazy"></p><blockquote><p>核心就是将事件就绪检查逻辑整体放到内核态，减少系统调用。</p></blockquote><p>检查完成之后返回就绪的事件数量，但是没有返回是哪个 fd。</p><p>使用select函数进行 IO 请求和 同步阻塞模型 没有太大的区别，甚至还多了添加监视socket，以及调用select函数的额外操作，效率更差。</p><p>但是，使用select以后最大的优势是用户可以<strong>在一个线程内同时处理多个socket的IO请求</strong>。用户可以注册多个socket，然后不断地调用select读取被激活的socket，即可<strong>达到在同一个线程内同时处理多个IO请求的目的</strong>。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。</p><p><strong>缺点</strong></p><ul><li><p>不知道具体哪个 fd 就绪，需要遍历。</p></li><li><p>单进程监听的 fd 有限制，默认 1024。</p><p>这里的限制跟入参fd_set 的长度有关系（默认 1024）</p></li><li><p>入参的 fd_set 每次调用都被重置。</p><p>使用位图作为数据结构，出参是在入参基础上修改的。所以每次调用都需要重置 fd_set。</p></li></ul><h3 id="poll" tabindex="-1">poll <a class="header-anchor" href="#poll" aria-label="Permalink to &quot;poll&quot;">​</a></h3><p>由于 select 的 fd_set 带来的缺点，poll 针对缺点进行了优化。</p><p><img src="https://s2.loli.net/2025/05/29/VdU9JE1t7MHipZB.png" alt="" loading="lazy"></p><p>入参取消 fd_set，改为可以复用的 pollfd。</p><blockquote><p>可以看到 pollfd 里面包含了fd、监听的事件和就绪的事件，这样再重复调用的时候就不需要重置参数。</p></blockquote><p>而且 pollfd 作为集合，拷贝到内核态之后是<code>链表</code>形式，所以是没有长度限制的。</p><p><img src="https://s2.loli.net/2025/05/29/rH2zRcsV6YkOx5d.png" alt="" loading="lazy"></p><p><code>poll 和 select整体对比，其实就是改变了入参，避免了 fd 限制和重置问题。</code></p><p>但是 poll 还是遗留了两个问题。</p><ul><li>每次需要将 fd 从用户态拷贝到内核态。</li><li>检测成功后不知道具体就绪的 fd，需要遍历全部的 fd。</li></ul><h3 id="epoll" tabindex="-1">epoll <a class="header-anchor" href="#epoll" aria-label="Permalink to &quot;epoll&quot;">​</a></h3><p>epoll 就是针对 select 和 poll 的优化，解决 poll 遗留的两个问题。</p><p>通过 红黑树 + 链表 + 回调函数解决。</p><p><img src="https://s2.loli.net/2025/05/29/eZFLQ4fiDGndmYH.png" alt="" loading="lazy"></p><p><img src="https://s2.loli.net/2025/05/29/OhbymDL8VIKcHsr.png" alt="" loading="lazy"></p><h3 id="epoll-create" tabindex="-1">epoll_create <a class="header-anchor" href="#epoll-create" aria-label="Permalink to &quot;epoll_create&quot;">​</a></h3><p>当进程调用 <code>epoll_create</code>时候，内核会创建 <code>eventpoll</code>结构体。</p><p><img src="https://s2.loli.net/2025/05/29/c5EaZVeRKM79Nur.png" alt="image-20250529185122163" loading="lazy"></p><ul><li><p>eventpoll</p><p>每个epoll实例有自己的 eventpoll 实例。</p><ul><li><p>rbr</p><p>红黑树，保存需要监控的 fd。</p></li><li><p>rdlist</p><p>双向链表，存放就绪的 fd。</p></li></ul><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct eventpoll{</span></span>
<span class="line"><span>....</span></span>
<span class="line"><span>/*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span></span>
<span class="line"><span>struct rb_root rbr;            //红黑树的根节点</span></span>
<span class="line"><span>/*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span></span>
<span class="line"><span>struct list_head rdlist;     //双向列表的头结点</span></span>
<span class="line"><span>....</span></span>
<span class="line"><span>};</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li></ul><h3 id="epoll-ctl" tabindex="-1">epoll_ctl <a class="header-anchor" href="#epoll-ctl" aria-label="Permalink to &quot;epoll_ctl&quot;">​</a></h3><p>将需要监听的文件描述符进行注册，内核会为这次动作构建一个红黑树的节点，并插入到红黑树中；</p><p>将需要监听的 fd 进行注册，生成 epitem 并添加到 rbr（红黑树）中。</p><p><img src="https://s2.loli.net/2025/05/29/ufkpwWAtgbY7NU4.png" alt="image-20250529185057235" loading="lazy"></p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>struct epitem{</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  struct rb_node rbn;//红黑树节点</span></span>
<span class="line"><span>  struct list_head rdllink;//双向链表节点</span></span>
<span class="line"><span>  struct eventpoll *ep; //指向其所属的eventpoll对象</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  pwqlist; //回调函数</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>将 fd 写入到 rbr 之后，<strong>内核会为 epitem 设置回调函数</strong>。</p><blockquote><p>内核会为这个 fd 与网卡驱动程序建立回调关系，当事件就绪时，会调用已经建立好的回调方法。这个回调方法会将发生的事件添加到就绪链表中；</p></blockquote><p>通过客户端发来的数据包通过网卡驱动找到对应的 epitem，然后进行操作。</p><p><img src="https://s2.loli.net/2025/05/29/6Upnt482fNASsMG.png" alt="image-20250529185046741" loading="lazy"></p><h3 id="epoll-wait" tabindex="-1">epoll_wait <a class="header-anchor" href="#epoll-wait" aria-label="Permalink to &quot;epoll_wait&quot;">​</a></h3><p>epoll_wait 会检查就绪列表里的事件。</p><ul><li><p>就绪列表不为空</p><p><strong>有就绪事件，将事件拷贝到用户态进行处理。</strong></p></li><li><p>就绪列表为空</p><p>将 epoll 进程放到 eventpoll （epoll 实例）的等待队列中，让出 CPU 。（等待 epitem 对应的回调函数唤醒）</p></li></ul><p><img src="https://s2.loli.net/2025/05/29/yAZwCvEm5Y1rqkN.png" alt="" loading="lazy"></p><p>通过客户端发来的数据找到对应的 epitem 之后，执行 epitem 的回调函数。执行过程会唤醒 eventpoll 等待队列中的epoll 进程，然后 添加到就绪队列。最后 epoll_wait获取就绪事件。</p><p><img src="https://s2.loli.net/2025/05/29/FkAfNbrxORjmwHK.png" alt="" loading="lazy"></p><p><code>在高并发场景下，epoll_wait 检查就绪队列，就绪事件会很多并且非常快。</code></p><p><img src="https://s2.loli.net/2025/05/29/2fdvV7qPSBGDeRU.png" alt="" loading="lazy"></p><ul><li>避免了每次都需要将 fd 从用户态拷贝到内核态，epoll 只需要在注册事件的时候拷贝一次。</li><li>不需要遍历所有 fd来找到就绪 fd，通过 epoll_wait 检查就绪队列可以直接找到就绪的 fd。</li></ul><h3 id="epoll的工作方式" tabindex="-1">epoll的工作方式 <a class="header-anchor" href="#epoll的工作方式" aria-label="Permalink to &quot;epoll的工作方式&quot;">​</a></h3><ul><li><p>水平触发（LT）</p><p><strong>LT 是 epoll 默认的通知方式。</strong></p><p>epoll_wait 检测到事件就绪后，后续的 epoll_wait 继续检测到该事件后，该事件未完成，会继续发通知。</p><p>这样 epoll_wait 的通知次数会增多，性能比 ET 低，但是更可靠。</p></li><li><p>边缘触发（ET）</p><p>ET 是只在第一次监测到时间的时候通知，之后不再通知。epoll_wait 通知次数少，性能更高。</p><p><img src="https://s2.loli.net/2025/05/29/uwsWq8tyal9XAdp.png" alt="" loading="lazy"></p></li></ul>`,85)]))}const u=a(n,[["render",t]]);export{b as __pageData,u as default};
