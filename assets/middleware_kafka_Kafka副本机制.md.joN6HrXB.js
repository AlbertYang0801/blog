import{_ as a,c as l,o as r,aN as o}from"./chunks/framework.A-MC8nKA.js";const h=JSON.parse('{"title":"Kafka副本机制","description":"","frontmatter":{},"headers":[],"relativePath":"middleware/kafka/Kafka副本机制.md","filePath":"middleware/kafka/Kafka副本机制.md","lastUpdated":1752827238000}'),t={name:"middleware/kafka/Kafka副本机制.md"};function i(d,e,n,p,s,c){return r(),l("div",null,e[0]||(e[0]=[o('<h1 id="kafka副本机制" tabindex="-1">Kafka副本机制 <a class="header-anchor" href="#kafka副本机制" aria-label="Permalink to &quot;Kafka副本机制&quot;">​</a></h1><p><img src="https://s2.loli.net/2025/06/26/OULBqCvD7pRfPEk.png" alt="image.png" loading="lazy"></p><p>Kafka 的副本是针对分区来说的，为分区创建副本。</p><p>副本的作用就是提供<strong>数据冗余，在 Leader 副本挂掉之后，转换为 Leader 副本继续工作。</strong></p><p>不然当 Leader 副本挂掉之后，该分区就会停止对外提供服务。</p><blockquote><p>Kafka的副本并不提供读写功能，为了避免数据读写差异导致的数据不一致问题出现。</p></blockquote><h3 id="副本同步" tabindex="-1">副本同步 <a class="header-anchor" href="#副本同步" aria-label="Permalink to &quot;副本同步&quot;">​</a></h3><p><img src="https://s2.loli.net/2025/06/26/49rwoxeGLvzcubB.png" alt="image.png" loading="lazy"></p><p>生产者只会往分区的 Leader 发消息，而其它 Follower 会从 Leader 拉取数据进行同步。</p><h3 id="follower追随者副本" tabindex="-1">Follower追随者副本 <a class="header-anchor" href="#follower追随者副本" aria-label="Permalink to &quot;Follower追随者副本&quot;">​</a></h3><p>Follower 副本是不对外提供服务的，只是定期地异步拉取领导者副本中的数据而已。</p><h2 id="lsr副本集合" tabindex="-1">LSR副本集合 <a class="header-anchor" href="#lsr副本集合" aria-label="Permalink to &quot;LSR副本集合&quot;">​</a></h2><p>LSR集合里面保存的副本都是<strong>与 Leader 副本保持同步的副本</strong>。</p><blockquote><p>Follower 追随者副本在同步 Leader 副本数据的时候，是异步方式同步的，这样就可能导致同步进度有差异，或者远远落后于 Leader 副本的数据。</p></blockquote><p>LSR集合里面必然会包含 Leader 副本，甚至在极端情况下，没有任何副本与 Leader 副本保持同步，这种情况下 LSR 里面只会有 Leader 副本。</p><h3 id="进入lsr副本集合的条件" tabindex="-1">进入LSR副本集合的条件 <a class="header-anchor" href="#进入lsr副本集合的条件" aria-label="Permalink to &quot;进入LSR副本集合的条件&quot;">​</a></h3><ul><li><p><strong>replica.lag.time.max.ms</strong></p><p>该参数的含义是 Follower 副本能够落后 Leader 副本的最长时间间隔，默认是 10s。</p></li></ul><p>所以只要副本与 Leader 副本的同步时间相差在 10s 以内，都认为该副本是同步的，也就可以进入 LSR副本集合里面。（即使该副本里面的数据要比 Leader 副本数据少很多）</p><p>如果 LSR副本集合里面的副本同步速度超过了该间隔，会被从 LSR副本集合里面踢出去。</p><p>LSR集合是一个动态的集合，它能够根据**<code>replica.lag.time.max.ms</code>**配置的时间间隔，来动态的调整集合里面的副本。超过就删除，未超过就将副本加入到 LSR集合。</p><ul><li>ISR（<strong>InSyncRepli）</strong> : 速率和leader相差低于10秒的follower的集合</li><li>OSR <strong>(OutSyncRepli)</strong> : 速率和leader相差大于10秒的follower</li><li>AR <strong>(AllRepli)</strong>: 全部分区的follower</li></ul><h3 id="故障转移" tabindex="-1">故障转移 <a class="header-anchor" href="#故障转移" aria-label="Permalink to &quot;故障转移&quot;">​</a></h3><p>当 Leader 副本挂掉之后，或者 Leader 副本所在 Broker 宕机之后。就会触发新的 Leader 的选举。</p><p>Kafka 依赖于 zk 的 watch 机制和临时节点功能，能够实时感知到挂掉的 Broker 和 Leader 副本，从而触发副本选举。</p><h3 id="partition副本选举leader机制" tabindex="-1">Partition副本选举Leader机制 <a class="header-anchor" href="#partition副本选举leader机制" aria-label="Permalink to &quot;Partition副本选举Leader机制&quot;">​</a></h3><p>选举受到<code>unclean.leader.election.enable</code>参数的影响。</p><ol><li>Controller 感知到 Leader 所在副本的 Broker 挂掉。</li><li><code>unclean.leader.election.enable=false</code>，Controller 从 LSR列表中获取第一个 Broker 作为对应分区的Leader。 <ul><li>当 LSR 集合为空的情况下，选不出来 Leader，就会导致该分区对外停止服务。</li><li>能避免数据丢失（HW 高水位保证Consumer 能消费的数据是 LSR 里面最低的数据水位），维护数据的一致性。但是牺牲了高可用。</li></ul></li><li><code>unclean.leader.election.enable=true</code>，Controller 从 LSR列表中获取第一个 Broker 作为对应分区的Leader。如果 LSR集合为空，则允许在其它副本选Leader。 <ul><li>缺点是可能导致数据的丢失。</li><li>优点是能保证 Leader 副本一直存在，不至于对外停止服务，提高了高可用性。</li></ul></li></ol>',27)]))}const k=a(t,[["render",i]]);export{h as __pageData,k as default};
