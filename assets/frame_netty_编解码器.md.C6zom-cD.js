import{_ as e,c as s,o as i,aN as n}from"./chunks/framework.A-MC8nKA.js";const k=JSON.parse('{"title":"编解码器","description":"","frontmatter":{},"headers":[],"relativePath":"frame/netty/编解码器.md","filePath":"frame/netty/编解码器.md","lastUpdated":1752827238000}'),l={name:"frame/netty/编解码器.md"};function t(r,a,p,h,o,d){return i(),s("div",null,a[0]||(a[0]=[n(`<h1 id="编解码器" tabindex="-1">编解码器 <a class="header-anchor" href="#编解码器" aria-label="Permalink to &quot;编解码器&quot;">​</a></h1><p>在网络传输中，数据是通过字节流传输。</p><p>对应到客户端和服务端需要进行对应的编码和解码。</p><h2 id="解码器" tabindex="-1">解码器 <a class="header-anchor" href="#解码器" aria-label="Permalink to &quot;解码器&quot;">​</a></h2><ul><li>将字节解码为消息：ByteToMessageDecoder</li><li>将一种消息类型解码为另一种：MessageToMessageDecoder。</li></ul><blockquote><p>解码器是负责将入站数据从一种格式转换到另一种格式的，所以 Netty 的解码器实现了 ChannelInboundHandler。</p></blockquote><h3 id="异常处理" tabindex="-1">异常处理 <a class="header-anchor" href="#异常处理" aria-label="Permalink to &quot;异常处理&quot;">​</a></h3><ul><li><p>TooLongFrameException</p><p>由于 Netty 是一个异步框架，所以需要在字节可以解码之前在内存中缓冲它们。因此，不能让解码器缓冲大量的数据以至于耗尽可用的内存。为了解除这个常见的顾虑，Netty 提供了 TooLongFrameException 类，其将由解码器在帧超出指定的大小限制时抛出。</p></li></ul><h2 id="编码器" tabindex="-1">编码器 <a class="header-anchor" href="#编码器" aria-label="Permalink to &quot;编码器&quot;">​</a></h2><ul><li>将消息编码为字节；MessageToByteEncoder</li><li>将消息编码为消息：MessageToMessageEncoder，T 代表源数据的类型</li></ul><h2 id="编码解码器" tabindex="-1">编码解码器 <a class="header-anchor" href="#编码解码器" aria-label="Permalink to &quot;编码解码器&quot;">​</a></h2><p>同时实现 ChannelInboundHandler 和 ChannelOutboundHandler 接口。在一个类里面写编码和解码的逻辑。</p><ul><li>抽象类 ByteToMessageCodec</li><li>抽象类 MessageToMessageCodec</li></ul><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ChannelDuplexHandler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ChannelInboundHandlerAdapter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ChannelOutboundHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ChannelDuplexHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div>`,14)]))}const u=e(l,[["render",t]]);export{k as __pageData,u as default};
