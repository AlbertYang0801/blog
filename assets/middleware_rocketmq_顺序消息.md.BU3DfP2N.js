import{_ as a,c as r,o,aN as t}from"./chunks/framework.A-MC8nKA.js";const h=JSON.parse('{"title":"顺序消息","description":"","frontmatter":{},"headers":[],"relativePath":"middleware/rocketmq/顺序消息.md","filePath":"middleware/rocketmq/顺序消息.md","lastUpdated":1752827238000}'),n={name:"middleware/rocketmq/顺序消息.md"};function l(i,e,p,s,c,d){return o(),r("div",null,e[0]||(e[0]=[t('<h1 id="顺序消息" tabindex="-1">顺序消息 <a class="header-anchor" href="#顺序消息" aria-label="Permalink to &quot;顺序消息&quot;">​</a></h1><h2 id="生产者" tabindex="-1">生产者 <a class="header-anchor" href="#生产者" aria-label="Permalink to &quot;生产者&quot;">​</a></h2><p>生产者发送消息到MQ的过程，如果要保证顺序消费。</p><p>只能采用单线程去生产消息，因为多线程无法控制消息生产顺序。</p><p>还需要保证 sharding key 相同，保证同一类消息发到同一个 ConsumerQueue。</p><blockquote><p>比如同一笔订单可以按照 <code>OrderId % queues.size()</code> 得到 sharding key。</p></blockquote><ul><li>单线程生产消息</li><li>发送到同一个ConsumerQueue</li></ul><h2 id="存储" tabindex="-1">存储 <a class="header-anchor" href="#存储" aria-label="Permalink to &quot;存储&quot;">​</a></h2><p>RocketMQ的存储是按照时间顺序 append write 到 commitlog 中的，同时它会被分发到 ConsumeQueue中。</p><p>所以只需要生产时候保证消息采用单线程发送到同一个ConsumerQueue，存储时候就能够顺序存储。</p><h2 id="消费者" tabindex="-1">消费者 <a class="header-anchor" href="#消费者" aria-label="Permalink to &quot;消费者&quot;">​</a></h2><p>RocketMQ的消费者在消费单个ConsumerQueue时，采用的是顺序消费。</p><p>而且在同一个ConsumerGroup 中只有一个 Consumer 能同时消费一个 ConsumerQueue。（第一把分布式锁）</p><p>消费者并发消费数据情况，为了保证消息有序性。保证一个线程去消费数据。（第二把本地锁）</p><blockquote><p>线程池消费数据，增加消费能力。</p></blockquote><p><img src="https://s2.loli.net/2025/06/27/lU9WIJX5pLyZVCc.png" alt="image.png" loading="lazy"></p><h2 id="顺序消费的三把锁" tabindex="-1">顺序消费的三把锁 <a class="header-anchor" href="#顺序消费的三把锁" aria-label="Permalink to &quot;顺序消费的三把锁&quot;">​</a></h2><h3 id="第一把锁-分布式锁" tabindex="-1">第一把锁：分布式锁 <a class="header-anchor" href="#第一把锁-分布式锁" aria-label="Permalink to &quot;第一把锁：分布式锁&quot;">​</a></h3><p>RocketMQ 提供了一个 ConsumeMessageOrderlyService 类来保证顺序消费。</p><p>这个 service 启动的时候会向 Broker 申请当前消费者负责的队列锁。</p><p>将 <strong>消费组+消费者+负责的队列</strong> 发往 Broker。Broker存储分布式锁，保证同一个消费者组只有一个消费者能消费某个队列。</p><p><img src="https://s2.loli.net/2025/06/27/wGDtShr4lF31k27.png" alt="image.png" loading="lazy"></p><ul><li>锁续期</li><li>消费者组纬度保存锁</li></ul><h3 id="第二把锁-本地锁synchronized" tabindex="-1">第二把锁：本地锁<strong>Synchronized</strong> <a class="header-anchor" href="#第二把锁-本地锁synchronized" aria-label="Permalink to &quot;第二把锁：本地锁**Synchronized**&quot;">​</a></h3><p>在消费者消费的时候，并发消费的情况下。</p><p>消费者获取消息后，提交到线程池的情况。可能存在多个线程分别处理消费到的消息，可能会破坏顺序性。</p><p>所以需要一把本地锁，保证同时只有一个线程处理消息。</p><h3 id="第三把锁-reentrantlock" tabindex="-1">第三把锁：<strong>ReentrantLock</strong> <a class="header-anchor" href="#第三把锁-reentrantlock" aria-label="Permalink to &quot;第三把锁：**ReentrantLock**&quot;">​</a></h3><p>消费者的某个线程获取到 Synchronized 锁之后，还需要到 ProcessQueue 获取到 ConsumerLock锁。</p><p>获取到该锁之后，标识消费者开始消费数据了。</p><p>在重平衡阶段，该锁能锁住某个队列不被重平衡，避免重复消息。</p><p>当消费者尝试获取某个ConsumerQueue的锁时。</p><ul><li>如果获取成功，表示当前队列没有被消费者消费，可以去 Broker 解除分布式锁，让新的消费者接管。</li><li>如果获取失败，表示当前队列正在被消费者消费消息，当前队列重平衡失败，等待下次重平衡。</li></ul><hr><h3 id="rocketmq的重平衡问题" tabindex="-1">RocketMQ的重平衡问题 <a class="header-anchor" href="#rocketmq的重平衡问题" aria-label="Permalink to &quot;RocketMQ的重平衡问题&quot;">​</a></h3><p>在消费者挂掉之后，会触发重平衡机制。让其他消费者顶替挂掉的消费者。</p><p>如果挂掉的消费者消息没有消费完，还未提交 offset，就会导致新来的消费者重复消费。</p><h2 id="顺序消费的问题" tabindex="-1">顺序消费的问题 <a class="header-anchor" href="#顺序消费的问题" aria-label="Permalink to &quot;顺序消费的问题&quot;">​</a></h2><p>三把锁并不能完全保证顺序性和不重复。</p><p>比如 Broker 挂了，那么 Broker 对应的队列就全部不可用了。此时其它 Broker 会顶替挂掉的Broker，队列中相关的消息只能被发送到别的队列里，就会被别的消费者消费。这个时候就破坏了单个消费者消费的有序性。</p><p>如果想要保证严格的顺序性，可以在创建Topic时候配置 <code>-order = true</code>。这样消息就不会发给别的队列。</p><p>牺牲可用性保证顺序性。</p>',42)]))}const m=a(n,[["render",l]]);export{h as __pageData,m as default};
