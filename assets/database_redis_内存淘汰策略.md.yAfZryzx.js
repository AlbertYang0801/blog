import{_ as e,c as i,o as a,ag as t}from"./chunks/framework.D7pKEi_Q.js";const m=JSON.parse('{"title":"内存淘汰策略","description":"","frontmatter":{},"headers":[],"relativePath":"database/redis/内存淘汰策略.md","filePath":"database/redis/内存淘汰策略.md"}'),o={name:"database/redis/内存淘汰策略.md"};function s(r,l,n,p,d,c){return a(),i("div",null,l[0]||(l[0]=[t(`<h1 id="内存淘汰策略" tabindex="-1">内存淘汰策略 <a class="header-anchor" href="#内存淘汰策略" aria-label="Permalink to &quot;内存淘汰策略&quot;">​</a></h1><h2 id="最大内存设置" tabindex="-1">最大内存设置 <a class="header-anchor" href="#最大内存设置" aria-label="Permalink to &quot;最大内存设置&quot;">​</a></h2><ol><li><p>redis 默认内存是多少？</p><p>在 64 位操作系统不限制内存大小，在 32 位操作系统下最多使用 3GB。</p></li><li><p>查看 redis 最大内存？</p><p><code>Plain Text config get maxmemory</code></p><p><img src="https://s2.loli.net/2025/06/18/hRDCm7rN8kwzoLU.png" alt=""></p></li><li><p>修改 redis 内存大小？</p><ul><li><p>修改配置文件</p><p>在 <code>redis.conf</code> 第 859 行可以设置最大内存大小（单位是字节）。</p><blockquote><p>: set nu 可以显示文件行号</p></blockquote><p><img src="https://s2.loli.net/2025/06/18/TFejNyVC4DQ1JrM.png" alt=""></p></li><li><p>使用命令配置</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>config set maxmemory 100</span></span></code></pre></div><p><img src="https://s2.loli.net/2025/06/18/f9LwzYK2SFTsgP7.png" alt=""></p></li></ul></li><li><p>redis 内存满了之后会怎样?</p><p>采用内存淘汰策略，默认是 <code>no-enviction</code>，会抛出 OOM 异常。</p><p><img src="https://s2.loli.net/2025/06/18/qThrsEeQFCvAKpH.png" alt=""></p></li><li><p>查看内存信息</p><p><code>Plain Text info memory</code></p><p><img src="https://s2.loli.net/2025/06/18/6IlXH17JvDcyC5e.png" alt=""></p></li><li><p>生产上一般怎么设置内存？</p><p>推荐设置内存为<strong>最大物理内存的四分之三</strong>。</p></li></ol><hr><h2 id="redis内存淘汰策略" tabindex="-1">redis内存淘汰策略 <a class="header-anchor" href="#redis内存淘汰策略" aria-label="Permalink to &quot;redis内存淘汰策略&quot;">​</a></h2><h3 id="八种内存淘汰策略" tabindex="-1">八种内存淘汰策略 <a class="header-anchor" href="#八种内存淘汰策略" aria-label="Permalink to &quot;八种内存淘汰策略&quot;">​</a></h3><p>在 redis.conf 文件中有体现。</p><p><img src="https://s2.loli.net/2025/06/18/zUEcpjbNdkXYx6B.png" alt=""></p><ul><li>2个范围 <ul><li>所有 key。</li><li>设置了过期时间的 key。</li></ul></li><li>4个方式 <ul><li>LRU 算法。</li><li>LFU 算法。</li><li>random - 随机删除。</li><li>ttl - 删除马上要过期的。</li></ul></li></ul><hr><ol><li>volatile-lru：对所有设置了过期时间的 key 使用 LRU 算法进行删除。</li><li>allkeys-lru：对所有 key 使用 LRU 算法进行删除。</li><li>volatile-lfu：对所有设置了过期时间的 key 使用 LFU 算法进行删除。</li><li>allkeys-lfu：对所有 key 使用 LFU 算法进行删除。</li><li>volatile-random ：对所有设置了过期时间的 key 随机删除。</li><li>allkeys-random ：对所有 key 随机删除。</li><li>volatile-ttl：删除马上要过期的 key。</li><li>noeviction：<strong>默认的内存淘汰策略</strong>，禁止删除数据，能保证数据不丢失。当内存满了的时候，再写入数据会返回错误。</li></ol><ul><li>LRU 算法：最近最久未使用。</li><li>LFU 算法：最近使用次数最少。</li></ul><h3 id="设置内存淘汰策略" tabindex="-1">设置内存淘汰策略 <a class="header-anchor" href="#设置内存淘汰策略" aria-label="Permalink to &quot;设置内存淘汰策略&quot;">​</a></h3><ol><li>配置文件设置</li></ol><p><img src="https://s2.loli.net/2025/06/18/cAX4aRjEVk9JfxT.png" alt=""></p><p>在 redis.conf 配置文件中 <code>maxmemory-policy</code> 对应设置内存淘汰策略，注释提示了默认淘汰策略是 <code>noeviction</code>。通过修改该配置就可以修改内存淘汰策略。</p><ol><li><p>命令行设置</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 获取maxmemory-policy配置127.0.0.1:6379&gt; config get maxmemory-policy</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 设置maxmemory-policy配置为allkeys-lru127.0.0.1:6379&gt; config set maxmemory-policy allkeys-lru</span></span></code></pre></div></li></ol><h3 id="如何选择内存淘汰策略" tabindex="-1">如何选择内存淘汰策略 <a class="header-anchor" href="#如何选择内存淘汰策略" aria-label="Permalink to &quot;如何选择内存淘汰策略&quot;">​</a></h3><ul><li>若所有数据访问频率一样，可以使用 <code>allkeys-random</code>。</li><li>若有一部分是热点数据，有一部分是冷门数据，可以考虑使用 <code>allkeys-lru</code>。</li><li>若希望有一部分数据被长期保存，而有些可以被删除。可以选择 <code>volatile-lru</code>或 <code>volatile-random</code>。</li><li>若希望避免设置 key 的失效时间来减少内存的使用。可以使用 <code>allkeys-lru</code> 搭配 key 不设置过期时间来高效利用内存。</li></ul><h2 id="参考链接" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接" aria-label="Permalink to &quot;参考链接&quot;">​</a></h2><ul><li><a href="https://blog.csdn.net/oneby1314/article/details/113789412" target="_blank" rel="noreferrer">https://blog.csdn.net/oneby1314/article/details/113789412</a></li><li><a href="https://www.bilibili.com/video/BV1Hy4y1B78T?p=68" target="_blank" rel="noreferrer">尚硅谷2021逆袭版Java面试题第三季（java大厂面试题，周阳主讲）- 手写 LRU算法</a></li></ul>`,21)]))}const u=e(o,[["render",s]]);export{m as __pageData,u as default};
