import{_ as a,c as o,o as i,aM as l}from"./chunks/framework.Du1sph90.js";const g=JSON.parse('{"title":"MySQL日志系统","description":"","frontmatter":{},"headers":[],"relativePath":"database/mysql/MySQL日志系统.md","filePath":"database/mysql/MySQL日志系统.md","lastUpdated":1752827238000}'),s={name:"database/mysql/MySQL日志系统.md"};function d(n,e,r,t,p,c){return i(),o("div",null,e[0]||(e[0]=[l(`<h1 id="mysql日志系统" tabindex="-1">MySQL日志系统 <a class="header-anchor" href="#mysql日志系统" aria-label="Permalink to &quot;MySQL日志系统&quot;">​</a></h1><h2 id="undo-log" tabindex="-1">undo.log <a class="header-anchor" href="#undo-log" aria-label="Permalink to &quot;undo.log&quot;">​</a></h2><p><strong>记录被更新前的数据。</strong></p><p><img src="https://s2.loli.net/2025/06/13/2qrd8h7f6nCpPUs.png" alt="" loading="lazy"></p><p>InnoDB 支持事务，在事务执行失败回滚时，数据会回到操作前的样子。</p><p><code>undo.log</code> 就是为了事务回滚，恢复数据的。</p><p>回滚对应的操作如下：</p><ol><li><p>insert</p><p>插入一条记录时，将这条记录的主键记录下来，回滚时根据主键删除。</p></li><li><p>update</p><p>更新一条记录时，将更新的列的旧值记录下来，回滚时将这些值更新回去。</p></li><li><p>delete</p><p>删除一条记录时，将这条记录记录下来，回滚时重新插入到表中。</p></li></ol><hr><p>在 MySQL 崩溃时，未提交的事务会影响到数据的准确性。此时就需要 <code>undo.log</code> 去回滚未提交的事务。</p><h2 id="redo-log" tabindex="-1">redo.log <a class="header-anchor" href="#redo-log" aria-label="Permalink to &quot;redo.log&quot;">​</a></h2><p>记录被修改后的数据。</p><p>当数据从磁盘中获取到，存到 <code>Buffer Pool</code> 后，同时将操作前的数据存到 <code>undo.log</code> 中。</p><p>对数据的操作都是在内存中，若发生了断电宕机，内存中的数据会丢失。</p><p>此时就引入了 <code>redo.log</code>，来解决<strong>断电宕机</strong>的问题。</p><p><code>redo.log</code> 是 InnoDB引擎独有的，是存储引擎级别，不是 MySQL 级别的。</p><h3 id="作用" tabindex="-1">作用 <a class="header-anchor" href="#作用" aria-label="Permalink to &quot;作用&quot;">​</a></h3><p><img src="https://s2.loli.net/2025/06/13/CghsYDIOGZcb5dQ.png" alt="" loading="lazy"></p><p><code>redo.log</code> 记录的是修改后的数据。<em>记录的是物理层面，“对什么数据，做了什么改动”。</em></p><h3 id="宕机恢复" tabindex="-1">宕机恢复 <a class="header-anchor" href="#宕机恢复" aria-label="Permalink to &quot;宕机恢复&quot;">​</a></h3><p>在 MySQL 重启后，存储引擎会将 <code>redo.log</code> 中的数据恢复到 <code>Buffer Pool</code> 中。</p><p>InnoDB 可以保证即使数据库发生异常重启，之前提交的记录都不会丢失。</p><h3 id="redo-log-buffer" tabindex="-1">redo log buffer <a class="header-anchor" href="#redo-log-buffer" aria-label="Permalink to &quot;redo log buffer&quot;">​</a></h3><p>由于 <code>redo.log</code> 也是磁盘上的文件，所以引入了 <code>redo log buffer</code> 来减少磁盘 I/O 读写。</p><hr><p>更新后的记录会先写到 <code>redo log buffer</code> 里，再根据刷盘策略刷到 <code>redo.log</code> 中。</p><h3 id="刷盘策略" tabindex="-1">刷盘策略 <a class="header-anchor" href="#刷盘策略" aria-label="Permalink to &quot;刷盘策略&quot;">​</a></h3><p><code>redo log buffer</code> 中的数据写入到 <code>redo.log</code>。</p><p>日志文件中刷盘策略可以通过 <code>innodb_flush_log_at_trx_commit</code> 参数来设置 :</p><ul><li>0：表示不刷入磁盘</li><li>1：表示立即刷入磁盘</li><li>2：表示先刷到 os cache</li></ul><hr><h3 id="极端问题" tabindex="-1">极端问题 <a class="header-anchor" href="#极端问题" aria-label="Permalink to &quot;极端问题&quot;">​</a></h3><p>假如在 <code>redo log buffer</code> 中的数据写入 <code>redo.log</code> 之前发生宕机情况，内存中的数据是否丢失？</p><p>此时内存中的数据会丢失，按照事务未成功处理，会根据 <code>undo.log</code> 中的数据回滚到之前的数据。</p><h3 id="文件限制" tabindex="-1">文件限制 <a class="header-anchor" href="#文件限制" aria-label="Permalink to &quot;文件限制&quot;">​</a></h3><p>InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，总共可以记录 4GB的数据。</p><p>从头开始写，写到末尾就又回到开头循环写。</p><p><img src="https://s2.loli.net/2025/06/13/rWQfm53kHSRBxNG.png" alt="" loading="lazy"></p><p><code>write pos</code> 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。</p><p><code>check point</code> 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。</p><p><code>write pos</code> 和 <code>checkpoint</code> 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 <code>write pos</code> 追上 <code>check point</code>，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 <code>check point</code> 推进一下。</p><p><img src="https://s2.loli.net/2025/06/13/I34yqBgObKNcxo2.png" alt="" loading="lazy"></p><h3 id="修改文件大小" tabindex="-1">修改文件大小 <a class="header-anchor" href="#修改文件大小" aria-label="Permalink to &quot;修改文件大小&quot;">​</a></h3><p>配置文件中修改<code>innodb_log_file_size</code>参数大小来调整 redo log 的日志大小。单个 redo log 日志文件大小为 48MB。</p><blockquote><p>innodb_log_file_size 参数的默认值为 48MB</p></blockquote><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">mysql</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SHOW GLOBAL VARIABLES LIKE </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;innodb_log_file_size&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+----------------------+----------+|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Variable_name        </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Value    </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|+----------------------+----------+|</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> innodb_log_file_size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 50331648</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |+----------------------+----------+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> row in </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.13</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sec)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在 mysql 配置文件 my.cnf 中新增如下配置：</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[mysqld]...innodb_log_file_size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">2G</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">...</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="bin-log" tabindex="-1">bin.log <a class="header-anchor" href="#bin-log" aria-label="Permalink to &quot;bin.log&quot;">​</a></h2><p><strong>记录整个操作记录。</strong></p><p><code>redo log</code>是 InnoDB 存储引擎特有的日志文件，在 InnoDB引擎中操作。而<code>bin log</code>属于是 MySQL 级别的日志，在<strong>执行器</strong>中操作。</p><p><code>redo log</code>记录的东西是偏向于物理性质的，如：“对什么数据，做了什么修改”。</p><p><code>bin log</code>是偏向于逻辑性质的，类似于：“对 students 表中的 id 为 1 的记录做了更新操作”。</p><hr><h3 id="写入文件" tabindex="-1">写入文件 <a class="header-anchor" href="#写入文件" aria-label="Permalink to &quot;写入文件&quot;">​</a></h3><p>在提交事务阶段，执行器会将操作后的数据写入内存，然后刷到磁盘上的 <code>bin.log</code> 日志文件中。</p><h3 id="文件限制-1" tabindex="-1">文件限制 <a class="header-anchor" href="#文件限制-1" aria-label="Permalink to &quot;文件限制&quot;">​</a></h3><p><code>bin.log</code> 日志文件是追加使用的，限制日志文件的大小，写满之后会顺序向后写。由 <code>binlog.index</code> 管理文件名。</p><p><img src="https://s2.loli.net/2025/06/13/KWQx7lPEINM28hr.png" alt="" loading="lazy"></p><p>而 <code>bin.log</code> 文件的默认过期时间是 30天，在过期之后会将文件删除。</p><h3 id="刷盘策略-1" tabindex="-1">刷盘策略 <a class="header-anchor" href="#刷盘策略-1" aria-label="Permalink to &quot;刷盘策略&quot;">​</a></h3><p><code>bin.log</code> 的刷盘策略可以根据 <code>sync_bin log</code> 参数来修改。</p><ul><li><p>默认为0，表示先写入 os cache。</p><p>也就是说在提交事务的时候，数据不会直接到磁盘中，这样如果宕机<code>bin log</code>数据仍然会丢失。</p></li><li><p>1：表示<strong>直接将数据写入到磁盘</strong>文件中。</p></li></ul><p><img src="https://s2.loli.net/2025/06/13/jsGzBW5hlZyrfPU.png" alt="" loading="lazy"></p><h3 id="使用场景" tabindex="-1">使用场景 <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景&quot;">​</a></h3><p><code>bin.log</code> 适用于 <strong>手动数据恢复 和 主从复制</strong>。</p><h2 id="拓展" tabindex="-1">拓展 <a class="header-anchor" href="#拓展" aria-label="Permalink to &quot;拓展&quot;">​</a></h2><h3 id="crase-safe" tabindex="-1">crase-safe <a class="header-anchor" href="#crase-safe" aria-label="Permalink to &quot;crase-safe&quot;">​</a></h3><p><code>crase-safe</code> 能力指的是 MySQL 服务器宕机重启后。保证：</p><ul><li>所有已经提交的事务的数据不会丢失。</li><li>所有没有提交的事务的数据自动回滚。</li></ul><h3 id="日志的两阶段提交" tabindex="-1">日志的两阶段提交 <a class="header-anchor" href="#日志的两阶段提交" aria-label="Permalink to &quot;日志的两阶段提交&quot;">​</a></h3><p>在 MySQL 日志中，<code>redo.log</code> 和 <code>bin.log</code> 中都记录了更新的数据。</p><p>在提交更新 SQL 时，必需要保证两个日志文件的一致性。要么全都失败、要么全都成功。不然会出现数据丢失问题。</p><p><img src="https://s2.loli.net/2025/06/13/NcRsGW1hFY5oPEv.png" alt="" loading="lazy"></p><h3 id="第一阶段-prepare阶段" tabindex="-1">第一阶段 - prepare阶段 <a class="header-anchor" href="#第一阶段-prepare阶段" aria-label="Permalink to &quot;第一阶段 - prepare阶段&quot;">​</a></h3><p>在执行器调用引擎接口记录最终 SQL数据时。</p><p>引擎会将最终数据以物理逻辑（对什么数据，做了什么改动）形式存到 <code>redo log b uffer</code> 中，再根据刷盘策略 <code>fsync</code> 到磁盘日志文件 <code>redo.log</code> 中。此时将 <code>redo.log</code> 状态变为 <code>prepare</code> 。</p><p>引擎通知执行器可以提交事务。</p><h3 id="第二阶段-commit阶段" tabindex="-1">第二阶段 - commit阶段 <a class="header-anchor" href="#第二阶段-commit阶段" aria-label="Permalink to &quot;第二阶段 - commit阶段&quot;">​</a></h3><p>执行器开始提交事务。</p><p>执行器将 SQL语句的逻辑操作（SQL语句）写入到 <code>binlog cahce</code>，再根据刷盘策略 <code>fsync</code> 到磁盘日志文件 <code>bin.log</code>。</p><p>执行器再次调用引擎接口，引擎将 <code>redo.log</code> 的状态改为 <code>commit</code>。</p><hr><h3 id="事务状态" tabindex="-1">事务状态 <a class="header-anchor" href="#事务状态" aria-label="Permalink to &quot;事务状态&quot;">​</a></h3><p>只有两阶段全部提交，才会视为整个事务成功执行。</p><p>若事务在写日志时，二阶段将 <code>redo.log</code> 改为 <code>commit</code> 状态之前发生断电宕机情况，都视为事务提交失败。</p><p>在重启恢复时，会按照 <code>undo.log</code> 中记录的数据回滚事务。</p>`,87)]))}const k=a(s,[["render",d]]);export{g as __pageData,k as default};
