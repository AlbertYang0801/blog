import{_ as l,c as e,o as p,aM as t}from"./chunks/framework.Du1sph90.js";const C=JSON.parse('{"title":"分布式事务","description":"","frontmatter":{},"headers":[],"relativePath":"java/distributed/分布式事务.md","filePath":"java/distributed/分布式事务.md","lastUpdated":1752827268000}'),i={name:"java/distributed/分布式事务.md"};function r(o,a,n,s,h,c){return p(),e("div",null,a[0]||(a[0]=[t('<h1 id="分布式事务" tabindex="-1">分布式事务 <a class="header-anchor" href="#分布式事务" aria-label="Permalink to &quot;分布式事务&quot;">​</a></h1><h2 id="反向补偿" tabindex="-1">反向补偿 <a class="header-anchor" href="#反向补偿" aria-label="Permalink to &quot;反向补偿&quot;">​</a></h2><p>在分布式情况下，假如存在 A 同时调用 B、C多个微服务。假如 B 服务事务正常执行并提交，但是 C 事务提交失败，此时 B 和 C都需要回滚。</p><p>而 MySQL 的事务回滚是通过 redo log 机制来实现的，保证事务的持久化和一致性。</p><p>但是在分布式，使用了分布式事务的情况下，是通过一条更新SQL，还原原本的数据。</p><p><a href="https://mp.weixin.qq.com/s/6DOtO5OQyCL8bR03Z-3q9A" target="_blank" rel="noreferrer">一文搞明白分布式事务解决方案！真的 so easy！</a></p><p><a href="https://juejin.cn/post/7110762693732089886" target="_blank" rel="noreferrer">分布式事务，原理简单，写起来全是坑！ - 掘金</a></p><h2 id="分布式事务解决方案" tabindex="-1">分布式事务解决方案 <a class="header-anchor" href="#分布式事务解决方案" aria-label="Permalink to &quot;分布式事务解决方案&quot;">​</a></h2><h3 id="_2pc-两阶段提交" tabindex="-1">2PC - 两阶段提交 <a class="header-anchor" href="#_2pc-两阶段提交" aria-label="Permalink to &quot;2PC - 两阶段提交&quot;">​</a></h3><ol><li><p>prepare - 准备阶段</p><p>各个参与者本地事务执行完成，向事务协调者提交本地事务状态。</p></li><li><p>commit/rollback - 提交/回滚阶段</p><ul><li><p>如果所有参与者本地事务都执行完成，事务协调者则触发全体提交。</p></li><li><p>如果有一个参与者的本地事务执行失败，事务协调者则触发全体回滚。</p></li></ul></li></ol><h4 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h4><p><img src="https://s2.loli.net/2025/07/16/vspfaX2BwcF7AbT.png" alt="image.png" loading="lazy"></p><ol><li><p>同步阻塞</p><p>第一阶段之后，所有本地资源都要处于事务的锁定状态。</p></li><li><p>单点故障</p><p>事务协调者如果挂掉，整个事务无法进行。</p></li><li><p>数据不一致</p><p>如果网络故障影响到事务协调者下发命令，可能导致事务参与者的数据不一致问题。</p></li></ol><h3 id="_3pc-三阶段提交" tabindex="-1">3PC - 三阶段提交 <a class="header-anchor" href="#_3pc-三阶段提交" aria-label="Permalink to &quot;3PC - 三阶段提交&quot;">​</a></h3><p>3PC 的引入是为了解决 2PC 同步阻塞和减少数据不一致的情况。</p><p>3PC比2PC就多了一个询问阶段。</p><ol><li><p>询问准备</p></li><li><p>预提交 - prepare</p></li><li><p>提交/回滚 - commit/rollback</p></li></ol><p><img src="https://s2.loli.net/2025/07/16/72WGhZQuUCtX1vg.png" alt="image.png" loading="lazy"></p><p>加入一个询问节点，就像是在事务开始之前询问各个事务参与者的状态。保证大家都能达到起跑点，然后再开始事务的准备和提交。</p><blockquote><p>就是在2PC基础上，增加一个保证各个事务参与者准备完成的阶段。</p></blockquote><p><img src="https://s2.loli.net/2025/07/16/Qw79JbT1GeAFhqK.png" alt="image 2" loading="lazy"></p><p>不管是 2PC 还是 3PC 都是依赖于数据库的事务提交和回滚。</p><h3 id="tcc-补偿事务" tabindex="-1">TCC-补偿事务 <a class="header-anchor" href="#tcc-补偿事务" aria-label="Permalink to &quot;TCC-补偿事务&quot;">​</a></h3><p>TCC （Try-Confirm-Cancel）</p><p>TCC与2PC的思想很相似，事务处理流程也很相似，但<strong>2PC是应用于在DB层面，TCC则可以理解为在应用层面的2PC，是需要我们编写业务逻辑来实现。</strong></p><p>TCC 分为两个阶段。</p><ol><li><p>第一阶段是资源检查预留阶段即 Try。</p></li><li><p>第二阶段是 Confirm 或 Cancel，如果是提交的话就是执行真正的业务操作，如果是回滚则是执行预留资源的取消，恢复初始状态。</p></li></ol><p><img src="https://s2.loli.net/2025/07/16/3RjgDhq2HNXVkn8.png" alt="image.png" loading="lazy"></p><h4 id="tcc问题" tabindex="-1">TCC问题 <a class="header-anchor" href="#tcc问题" aria-label="Permalink to &quot;TCC问题&quot;">​</a></h4><p><img src="https://s2.loli.net/2025/07/16/sKnMqdBVptTgiO7.png" alt="image.png" loading="lazy"></p><ol><li><p>幂等实现</p><p>TCC的三个方法都会有重试机制，所以方法需要实现幂等性。</p></li><li><p>空回滚</p><p>如果try由于网络问题超时未执行，触发了Cancel方法。要确保Cancel在try未执行的情况正确执行。</p></li><li><p>防悬挂</p><p>指 Try 方法由于网络阻塞超时触发了事务管理器发出了 Cancel 命令，但是执行了 Cancel 命令之后 Try 请求到了。</p><p>本来事务都结束了，但是执行了try，后续也不会再执行。</p><p>需要我们在空回滚的情况下，记录一下已经Cancel，防止再执行try。</p></li></ol><h3 id="本地消息表-补偿事务" tabindex="-1">本地消息表+补偿事务 <a class="header-anchor" href="#本地消息表-补偿事务" aria-label="Permalink to &quot;本地消息表+补偿事务&quot;">​</a></h3><p>本地消息表的方案核心就是将分布式事务拆分为本地事务来执行。</p><p>通过本地事务来保证最终一致性。</p><p><img src="https://s2.loli.net/2025/07/16/r8NkRXyuAjhWZsE.png" alt="image.png" loading="lazy"></p><ol><li><p>事务A 写消息到本地消息表，消息状态为未完成。定时轮训消息状态，如果未成功会继续发给MQ。</p></li><li><p>通过MQ通知事务B去消费业务数据，事务B本地事务完成后，回调事务A的方法修改消息状态为已完成。</p></li></ol><h3 id="事务消息-补偿事务" tabindex="-1">事务消息+补偿事务 <a class="header-anchor" href="#事务消息-补偿事务" aria-label="Permalink to &quot;事务消息+补偿事务&quot;">​</a></h3><p>利用RocketMQ的事务消息，既保证本地事务执行成功，又能保证事务消息能够投递成功。</p><p>如果其他事务执行失败，可以通过消息触发本地事务的回滚（补偿逻辑）。</p><p><img src="https://s2.loli.net/2025/07/16/iHnpmCv5QwUrW9c.png" alt="image 6" loading="lazy"></p><h2 id="seata" tabindex="-1">Seata <a class="header-anchor" href="#seata" aria-label="Permalink to &quot;Seata&quot;">​</a></h2><p><a href="./../../frame/springcloud/Seata分布式事务.html">Seata分布式事务</a></p>',42)]))}const m=l(i,[["render",r]]);export{C as __pageData,m as default};
