import{_ as e,c as l,o as t,aN as o}from"./chunks/framework.A-MC8nKA.js";const f=JSON.parse('{"title":"Kafka高性能的原因","description":"","frontmatter":{},"headers":[],"relativePath":"middleware/kafka/Kafka高性能的原因.md","filePath":"middleware/kafka/Kafka高性能的原因.md","lastUpdated":1752827238000}'),p={name:"middleware/kafka/Kafka高性能的原因.md"};function i(r,a,n,d,s,c){return t(),l("div",null,a[0]||(a[0]=[o('<h1 id="kafka高性能的原因" tabindex="-1">Kafka高性能的原因 <a class="header-anchor" href="#kafka高性能的原因" aria-label="Permalink to &quot;Kafka高性能的原因&quot;">​</a></h1><ol><li><p>写数据是按照磁盘顺序读写。</p><p>保证顺序读写，比随机写性能要高很多。</p><p>数据保存在 log 中，并对 log 进行了分段（logSegment）技术，对 logSegment 还增加了日志索引。</p></li><li><p>数据传输的零拷贝，使的数据在内核空间中就完成了读写操作。</p><p>零拷贝原理：</p><p><img src="https://s2.loli.net/2025/06/26/Vi2nFAkDtSjKycW.png" alt="image.png" loading="lazy"></p></li><li><p>读写数据的批量处理以及压缩传输。</p><blockquote><p>Kafka 消息的压缩发生在Producer 和 Broker。Producer 会将批量发送的数据压缩，Broker 会将压缩的数据保存下来，而消费者会去解压缩。</p></blockquote></li></ol><h3 id="零拷贝" tabindex="-1">零拷贝 <a class="header-anchor" href="#零拷贝" aria-label="Permalink to &quot;零拷贝&quot;">​</a></h3><ul><li><p>传统数据文件拷贝过程</p><p>整个过程需要在内核空间和应用空间之间拷贝 2 次。</p><p><img src="https://s2.loli.net/2025/06/26/dByMz7faUmVNsJ9.png" alt="image.png" loading="lazy"></p></li><li><p>零拷贝</p><p>为什么叫做零拷贝，就是因为不需要在应用空间和内核空间拷贝。</p><ol><li>读取磁盘文件加载到内核空间里面的 <code>Read Buffer</code>之后。</li><li>直接将文件数据发给网卡接口。</li></ol><blockquote><p>整个过程不需要将数据拷贝到应用空间，也不需要将数据拷贝到 Socket Buffer。</p></blockquote><p><img src="https://s2.loli.net/2025/06/26/DYiuOVohmcT2SqC.png" alt="image.png" loading="lazy"></p></li></ul>',4)]))}const _=e(p,[["render",i]]);export{f as __pageData,_ as default};
