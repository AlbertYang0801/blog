import{_ as e,c as l,o as t,aN as i}from"./chunks/framework.A-MC8nKA.js";const k=JSON.parse('{"title":"锁","description":"","frontmatter":{},"headers":[],"relativePath":"database/mysql/锁.md","filePath":"database/mysql/锁.md","lastUpdated":1752827238000}'),o={name:"database/mysql/锁.md"};function s(n,a,p,r,h,d){return t(),l("div",null,a[0]||(a[0]=[i(`<h1 id="锁" tabindex="-1">锁 <a class="header-anchor" href="#锁" aria-label="Permalink to &quot;锁&quot;">​</a></h1><p>MySQL中加锁是为了处理并发问题，根据锁的粒度可以分为全局锁、表级锁和行锁。</p><h2 id="全局锁" tabindex="-1">全局锁 <a class="header-anchor" href="#全局锁" aria-label="Permalink to &quot;全局锁&quot;">​</a></h2><p>全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 <code>Flush tables with read lock</code> (FTWRL)。</p><p>加完之后整个数据库处于<strong>只读状态</strong>。</p><hr><h3 id="应用场景-不推荐" tabindex="-1">应用场景（不推荐） <a class="header-anchor" href="#应用场景-不推荐" aria-label="Permalink to &quot;应用场景（不推荐）&quot;">​</a></h3><p>全局锁的经典应用场景 <strong>数据库备份</strong>。</p><p>由于加全局锁，会导致整个数据库只读，所以一般不推荐使用。</p><h3 id="可重复读进行备份" tabindex="-1">可重复读进行备份 <a class="header-anchor" href="#可重复读进行备份" aria-label="Permalink to &quot;可重复读进行备份&quot;">​</a></h3><p>备份数据库一般可以利用可重复读的事务隔离级别来实现，因为可重复读情况开始事务，会生成当前数据库的视图，保证整个事务期间以视图数据为准。</p><p>官方自带的逻辑备份工具是 <code>mysqldump</code>。当 <code>mysqldump</code> 使用参数<code>–single-transaction</code>的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。</p><p>由于 MySQL 支持 <code>MVCC</code> （多版本控制协议），在开启事务的情况下，不影响其它线程对数据库进行更新等操作。</p><hr><blockquote><p>由于利用事务的隔离级别，要求 MySQL 使用的引擎要支持事务，像 MyISAM 便不支持事务，不能使用事务进行全局备份，只能利用全局锁 FTWRL 来实现。</p></blockquote><h2 id="表级锁" tabindex="-1">表级锁 <a class="header-anchor" href="#表级锁" aria-label="Permalink to &quot;表级锁&quot;">​</a></h2><p>MySQL 中表级锁有两种，一种是表锁，另一种是元数据锁（meta data lock，MDL）。</p><h3 id="表锁-不推荐" tabindex="-1">表锁（不推荐） <a class="header-anchor" href="#表锁-不推荐" aria-label="Permalink to &quot;表锁（不推荐）&quot;">​</a></h3><p>**表锁的语法是 <code>lock tables … read/write</code>。**与 FTWRL 类似，可以用 <code>unlock tables</code>主动释放锁，也可以在客户端断开的时候自动释放。需要注意，<code>lock tables</code> 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p><p>表锁的粒度比较大，一般不推荐使用。</p><p><strong>但是在没有元数据锁之前，如果要修改表结构，都需要加表锁。</strong></p><h3 id="元数据锁-mdl" tabindex="-1">元数据锁（MDL） <a class="header-anchor" href="#元数据锁-mdl" aria-label="Permalink to &quot;元数据锁（MDL）&quot;">​</a></h3><p>MySQL 5.5 版本中引入了 MDL，不需要手动加，在访问表的时候自动加上。</p><ul><li>对表数据进行增删改查的时候，加 <strong>读锁</strong>。</li><li>对表结构进行修改的时候，加 <strong>写锁</strong>。</li></ul><hr><p>MySQL 支持多个线程同时对一张表进行增删改查，所以增删改查加读锁。</p><p>但是读-写互斥、写-写互斥。表示修改表结构时，要等待读锁释放或者其它写锁释放。</p><hr><p>在事务情况下，执行SQL时申请MDL锁，但是执行完不会释放锁，而是直到事务结束才会释放锁。</p><p>使用MDL时，一定注意不要长时间阻塞增删改查，影响业务。</p><h3 id="表结构修改问题" tabindex="-1">表结构修改问题 <a class="header-anchor" href="#表结构修改问题" aria-label="Permalink to &quot;表结构修改问题&quot;">​</a></h3><p>MDL 能保证修改表结构的时候的原子性，不能多个线程同时修改表结构。</p><p>而修改表结构，类似加索引、加字段、删除字段等操作，都需要<strong>扫描全表</strong>，操作每一条记录。假如表的数据量很大的情况下，会出现性能问题。</p><p>大表的情况修改结构会长时间占用MDL写锁，影响对该表的查询。</p><hr><p>假如在查询频率高的情况，由于写锁的存在，查询的线程会一直阻塞等待，导致线程爆满。</p><h3 id="长事务阻塞问题" tabindex="-1">长事务阻塞问题 <a class="header-anchor" href="#长事务阻塞问题" aria-label="Permalink to &quot;长事务阻塞问题&quot;">​</a></h3><p>大表由于数据量的原因，去改表结构，执行时间长是必然的。只能在特定时间去修改。</p><p>而对于小表，急需修改表结构的情况。</p><p><strong>要解决两个问题：</strong></p><ol><li><p>其它线程的长事务问题。</p><p>在 MySQL 的 <code>information_schema</code> 库的 <code>innodb_trx</code> 表中，你可以查到当前执行中的事务。</p><p>如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。</p></li><li><p>自身等待时间长，阻塞其它线程。</p><ol><li><p>为执行语句增加超时时间，超时放弃获取。</p><div class="language-sql vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ALTER</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TABLE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tbl_name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">NOWAIT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> column ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">ALTER</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> TABLE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tbl_name WAIT N </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> column ...</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>重复执行语句，指到获取MDL进而执行。</p></li></ol></li></ol><h2 id="行锁" tabindex="-1">行锁 <a class="header-anchor" href="#行锁" aria-label="Permalink to &quot;行锁&quot;">​</a></h2><p>MySQL 的行锁，是引擎自己实现的。MyIASM 就不支持行锁，若想要控制并发，只能使用表锁。InnoDB是支持行锁的，这也是 MyIASM 被 InnoDB 取代的原因之一。</p><p><strong>行锁</strong>：<em>针对某一行记录加锁，保证记录的原子性</em>。</p><h3 id="两阶段锁协议" tabindex="-1">两阶段锁协议 <a class="header-anchor" href="#两阶段锁协议" aria-label="Permalink to &quot;两阶段锁协议&quot;">​</a></h3><p>在 InnoDB 事务中，行锁在需要的时候加上，但是要等事务 commit 之后才会释放。</p><p><img src="https://s2.loli.net/2025/06/16/xMVYtAFmK45d8Nf.png" alt="" loading="lazy"></p><p>事务B 在 事务A commit 之前都处于阻塞状态。事务 A 的两条 SQL执行完，事务B依旧阻塞。</p><h3 id="事务中合理安排锁顺序" tabindex="-1">事务中合理安排锁顺序 <a class="header-anchor" href="#事务中合理安排锁顺序" aria-label="Permalink to &quot;事务中合理安排锁顺序&quot;">​</a></h3><p>由于事务中的行锁只有在 commit 时才会释放。</p><p>所以尽量将会引起锁竞争的行锁，放在后面，减少锁的持有时间。</p><p><img src="https://s2.loli.net/2025/06/16/2rRnNBEjHyglLWX.png" alt="" loading="lazy"></p><p>影院增加余额比较容易影响其它顾客的交易，产生锁竞争。所以可以按照3、1、2顺序调整，减少其锁的持有时间。</p><h2 id="死锁" tabindex="-1">死锁 <a class="header-anchor" href="#死锁" aria-label="Permalink to &quot;死锁&quot;">​</a></h2><p>在并发情况下，线程之间存在互相等待资源的情况，称为死锁。</p><p><img src="https://s2.loli.net/2025/06/16/6fjF8quZJxdMc5G.png" alt="" loading="lazy"></p><p>比如行锁的情况下，事务A和事务B相互等待对方持有的锁，导致一直循环等待。出现死锁。</p><h3 id="死锁解决策略" tabindex="-1">死锁解决策略 <a class="header-anchor" href="#死锁解决策略" aria-label="Permalink to &quot;死锁解决策略&quot;">​</a></h3><ol><li><p>过期策略。</p><p>设置超时时间，超时放弃持有资源。可以设置<code>innodb_lock_wait_timeout</code>参数。</p><blockquote><p>innodb_lock_wait_timeout 默认时间是50s，意味着发生死锁时，最少要50s才能破坏死锁。</p></blockquote></li><li><p>主动破坏死锁 - <strong>死锁检测</strong>。</p><p>主动发起死锁检测，发现死锁后，主动回滚其中的一个事务，保证其它事务继续执行，规避死锁。</p><p>将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个死锁检测。</p><blockquote><p>死锁检测是很耗费CPU资源的，因为事务开启后，便要不停的检测需要的锁资源有没有被其它事务持有。最后判断是否出现死锁。</p></blockquote></li></ol><h2 id="间隙锁" tabindex="-1">间隙锁 <a class="header-anchor" href="#间隙锁" aria-label="Permalink to &quot;间隙锁&quot;">​</a></h2><p>间隙锁只有在可重复读的隔离级别下才有，是为了解决可重复读的问题。</p><h3 id="可重复读的幻读问题" tabindex="-1">可重复读的幻读问题 <a class="header-anchor" href="#可重复读的幻读问题" aria-label="Permalink to &quot;可重复读的幻读问题&quot;">​</a></h3><ol><li><strong>查询涉及范围查询</strong>：使用 BETWEEN、IN、LIMIT 和 OFFSET 等条件。</li><li><strong>在同一个事务中</strong>，两次执行相同的范围查询。</li><li><strong>在两次查询之间</strong>，有其他事务插入了新的行，这些新行满足原来的查询条件。</li><li>当前读，强制读取最新数据也会导致幻读。</li></ol><p>间隙锁<strong>只要锁住的是范围内的数据，保证该范围数据不能被其它事务修改</strong>。</p><p>当执行一个范围查询并请求锁时，InnoDB会锁定<strong>这个范围内的所有现有记录</strong>，同时还会<strong>锁定那些不存在于当前查询结果中但可能在范围内的记录</strong>。这样做可以防止其他事务在这个范围内插入新的记录，从而避免幻读的发生。</p><h3 id="临键锁" tabindex="-1">临键锁 <a class="header-anchor" href="#临键锁" aria-label="Permalink to &quot;临键锁&quot;">​</a></h3><p>间隙锁是对范围内数据进行加锁，防止间隙有数据新增或删除。</p><p>而还需要对行记录加行锁，保证行记录不被其它事务篡改。</p><p>间隙锁+行锁 = 临键锁 （Next-Key Locks），通过临键锁可以有效解决幻读的问题。</p><h2 id="问题记录" tabindex="-1">问题记录 <a class="header-anchor" href="#问题记录" aria-label="Permalink to &quot;问题记录&quot;">​</a></h2><p><img src="https://s2.loli.net/2025/06/16/sa5N3BX1dM24KyU.png" alt="" loading="lazy"></p><ol><li>直接删除 10000条，是一个长事务。</li><li>每次删除500条，分20次删除。最为推荐，减少锁竞争和事务大小。</li><li>20个线程同时删除500条数据，容易产生行锁竞争。</li></ol><p><img src="https://s2.loli.net/2025/06/16/hjB7by3XG19HdLm.png" alt="" loading="lazy"></p>`,73)]))}const u=e(o,[["render",s]]);export{k as __pageData,u as default};
