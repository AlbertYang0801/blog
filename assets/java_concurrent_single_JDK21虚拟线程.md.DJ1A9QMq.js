import{_ as a,c as i,o as n,aN as e}from"./chunks/framework.A-MC8nKA.js";const c=JSON.parse('{"title":"JDK21-虚拟线程","description":"","frontmatter":{},"headers":[],"relativePath":"java/concurrent/single/JDK21虚拟线程.md","filePath":"java/concurrent/single/JDK21虚拟线程.md","lastUpdated":1755674252000}'),l={name:"java/concurrent/single/JDK21虚拟线程.md"};function p(t,s,h,r,k,d){return n(),i("div",null,s[0]||(s[0]=[e(`<h1 id="jdk21-虚拟线程" tabindex="-1">JDK21-虚拟线程 <a class="header-anchor" href="#jdk21-虚拟线程" aria-label="Permalink to &quot;JDK21-虚拟线程&quot;">​</a></h1><h2 id="虚拟线程概念" tabindex="-1">虚拟线程概念 <a class="header-anchor" href="#虚拟线程概念" aria-label="Permalink to &quot;虚拟线程概念&quot;">​</a></h2><p>传统的线程 （Platform Thread）和 os 线程是一对一的。</p><p><img src="https://s2.loli.net/2025/08/20/GTbKNWr9i8YZzVf.png" alt="image.png" loading="lazy"></p><p>引入虚拟线程之后，大量（M）的虚拟线程在较小数量（N）的平台线程（与操作系统线程一一对应）上运行（M:N调度）。多个虚拟线程会被 JVM 调度到某一个平台线程上执行，一个平台线程同时只会执行一个虚拟线程。</p><p>虚拟线程是由 JVM 管理的，和机器线程概念无关。</p><ul><li>创建和切换成本非常低。</li></ul><p>之前的 IO 阻塞操作在 Platform Thread 上，引入虚拟线程之后，由 JVM 负责管理。JVM 负责阻塞和唤醒线程，不占用 Platform Thread 资源。</p><p>能够大大提高 IO 阻塞型任务的效率。</p><h2 id="调度原理" tabindex="-1">调度原理 <a class="header-anchor" href="#调度原理" aria-label="Permalink to &quot;调度原理&quot;">​</a></h2><p>JDK 实现了虚拟线程调度，不直接与 os 线程 交互，而是与 Platform Thread 交互。</p><p>JDK的虚拟线程调度是一个 FIFO模式的 <code>ForkJoinPool</code> 线程池，并行数量取决于平台机器的线程数量，默认是CPU可用核心数。</p><p><img src="https://s2.loli.net/2025/08/20/MV84klAoFHZm7B3.png" alt="image.png" loading="lazy"></p><p><code>ForkJoinPool</code> 线程池适合大量任务计算，和 <code>ExecutorService</code> 不同的是，<code>ForkJoinPool</code> 每个线程都有一个任务队列，当一个由线程运行的任务生成另一个任务时，该任务被添加到该线程的等待队列中，当我们运行<code>Parallel Stream</code>，一个大任务划分成两个小任务时就会发生这种情况。</p><p>为了防止<strong>线程饥饿</strong>问题，当一个线程的等待队列中没有更多的任务时，<code>ForkJoinPool</code>还实现了另一种模式，称为<strong>任务窃取</strong>， 也就是说：饥饿线程可以从另一个线程的等待队列中窃取一些任务。</p><h2 id="执行效率" tabindex="-1">执行效率 <a class="header-anchor" href="#执行效率" aria-label="Permalink to &quot;执行效率&quot;">​</a></h2><p>执行 1w 次休眠 1s 的任务，传统线程池需要 50s。</p><div class="language-jsx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(var executor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Executors.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newFixedThreadPool</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">200</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            IntStream.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                executor.submit(() -&gt; {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Duration.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ofSeconds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>虚拟线程只需要1.2s。</p><div class="language-jsx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(var executor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Executors.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">newVirtualThreadPerTaskExecutor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            IntStream.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                executor.submit(() -&gt; {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    Thread.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sleep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Duration.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ofSeconds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>当任务有大量的IO操作时，由于虚拟线程的 IO 阻塞操作不会影响操作系统线程，操作系统可以用来执行其他任务。</p><ul><li>程序并发任务数量很高。</li><li>IO密集型、工作负载不受 CPU 约束。</li></ul><aside> 💡 <p>虚拟线程可以大大提高 IO 任务的执行效率。</p></aside><h2 id="执行原理" tabindex="-1">执行原理 <a class="header-anchor" href="#执行原理" aria-label="Permalink to &quot;执行原理&quot;">​</a></h2><p>通常，当虚拟线程执行 I/O 或 JDK 中的其他阻止操作（如<code>BlockingQueue.take()</code>时，虚拟线程会从平台线程上卸载。当阻塞操作准备完成时（例如，网络 IO 已收到字节数据），调度程序将虚拟线程挂载到平台线程上以恢复执行。</p><aside> 💡 <p>JDK 中的绝大多数阻塞操作会将虚拟线程从平台线程上卸载，使平台线程能够执行其他工作任务。</p></aside><h3 id="虚拟线程固定" tabindex="-1">虚拟线程固定 <a class="header-anchor" href="#虚拟线程固定" aria-label="Permalink to &quot;虚拟线程固定&quot;">​</a></h3><p>JDK 中的少数阻塞操作不会卸载虚拟线程，因此会阻塞平台线程。因为操作系统级别（例如许多文件系统操作）或  JDK 级别（例如<code>Object.wait()</code>）的限制。这些阻塞操作阻塞平台线程时，将通过暂时增加平台线程的数量来补偿其他平台线程阻塞的损失。因此，调度器的<code>ForkJoinPool</code>中的平台线程数量可能会暂时超过 CPU 可用核心数量。调度器可用的平台线程的最大数量可以使用系统属性 <code>jdk.virtualThreadScheduler.maxPoolSize</code> 进行调整。</p><p>在以下两种情况下，虚拟线程会被固定到运行它的平台线程，在阻塞操作期间无法卸载虚拟线程：</p><ol><li>当在<code>synchronized</code>块或方法中执行代码时。</li><li>当执行<code>native</code>方法或 foreign function 时。</li></ol><p>如果虚拟线程在被固定时执行 I/O或<code>BlockingQueue.take()</code> 等阻塞操作，则负责运行它的平台线程在操作期间会被阻塞。</p><aside> 💡 <p>虚拟线程被固定不会影响程序运行的正确性，但它可能会影响系统的并发度和吞吐量。</p></aside><h3 id="sleep-原理" tabindex="-1">sleep 原理 <a class="header-anchor" href="#sleep-原理" aria-label="Permalink to &quot;sleep 原理&quot;">​</a></h3><p>sleep 方法新增了关于虚拟线程的逻辑。</p><p><img src="https://s2.loli.net/2025/08/20/mBrhYpANoOkwTPW.png" alt="image.png" loading="lazy"></p><p><img src="https://s2.loli.net/2025/08/20/4Bd2NCuc9mgYtVy.png" alt="image.png" loading="lazy"></p><p><code>Continuation.yield</code> 会将当前虚拟线程的堆栈由平台线程的堆栈转移到 Java 堆内存，然后将其他就绪虚拟线程的堆栈由 Java 堆中拷贝到当前平台线程的堆栈中继续执行。执行 IO 或<code>BlockingQueue.take()</code> 等阻塞操作时会跟 sleep 一样导致虚拟线程切换。虚拟线程的切换也是一个相对耗时的操作，但是与平台线程的上下文切换相比，还是轻量很多的。</p><h2 id="使用注意" tabindex="-1">使用注意 <a class="header-anchor" href="#使用注意" aria-label="Permalink to &quot;使用注意&quot;">​</a></h2><h3 id="不要池化虚拟线程" tabindex="-1">不要池化虚拟线程 <a class="header-anchor" href="#不要池化虚拟线程" aria-label="Permalink to &quot;不要池化虚拟线程&quot;">​</a></h3><p>因为虚拟线程非常轻量，每个虚拟线程都打算在其生命周期内只运行单个任务，所以没有池化虚拟线程的必要。</p><p>虚拟线程可以创建数百万个。</p><h3 id="threadlocal" tabindex="-1">ThreadLocal <a class="header-anchor" href="#threadlocal" aria-label="Permalink to &quot;ThreadLocal&quot;">​</a></h3><p>虚拟线程的使用和平台线程使用是一样的。</p><p>虚拟线程和平台线程是隔离的，而且虚拟线程可以创建数百万个，ThreadLocal的内存负担比较大。</p><h3 id="使用-reentranlock-替换-synchronized" tabindex="-1">使用 ReentranLock 替换 synchronized <a class="header-anchor" href="#使用-reentranlock-替换-synchronized" aria-label="Permalink to &quot;使用 ReentranLock 替换 synchronized&quot;">​</a></h3><p>synchronized 依赖于平台线程的本地锁机制实现。</p><p>所以如果虚拟线程里面有使用 synchronized 的部分，会导致被固定在平台线程上。即使阻塞不会卸载虚拟线程。</p><h2 id="迁移方案" tabindex="-1">迁移方案 <a class="header-anchor" href="#迁移方案" aria-label="Permalink to &quot;迁移方案&quot;">​</a></h2><p>使用虚拟线程替代传统线程池</p><ol><li>直接替换线程池为虚拟线程池。如果你的项目使用了 <code>CompletableFuture</code> 你也可以直接替换执行异步任务的线程池为<code>Executors.newVirtualThreadPerTaskExecutor()</code>。</li><li>取消池化机制。虚拟线程非常轻量级，无需池化。</li><li><code>synchronized</code> 改为 <code>ReentrantLock</code>，以减少虚拟线程被固定到平台线程。</li></ol><h2 id="参考链接" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接" aria-label="Permalink to &quot;参考链接&quot;">​</a></h2><p><a href="https://mp.weixin.qq.com/s/yyApBXxpXxVwttr01Hld6Q" target="_blank" rel="noreferrer">mp.weixin.qq.com</a></p>`,52)]))}const E=a(l,[["render",p]]);export{c as __pageData,E as default};
