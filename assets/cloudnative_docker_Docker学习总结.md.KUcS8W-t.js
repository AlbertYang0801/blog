import{_ as d,c as a,o as e,aM as r}from"./chunks/framework.Du1sph90.js";const p=JSON.parse('{"title":"Docker学习总结","description":"","frontmatter":{},"headers":[],"relativePath":"cloudnative/docker/Docker学习总结.md","filePath":"cloudnative/docker/Docker学习总结.md","lastUpdated":1752827268000}'),s={name:"cloudnative/docker/Docker学习总结.md"};function i(o,t,l,c,n,k){return e(),a("div",null,t[0]||(t[0]=[r(`<h1 id="docker学习总结" tabindex="-1">Docker学习总结 <a class="header-anchor" href="#docker学习总结" aria-label="Permalink to &quot;Docker学习总结&quot;">​</a></h1><h2 id="基本知识" tabindex="-1">基本知识 <a class="header-anchor" href="#基本知识" aria-label="Permalink to &quot;基本知识&quot;">​</a></h2><h3 id="_1-docker-是什么" tabindex="-1">1. Docker 是什么？ <a class="header-anchor" href="#_1-docker-是什么" aria-label="Permalink to &quot;1. Docker 是什么？&quot;">​</a></h3><p>docker 是一种容器化虚拟技术，解决了运行环境和配置问题，方便持续集成并有助于项目整体发布。</p><h3 id="_2-docker-能干嘛" tabindex="-1">2. Docker 能干嘛？ <a class="header-anchor" href="#_2-docker-能干嘛" aria-label="Permalink to &quot;2. Docker 能干嘛？&quot;">​</a></h3><p><em>一次构建、随处运行。</em></p><ul><li>更快速的应用交付和部署。</li><li>更便捷的升级和扩缩容。</li><li>更简单的系统运维。</li><li>更高效的计算源利用。</li></ul><h2 id="基本组成" tabindex="-1">基本组成 <a class="header-anchor" href="#基本组成" aria-label="Permalink to &quot;基本组成&quot;">​</a></h2><h3 id="_1-镜像" tabindex="-1">1. 镜像 <a class="header-anchor" href="#_1-镜像" aria-label="Permalink to &quot;1. 镜像&quot;">​</a></h3><blockquote><p>Docker 镜像（image）就是一个只读的模版，一个镜像可以创建很多容器。</p></blockquote><h3 id="_2-容器" tabindex="-1">2. 容器 <a class="header-anchor" href="#_2-容器" aria-label="Permalink to &quot;2. 容器&quot;">​</a></h3><blockquote><p>Docker 利用容器（Container）独立运行一个或一组应，容器是用镜像创建的运行实例。</p></blockquote><p>它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。</p><p><em>可以把容器看做是一个简易版的 Linux 环境</em>（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p><p>容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</p><h3 id="_3-仓库" tabindex="-1">3. 仓库 <a class="header-anchor" href="#_3-仓库" aria-label="Permalink to &quot;3. 仓库&quot;">​</a></h3><blockquote><p>仓库（Repository）是集中存放镜像文件的场所。</p></blockquote><p>仓库(Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</p><p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。</p><p>最大的公开仓库是 Docker Hub(<a href="https://hub.docker.com/" target="_blank" rel="noreferrer">https://hub.docker.com/)，</a>，)</p><p>存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云 等</p><h3 id="_4-基本组成总结" tabindex="-1">4. 基本组成总结 <a class="header-anchor" href="#_4-基本组成总结" aria-label="Permalink to &quot;4. 基本组成总结&quot;">​</a></h3><blockquote><p>需要正确的理解仓储/镜像/容器这几个概念:</p></blockquote><p>Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就似乎 image镜像文件。只有通过这个镜像文件才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><ul><li>image 文件生成的容器实例，本身也是一个文件，称为镜像文件。</li><li>一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器</li><li>至于仓储，就是放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中拉下来就可以了。</li></ul><h2 id="dockerfile" tabindex="-1">DockerFile <a class="header-anchor" href="#dockerfile" aria-label="Permalink to &quot;DockerFile&quot;">​</a></h2><h3 id="生成一个镜像" tabindex="-1">生成一个镜像 <a class="header-anchor" href="#生成一个镜像" aria-label="Permalink to &quot;生成一个镜像&quot;">​</a></h3><h3 id="制作-dockerfile" tabindex="-1">制作 DockerFile <a class="header-anchor" href="#制作-dockerfile" aria-label="Permalink to &quot;制作 DockerFile&quot;">​</a></h3><ol><li><p>切换到 target 目录。</p></li><li><p>制作 DockerFile，创建文件名 Dockerfile （必须为 Dockerfile）。</p><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 基础镜像 JDK</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">FROM</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> openjdk:8</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 设置时区</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RUN</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ln</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -sf</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /usr/share/zoneinfo/Asia/Shanghai</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /etc/localtime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &amp;&amp; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">echo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Asia/Shanghai&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /etc/timezone</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 拷贝jar包</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">COPY</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> delay-order-0.0.1-SNAPSHOT.jar</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /usr/local/delay-order-0.0.1-SNAPSHOT.jar</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 启动命令</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">CMD</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> java</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -jar</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /usr/local/delay-order-0.0.1-SNAPSHOT.jar</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote><p>jdk镜像先拉取到本地。</p></blockquote><div class="language-bash vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pull</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 10.10.102.213:8443/k8s-deploy/openjdk:8</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li><li><p>打包镜像</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>docker build -t delay-order .</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div></li></ol><h2 id="参考链接" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接" aria-label="Permalink to &quot;参考链接&quot;">​</a></h2><ul><li><a href="https://www.qikegu.com/docs/3033" target="_blank" rel="noreferrer">https://www.qikegu.com/docs/3033</a></li></ul><h2 id="常见问题" tabindex="-1">常见问题 <a class="header-anchor" href="#常见问题" aria-label="Permalink to &quot;常见问题&quot;">​</a></h2><h3 id="_1-docker-的工作原理" tabindex="-1">1. Docker 的工作原理 <a class="header-anchor" href="#_1-docker-的工作原理" aria-label="Permalink to &quot;1. Docker 的工作原理&quot;">​</a></h3><p>Docker是一个 Client-Server 结构的系统，Docker 的守护进程运行在主机上， 然后通过 Socket 连接从客户端访问，守护进程从客户端接受<strong>命令</strong>并管理运行在主机上的容器。</p><p><img src="https://s2.loli.net/2025/07/14/g3aIQqkb4FvBz7D.png" alt="https://cdn.jsdelivr.net/gh/AlbertYang0801/pic-bed@main/img/20210831195531.png" loading="lazy"></p><ol><li>在客户端发起的命令都是访问 Docker_Host 的守护线程 Docker daemon；</li><li>Repository 是镜像仓库，可以拉取镜像到本地。</li><li>从镜像创建的运行实例就是容器，来运行应用。</li></ol><h2 id="常用命令" tabindex="-1">常用命令 <a class="header-anchor" href="#常用命令" aria-label="Permalink to &quot;常用命令&quot;">​</a></h2><h3 id="docker启动相关" tabindex="-1">Docker启动相关 <a class="header-anchor" href="#docker启动相关" aria-label="Permalink to &quot;Docker启动相关&quot;">​</a></h3><table tabindex="0"><thead><tr><th>功能</th><th>相关命令</th><th></th></tr></thead><tbody><tr><td>启动docker</td><td>systemctl start docker</td><td></td></tr><tr><td>查看docker版本</td><td>docker -v</td><td></td></tr><tr><td>设置开机启动docker</td><td>systemctl enable docker</td><td></td></tr><tr><td>停止docker</td><td>systemctl stop docker</td><td></td></tr></tbody></table><h3 id="docker镜像操作" tabindex="-1">Docker镜像操作 <a class="header-anchor" href="#docker镜像操作" aria-label="Permalink to &quot;Docker镜像操作&quot;">​</a></h3><table tabindex="0"><thead><tr><th>功能</th><th>相关命令</th></tr></thead><tbody><tr><td>Docker命令文档</td><td>docker –help</td></tr><tr><td>查看本地镜像列表</td><td>docker images</td></tr><tr><td>列出本地所有镜像</td><td>docker images -a</td></tr><tr><td>查看本地镜像列表 - 只显示镜像ID</td><td>docker images -q</td></tr><tr><td>列出本地所有镜像的ID</td><td>docker images -qa</td></tr><tr><td>显示镜像的摘要信息</td><td>docker images -digests</td></tr><tr><td>显示完整的镜像信息(完整镜像ID)</td><td>docker images -no-trunc</td></tr><tr><td>检索镜像(从 Docker-Hub 检索)</td><td>docker search</td></tr><tr><td>拉取镜像(从配置的阿里云拉取)</td><td>docker pull 镜像名:tag(版本号.默认为latest)</td></tr><tr><td>删除本地指定镜像</td><td>docker rmi image-id</td></tr><tr><td>强制删除单个镜像</td><td>docker rmi -f image-id</td></tr><tr><td>删除多个镜像</td><td>docker rmi -f image:TAG image:TAG</td></tr><tr><td>删除全部镜像</td><td>docker rmi -f $(docker images -qa)</td></tr></tbody></table><h3 id="docker容器操作" tabindex="-1">Docker容器操作 <a class="header-anchor" href="#docker容器操作" aria-label="Permalink to &quot;Docker容器操作&quot;">​</a></h3><table tabindex="0"><thead><tr><th>功能</th><th>相关命令</th><th></th></tr></thead><tbody><tr><td>根据镜像名在后台启动容器</td><td>docker run –name mytomcat -d tomcat:latest</td><td>–name:给容器命名 -d 在后台启动</td></tr><tr><td>根据镜像id启动容器，并进入容器开启伪终端</td><td>docker run -it image-id</td><td>–i:以交互模式启动容器，-t:创建伪终端</td></tr><tr><td>启动端口映射的mysql镜像(指定密码)</td><td>docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6</td><td></td></tr><tr><td>列出docker正在运行的容器</td><td>docker ps</td><td></td></tr><tr><td>上一个运行的容器</td><td>docker ps -l</td><td></td></tr><tr><td>列出所有容器(包含运行过的)</td><td>docker ps -a</td><td></td></tr><tr><td>显示最近n(3)个创建的容器</td><td>docker ps -n 3</td><td></td></tr><tr><td>只显示容器编号(静默模式)</td><td>docker ps -q</td><td></td></tr><tr><td>不截断输出(完整容器ID，默认的输出12位左右)</td><td>docker ps –no-trunc</td><td></td></tr><tr><td>容器停止退出</td><td>exit</td><td></td></tr><tr><td>容器不停止退出</td><td>ctrl+P+Q</td><td></td></tr><tr><td>启动容器</td><td>docker start 容器ID或容器名</td><td></td></tr><tr><td>重启容器</td><td>docker restart 容器ID或容器名</td><td></td></tr><tr><td>停止容器</td><td>docker stop 容器ID或容器名</td><td></td></tr><tr><td>强制停止容器</td><td>docker kill 容器ID或容器名</td><td></td></tr><tr><td>删除已停止的容器</td><td>docker rm 容器ID</td><td></td></tr><tr><td>删除全部容器</td><td>docker rm -f $(docker ps - a -q)</td><td></td></tr><tr><td>停止容器</td><td>docker stop 容器ID或容器名</td><td></td></tr><tr><td>停止容器</td><td>docker stop 容器ID或容器名</td><td></td></tr><tr><td>停止容器</td><td>docker stop 容器ID或容器名</td><td></td></tr><tr><td>停止容器</td><td>docker stop 容器ID或容器名</td><td></td></tr><tr><td>———————————————</td><td>—————————————————-</td><td></td></tr><tr><td>启动守护式容器(后台运行，必须有一个前台进程，否则自动退出)</td><td>docker run -d 容器名</td><td></td></tr><tr><td>查看容器日志</td><td>docker logs 容器ID</td><td></td></tr><tr><td>加入时间戳</td><td>docker logs -t</td><td></td></tr><tr><td>打印最新的日志</td><td>docker logs -f</td><td></td></tr><tr><td>显示最后多少条</td><td>docker logs –tail</td><td></td></tr><tr><td>查看容器内运行的进程</td><td>docker top 容器ID</td><td></td></tr><tr><td>查看容器内部细节</td><td>docker inspect 容器ID</td><td></td></tr><tr><td>进入正在运行的终端(直接进入容器的伪终端，不会启动新的进程)</td><td>docker attach 容器ID</td><td></td></tr><tr><td>进入正在运行的终端(在容器中打开新的终端，并且可以启动新的线程)</td><td>docker exec -it 容器I</td><td>例如:mysql docker exec -it 容器ID /bin/bash</td></tr><tr><td>从容器内拷贝文件到主机上</td><td>docker cp 容器ID:容器内路径 目的主机路径</td><td></td></tr></tbody></table><h3 id="其它命令总结" tabindex="-1">其它命令总结 <a class="header-anchor" href="#其它命令总结" aria-label="Permalink to &quot;其它命令总结&quot;">​</a></h3><table tabindex="0"><thead><tr><th>功能</th><th>相关命令</th><th></th></tr></thead><tbody><tr><td>启动zookeeper命令(默认端口为2181,2888,3888,8080):</td><td>docker run –name some-zookeeper –restart always -d zookeeper</td><td>docker run –name zk01 -p 2181:2181 –restart always -d 镜像ID</td></tr><tr><td>Docker中的MySQL容器数据持久化命令</td><td>docker run -p 3306:3306 –name mysql -v /usr/local/mysql/conf:/etc/mysql/conf.d -v /usr/local/mysql/logs:/logs -v /usr/local/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql</td><td></td></tr><tr><td>进入tomcat容器内部</td><td>docker exec -it 容器ID /bin/bash</td><td></td></tr><tr><td>Docker中的Tomcat容器实现挂载本地目录</td><td>docker run -d -p 8080:8080 –name tomcat -v /usr/local/docker/docker-tomcat/tomcat-war:/usr/local/tomcat/webapps -v /usr/local/docker/docker-tomcat/tomcat-conf:/usr/local/tomcat/conf tomcat:8.5</td><td></td></tr><tr><td>Docker中的Tomcat容器启动只挂载本地war包目录</td><td>docker run -d -p 8080:8080 –name tomcat -v /usr/local/docker/docker-tomcat/tomcat-war:/usr/local/tomcat/webapps tomcat:8.5</td><td></td></tr></tbody></table>`,45)]))}const b=d(s,[["render",i]]);export{p as __pageData,b as default};
