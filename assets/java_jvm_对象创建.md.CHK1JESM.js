import{_ as e,c as t,o as r,ag as o}from"./chunks/framework.D7pKEi_Q.js";const b=JSON.parse('{"title":"对象创建","description":"","frontmatter":{},"headers":[],"relativePath":"java/jvm/对象创建.md","filePath":"java/jvm/对象创建.md"}'),i={name:"java/jvm/对象创建.md"};function l(n,a,h,s,p,d){return r(),t("div",null,a[0]||(a[0]=[o('<h1 id="对象创建" tabindex="-1">对象创建 <a class="header-anchor" href="#对象创建" aria-label="Permalink to &quot;对象创建&quot;">​</a></h1><h2 id="对象的创建流程" tabindex="-1">对象的创建流程 <a class="header-anchor" href="#对象的创建流程" aria-label="Permalink to &quot;对象的创建流程&quot;">​</a></h2><p><img src="https://s2.loli.net/2025/05/29/vo6SudDje4VEkWC.png" alt=""></p><h3 id="类加载检查" tabindex="-1">类加载检查 <a class="header-anchor" href="#类加载检查" aria-label="Permalink to &quot;类加载检查&quot;">​</a></h3><p>判断有无加载过该类，有则直接进入下一步、没有则加载类对象。</p><h3 id="分配内存" tabindex="-1">分配内存 <a class="header-anchor" href="#分配内存" aria-label="Permalink to &quot;分配内存&quot;">​</a></h3><p>虚拟机为新生对象分配内存。</p><p>对象所需内存大小在类检查阶段便可确定，为对象分配空间就是将一块确定大小内存从 Java 堆中划分出来。</p><h3 id="_1-划分内存的方法" tabindex="-1">1. 划分内存的方法 <a class="header-anchor" href="#_1-划分内存的方法" aria-label="Permalink to &quot;1. 划分内存的方法&quot;">​</a></h3><ul><li><p><strong>指针碰撞法</strong></p><p><strong>该方法是JVM中的默认方法。</strong></p><p>它主要就是假设JVM中的内存是绝对规整的，使用过的内存和未使用过的内存分别放在两边，用一个指针来给他们做区分。如果要分配内存，只需要将指针向空闲的那一端移动对象大小的位置就好了。</p></li><li><p><strong>空闲列表</strong></p><p>如果JAVA堆中的内存分配并不是规整的，那么就需要一张<strong>表来记录某些还未分配的内存大小</strong>，当需要进行内存分配的时候从表中找到足够大小的内存区域来完成分配，并更新列表上的区域。</p></li></ul><h3 id="_2-解决并发问题的方法" tabindex="-1">2. 解决并发问题的方法 <a class="header-anchor" href="#_2-解决并发问题的方法" aria-label="Permalink to &quot;2. 解决并发问题的方法&quot;">​</a></h3><ul><li><p>在并发情况下，可能出现多个对象引用同一块内存地址的问题。</p></li><li><p>CAS</p><p>虚拟机默认使用 <strong>CAS 配上重试失败</strong>的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。</p></li><li><p>本地线程分配缓冲（TLAB)</p><p>每个线程在堆上分配一块区域，将内存分配按照不同的线程进行。</p></li></ul><h3 id="初始化" tabindex="-1">初始化 <a class="header-anchor" href="#初始化" aria-label="Permalink to &quot;初始化&quot;">​</a></h3><p>分配完成之后虚拟机需要将分配完成的对象空间都初始化为零值（不包括对象头）。</p><h3 id="设置对象头" tabindex="-1">设置对象头 <a class="header-anchor" href="#设置对象头" aria-label="Permalink to &quot;设置对象头&quot;">​</a></h3><p>初始化零值之后、虚拟机要对对象做一些必要的设置，这些设置是用来帮助虚拟机管理这个对象的。</p><h3 id="执行init方法" tabindex="-1">执行init方法 <a class="header-anchor" href="#执行init方法" aria-label="Permalink to &quot;执行init方法&quot;">​</a></h3><p>对象按照程序员的意愿进行初始化，也就是给属性赋值（代码中的值）并执行构造方法。</p><h2 id="堆内存中的对象实例" tabindex="-1">堆内存中的对象实例 <a class="header-anchor" href="#堆内存中的对象实例" aria-label="Permalink to &quot;堆内存中的对象实例&quot;">​</a></h2><h3 id="对象头" tabindex="-1">对象头 <a class="header-anchor" href="#对象头" aria-label="Permalink to &quot;对象头&quot;">​</a></h3><ul><li><p>存储对象自身的运行时数据。</p><p>哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。</p><p><img src="https://tc-cdn.flowus.cn/oss/04058f37-a074-411e-80c8-25bbe139e5b8/image.png?time=1748506500&amp;token=8af73dd158bcbaeaab8fc99db6fe01c6bb66d48b096fb22fd150c069eeb05bf4&amp;role=free" alt=""></p></li><li><p>存储类型指针。</p><p>即<strong>对象指向它的类元数据的指针</strong>，虚拟机通过这个指针来<strong>确定这个对象是哪个类的实例。</strong></p></li></ul><h3 id="实例数据" tabindex="-1">实例数据 <a class="header-anchor" href="#实例数据" aria-label="Permalink to &quot;实例数据&quot;">​</a></h3><p>具体的实例对象数据。</p><h3 id="对齐填充" tabindex="-1">对齐填充 <a class="header-anchor" href="#对齐填充" aria-label="Permalink to &quot;对齐填充&quot;">​</a></h3><p>保证对象是 8 个字节的整数倍。</p><h2 id="对象指针压缩" tabindex="-1">对象指针压缩 <a class="header-anchor" href="#对象指针压缩" aria-label="Permalink to &quot;对象指针压缩&quot;">​</a></h2><h3 id="减少内存消耗" tabindex="-1"><strong>减少内存消耗</strong> <a class="header-anchor" href="#减少内存消耗" aria-label="Permalink to &quot;**减少内存消耗**&quot;">​</a></h3><p>指针压缩可以减少每一个堆对象的大小，让同样的内存大小可以放更多的对象，这样就会使得内存存储的数据更多的情况下才会触发GC。（指针压缩在JDK1.6之后是默认开启的）</p>',28)]))}const u=e(i,[["render",l]]);export{b as __pageData,u as default};
