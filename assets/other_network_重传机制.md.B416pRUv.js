import{_ as t,c as e,o as r,aN as l}from"./chunks/framework.A-MC8nKA.js";const g=JSON.parse('{"title":"重传机制","description":"","frontmatter":{},"headers":[],"relativePath":"other/network/重传机制.md","filePath":"other/network/重传机制.md","lastUpdated":1752827268000}'),o={name:"other/network/重传机制.md"};function i(n,a,s,p,h,d){return r(),e("div",null,a[0]||(a[0]=[l('<h1 id="重传机制" tabindex="-1">重传机制 <a class="header-anchor" href="#重传机制" aria-label="Permalink to &quot;重传机制&quot;">​</a></h1><h2 id="超时重传" tabindex="-1">超时重传 <a class="header-anchor" href="#超时重传" aria-label="Permalink to &quot;超时重传&quot;">​</a></h2><p>原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的 ACK 报文，那么就重新发送数据，直到发送成功为止。</p><h3 id="rtt" tabindex="-1">RTT <a class="header-anchor" href="#rtt" aria-label="Permalink to &quot;RTT&quot;">​</a></h3><p><strong>RTT（Round-Trip Time，往返时间）</strong>。数据包一次的往返时间。</p><p><img src="https://s2.loli.net/2025/07/17/kfySnEVjqzm8MKR.png" alt="image.png" loading="lazy"></p><p>SRTT：平均的RTT</p><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ul><li>当一个报文丢失时，会<strong>等待一定的超时周期</strong>，才重传分组，增加了<strong>端到端的时延</strong>。</li><li>当一个报文丢失时，在其等待超时的过程中，可能会出现这种情况：其后的报文段已经被接收端接收但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传，既浪费资源也浪费时间。</li><li>并且，对于 TCP，如果<strong>发生一次超时重传</strong>，<strong>时间间隔下次就会加倍</strong>。</li></ul><h2 id="快速重传" tabindex="-1">快速重传 <a class="header-anchor" href="#快速重传" aria-label="Permalink to &quot;快速重传&quot;">​</a></h2><p>TCP 还有另外⼀种快速重传（<strong>Fast Retransmit</strong>）机制，它不以时间为驱动，⽽是以数据驱动重传。</p><p><img src="https://s2.loli.net/2025/07/17/zr5SZwTUIaG4Lte.png" alt="image.png" loading="lazy"></p><ul><li>当seq2丢失之后，虽然接收方收到了seq3、seq4、seq5，但是接收方依然回复给发送方ACK=2。</li><li>发送方在收到三个ACK=2之后，就会触发快速重传。重传seq2。</li><li>而接收方在收到seq2之后，可以直接返回ACK=6。</li></ul><p>快速重传解决了超时等待的问题，但是引入了一个新的问题。</p><p>就是不确定seq2之后的数据是否成功了。因为返回的都是ACK2，所以在重传的时候会面临重传seq2，还是重传seq2包括之后所有的数据。</p><h3 id="sack" tabindex="-1">SACK <a class="header-anchor" href="#sack" aria-label="Permalink to &quot;SACK&quot;">​</a></h3><p>为了解决应该重传哪些包，TCP提供了带选择确认的重传，<strong>SACK</strong>。</p><p><img src="https://s2.loli.net/2025/07/17/njHPN6tflqQVyb7.png" alt="image.png" loading="lazy"></p><p>在快速重传基础上，<strong>接收方返回最近收到报文段的序列号范围</strong>。</p><p>这样发送方能够确认哪些数据包是没收到的，就清楚应该重传哪些数据包。</p><p><em>如上图中，发送⽅收到了三次同样的 ACK 确认报⽂，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进⾏重发。</em></p><h3 id="duplicate-sack" tabindex="-1">Duplicate-SACK <a class="header-anchor" href="#duplicate-sack" aria-label="Permalink to &quot;Duplicate-SACK&quot;">​</a></h3><p>假如发送方发的数据接收方收到了，但是接收方在返回ACK的时候丢了。</p><p>这个时候发送方就会发送重复数据给接收方。而接收方在收到重复数据后，会返回D-SACK标志给发送方，能够让发送方判断出来数据重复的部分。</p><p><img src="https://s2.loli.net/2025/07/17/UoGR4ALJ8OQD3Ic.png" alt="image.png" loading="lazy"></p><ul><li>ACK包丢失导致的重复发送问题。</li></ul>',26)]))}const u=t(o,[["render",i]]);export{g as __pageData,u as default};
