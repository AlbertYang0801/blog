import{_ as a,c as r,o as l,aM as t}from"./chunks/framework.Du1sph90.js";const h=JSON.parse('{"title":"如何保证消息不丢失","description":"","frontmatter":{},"headers":[],"relativePath":"middleware/rocketmq/如何保证消息不丢失.md","filePath":"middleware/rocketmq/如何保证消息不丢失.md","lastUpdated":1752827238000}'),o={name:"middleware/rocketmq/如何保证消息不丢失.md"};function i(d,e,p,c,n,m){return l(),r("div",null,e[0]||(e[0]=[t('<h1 id="如何保证消息不丢失" tabindex="-1">如何保证消息不丢失 <a class="header-anchor" href="#如何保证消息不丢失" aria-label="Permalink to &quot;如何保证消息不丢失&quot;">​</a></h1><h2 id="消息丢失场景" tabindex="-1">消息丢失场景 <a class="header-anchor" href="#消息丢失场景" aria-label="Permalink to &quot;消息丢失场景&quot;">​</a></h2><p>数据丢失在MQ中比较常见，一般丢失数据都是在跨网络的部分，比如1、2、4。</p><ul><li>生产者发数据</li><li>消费者消费数据</li><li>MQ内部主从同步</li></ul><p>而MQ写数据到磁盘过程也是有丢失数据的可能的。</p><p>一般写数据到磁盘不会直接去写，而是利用操作系统的缓存，先写数据到缓存中，等待操作系统异步刷进磁盘。</p><p>比如 Prometheus 的 WAL 机制。</p><p><img src="https://s2.loli.net/2025/06/27/TeS3nRNvd14aDky.png" alt="image.png" loading="lazy"></p><h3 id="事务消息-生产者" tabindex="-1">事务消息-生产者 <a class="header-anchor" href="#事务消息-生产者" aria-label="Permalink to &quot;事务消息-生产者&quot;">​</a></h3><p>使用事务消息能保证本地事务和写入MQ的事务一致性。</p><p>比如订单场景，只保证本地下订单和向MQ发消息的事务一致性。不会像MySQL一样保证数据库事务。</p><p>只是保证了业务的分布式一致性问题。</p><blockquote><p>事务消息能保证生产者发送数据到MQ过程不会丢数据。也就是第1个问题。</p></blockquote><h3 id="异步消费-消费者" tabindex="-1">异步消费-消费者 <a class="header-anchor" href="#异步消费-消费者" aria-label="Permalink to &quot;异步消费-消费者&quot;">​</a></h3><p>一般消费者消费完数据，会提交ACK给RocketMQ，然后RocketMQ会修改offset。</p><blockquote><p>kafka是提交offset，而且可以配置是否自动提交。</p></blockquote><p>这种同步推送ACK的机制，结合重试机制（网络故障），能够保证消费消息的过程是不会丢失的。</p><hr><p>但是异步消费的情况，在消费到数据后，把数据丢到线程池，然后直接返回ACK。</p><p>这种情况可能出现消息丢失问题。（比如消费者机器重启，消息就丢了）</p><h3 id="rocketmq同步刷盘-操作系统" tabindex="-1">RocketMQ同步刷盘-操作系统 <a class="header-anchor" href="#rocketmq同步刷盘-操作系统" aria-label="Permalink to &quot;RocketMQ同步刷盘-操作系统&quot;">​</a></h3><p>将RocketMQ刷盘方式改为同步，可以解决消息在刷盘过程丢失的问题。也就是第3个问题。</p><p>但是同步刷盘会导致写入效率变低，需要有取舍。</p><p>比如金融场景要求强一致的情况，可以采用同步刷盘，牺牲写入效率。</p><p>而其他场景强一致要求不高的情况下，可以用异步。</p><h3 id="dledger主从架构保证mq主从同步时不会丢消息" tabindex="-1">Dledger主从架构保证MQ主从同步时不会丢消息 <a class="header-anchor" href="#dledger主从架构保证mq主从同步时不会丢消息" aria-label="Permalink to &quot;Dledger主从架构保证MQ主从同步时不会丢消息&quot;">​</a></h3><p>Dledger搭建的集群中，能够实现主从切换和主从数据同步。</p><blockquote><p>普通集群不能实现主从切换，即如果Master挂了，Slave不会转换为Master，进而导致这一组Broker不可用。</p></blockquote><p>Dledger内部能保证数据在主从同步时不会丢失。</p><h3 id="nameserver挂掉消息怎么保证不丢失" tabindex="-1">NameServer挂掉消息怎么保证不丢失？ <a class="header-anchor" href="#nameserver挂掉消息怎么保证不丢失" aria-label="Permalink to &quot;NameServer挂掉消息怎么保证不丢失？&quot;">​</a></h3><p>当NameServer挂掉之后，RocketMQ没有Broker路由的功能，找不到对应的Broker，就会导致RocketMQ不可用。</p><p>这种情况就要做降级处理，如果RocketMQ不可用，在重试几次之后。要将订单信息存到其他地方，比如Redis、内存。等MQ恢复之后，再第一时间处理这些消息。</p><h2 id="dledger的主从同步" tabindex="-1">Dledger的主从同步 <a class="header-anchor" href="#dledger的主从同步" aria-label="Permalink to &quot;Dledger的主从同步&quot;">​</a></h2><p><img src="https://s2.loli.net/2025/06/27/nUBH5sVE7dj3mFI.png" alt="image.png" loading="lazy"></p><p>通过两阶段提交的方式保证文件在主从之间同步数据不会丢数据。</p><ul><li><p>uncommitted阶段</p><ul><li>数据提交给Leader Broker之后，会被标记为uncommitted状态。</li><li>然后通过 DledgerServer 将 uncommitted 消息发给 Follower Broker 的 DledgerServer。</li></ul></li><li><p>commited阶段</p><p><strong>Follower Broker 的 DledgerServer 收到 uncommitted消息之后，必须返回一个ack。</strong></p><ul><li>如果Leader Broker收到超过半数的 ack ，就会把消息标记为 committed状态。</li><li>Leader Broker上面的DledgerServer会发送一个committed消息给每个Follower，让他们把消息改为committed状态。</li></ul></li></ul><h2 id="方案总结" tabindex="-1">方案总结 <a class="header-anchor" href="#方案总结" aria-label="Permalink to &quot;方案总结&quot;">​</a></h2><ul><li>生产者使用事务消息保证。</li><li>消费者不要使用异步消息。</li><li>Broker配置同步刷盘。</li><li>Dledger主从架构保证主从同步数据不会丢。</li><li>MQ挂了之后准备降级方案。</li></ul><p>每个阶段保证不丢失数据的方案，都是牺牲了性能来做的。</p><p>在实际处理时要做适当选择。</p>',40)]))}const k=a(o,[["render",i]]);export{h as __pageData,k as default};
