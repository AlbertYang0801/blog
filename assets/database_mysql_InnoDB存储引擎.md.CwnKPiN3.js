import{_ as o,c as a,o as n,aN as t}from"./chunks/framework.A-MC8nKA.js";const f=JSON.parse('{"title":"InnoDB存储引擎","description":"","frontmatter":{},"headers":[],"relativePath":"database/mysql/InnoDB存储引擎.md","filePath":"database/mysql/InnoDB存储引擎.md","lastUpdated":1752827238000}'),d={name:"database/mysql/InnoDB存储引擎.md"};function l(r,e,i,c,s,p){return n(),a("div",null,e[0]||(e[0]=[t('<h1 id="innodb存储引擎" tabindex="-1">InnoDB存储引擎 <a class="header-anchor" href="#innodb存储引擎" aria-label="Permalink to &quot;InnoDB存储引擎&quot;">​</a></h1><h2 id="存储引擎" tabindex="-1">存储引擎 <a class="header-anchor" href="#存储引擎" aria-label="Permalink to &quot;存储引擎&quot;">​</a></h2><p>在系统执行 <code>update</code> 语句时，经过 <code>Server层</code> 的处理，最终要由执行器去调用存储引擎去执行。</p><p>而 MySQL 存储引擎有很多种，比如 <code>InnoDB</code>、<code>MyISAM</code>等。</p><p>MySQL的默认存储引擎已经变更为了 <code>InnoDB</code></p><hr><p><code>update</code> 语句操作的数据最终是要写入磁盘中的，但是如果每次都直接操作磁盘，磁盘I/O的开销是很大的。所以需要每次将操作的数据加载到内存中，减少磁盘I/O次数，再在适当时机进行刷盘操作即可。InnoDB 中使用的这块内存叫做 <code>Buffer Pool</code>。</p><h3 id="缓冲池-buffer-pool" tabindex="-1">缓冲池 - Buffer Pool <a class="header-anchor" href="#缓冲池-buffer-pool" aria-label="Permalink to &quot;缓冲池 - Buffer Pool&quot;">​</a></h3><p><img src="https://s2.loli.net/2025/06/13/yPWtvRzbVJgiaAS.png" alt="" loading="lazy"></p><p>MySQL的数据最终存在磁盘中，而缓冲池位于内存中。在第一次查询的时候数据会被加载到缓冲池中，后续请求会从缓冲池中获取。</p><p>执行器调用存储引擎的查询流程：</p><ol><li>InnoDB 会在缓冲池中查找 id=1 的数据是否存在。</li><li>不存在，会从磁盘中查找，并将其放在缓冲池中。</li><li>该条记录会被加上独占锁（保证同时只能被一个线程操作）。</li></ol>',12)]))}const h=o(d,[["render",l]]);export{f as __pageData,h as default};
