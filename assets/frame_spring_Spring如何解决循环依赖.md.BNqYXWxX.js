import{_ as i,c as a,o as n,aN as l}from"./chunks/framework.A-MC8nKA.js";const o=JSON.parse('{"title":"Spring如何解决循环依赖","description":"","frontmatter":{},"headers":[],"relativePath":"frame/spring/Spring如何解决循环依赖.md","filePath":"frame/spring/Spring如何解决循环依赖.md","lastUpdated":1752832844000}'),e={name:"frame/spring/Spring如何解决循环依赖.md"};function p(t,s,h,r,k,d){return n(),a("div",null,s[0]||(s[0]=[l(`<h1 id="spring如何解决循环依赖" tabindex="-1">Spring如何解决循环依赖 <a class="header-anchor" href="#spring如何解决循环依赖" aria-label="Permalink to &quot;Spring如何解决循环依赖&quot;">​</a></h1><h2 id="依赖注入的四种方法" tabindex="-1">依赖注入的四种方法 <a class="header-anchor" href="#依赖注入的四种方法" aria-label="Permalink to &quot;依赖注入的四种方法&quot;">​</a></h2><ul><li><p>构造方法注入</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HelloA</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Autowired</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HelloService helloService) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.helloService </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> helloService;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li><li><p>工厂方法注入</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Bean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">initMethod</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;init&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">destroyMethod</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;destory&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HelloB </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">helloB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Autowired</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HelloService helloService) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HelloB</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(helloService);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li><li><p>set方法注入</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> HelloC </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setHelloService</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(HelloService helloService) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.helloService </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> helloService;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li><li><p>字段注入</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    HelloService helloService;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ul><h3 id="循环依赖的问题" tabindex="-1">循环依赖的问题 <a class="header-anchor" href="#循环依赖的问题" aria-label="Permalink to &quot;循环依赖的问题&quot;">​</a></h3><p>其中构造方法注入和工厂方法注入是强依赖，因为Bean创建和属性注入放到一起了。</p><p>比如构造方法注入，创建对象的同时进行属性注入，这种属于强依赖。</p><p>而强依赖是解决不了循环依赖的问题的，因为创建对象和属性注入属于一体不可分的。</p><p>我们解决循环依赖是先创建对象，然后属性注入的时候利用三级缓存解决的。</p><h2 id="循环依赖分析" tabindex="-1">循环依赖分析 <a class="header-anchor" href="#循环依赖分析" aria-label="Permalink to &quot;循环依赖分析&quot;">​</a></h2><p><img src="https://s2.loli.net/2025/06/27/fOXk5z2AIjltQJn.png" alt="" loading="lazy"></p><p>在创建 Bean 的过程中，有依赖注入的过程。</p><p>这个阶段会发生循环依赖。</p><p><em>ABean创建–&gt;依赖了B属性–&gt;触发BBean创建—&gt;B依赖了A属性—&gt;需要ABean（但ABean还在创建过程中）</em></p><h2 id="依赖场景" tabindex="-1">依赖场景 <a class="header-anchor" href="#依赖场景" aria-label="Permalink to &quot;依赖场景&quot;">​</a></h2><ol><li><p>构造器注入循环依赖</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Service</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(B </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Service</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(A </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//A a = new A(new B(new A(new B(new A()))));</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><strong>构造器的循环依赖Spring是无法解决的。</strong></p><p>因为Spring解决循环依赖是在对象实例化之后，依赖注入时解决的。</p><p>构造器对应的是<strong>实例化阶段</strong>，无法解决循环依赖。</p><p>强依赖是无法解决循环依赖的问题的，因为Bean对象创建和属性注入是一个阶段。我们解决循环依赖是分为两个阶段，创建对象和属性注入，在属性注入时可以解决循环依赖。</p></li><li><p>依赖注入</p><p>利用三级缓存可以解决。</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Service</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> B b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Service</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> B</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Autowired</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> A a;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></li><li><p>Prototype类的循环依赖</p><p>无法解决，因为 Prototype作用域的类不会放到缓存中，Spring通过缓存解决循环依赖。</p></li></ol><h2 id="懒加载" tabindex="-1">懒加载 <a class="header-anchor" href="#懒加载" aria-label="Permalink to &quot;懒加载&quot;">​</a></h2><h3 id="懒加载的工作原理" tabindex="-1">懒加载的工作原理 <a class="header-anchor" href="#懒加载的工作原理" aria-label="Permalink to &quot;懒加载的工作原理&quot;">​</a></h3><p>当一个懒加载的 bean需要被初始化时，Spring会创建一个代理对象（通常是CGLIB 字节码动态代理）。</p><p>这个代理对象可以在其它类需要的时候，通过代理对象调用实际对象的方法。</p><p>而实际Bean在第一次使用的时候才会创建。</p><h3 id="使用方式" tabindex="-1">使用方式 <a class="header-anchor" href="#使用方式" aria-label="Permalink to &quot;使用方式&quot;">​</a></h3><p>@Lazy</p><h2 id="三级缓存" tabindex="-1">三级缓存 <a class="header-anchor" href="#三级缓存" aria-label="Permalink to &quot;三级缓存&quot;">​</a></h2><p>Spring引入三级缓存解决依赖注入和set方法注入可能导致的循环依赖</p><p><img src="https://s2.loli.net/2025/06/27/VicBqvWabCmZFA7.png" alt="" loading="lazy"></p><ul><li><p><code>singletonObjects</code></p><p>单例池，缓存的是已经<strong>经历了完整生命周期的Bean对象</strong>。</p><p><strong>已经实例化并且已经属性赋值。</strong></p></li><li><p><code>earlySingletonObjects</code></p><p>二级缓存，缓存的是<strong>早期的 Bean 对象</strong>，Bean的生命周期还没走完就放入了二级缓存。</p><p><strong>已经实例化但是还未属性赋值。可以存放原对象，也可能存放代理对象。</strong></p></li><li><p><code>singletonFactories</code></p><p>三级缓存，缓存的是ObjectFactory，表示对象工厂，用来创建早期 Bean对象的工厂，可以通过该工厂创建出代理对象。</p></li></ul><h3 id="为什么引入二级缓存" tabindex="-1">为什么引入二级缓存 <a class="header-anchor" href="#为什么引入二级缓存" aria-label="Permalink to &quot;为什么引入二级缓存&quot;">​</a></h3><p>在循环依赖场景 A→B→A 中，实例化之后将A对象放到二级缓存中，这样 B 需要引用 A 时，从二级缓存获取就可以了。</p><p>Bean 实例化之后，整个 Bean生命周期 <strong>Bean对象的堆内存地址都不会改变</strong>。所以 B依赖的A（缓存）和走完生命周期的 A是一个对象。</p><p><img src="https://s2.loli.net/2025/06/27/TgR5zyf8hBJqiF6.png" alt="" loading="lazy"></p><h3 id="为什么引入三级缓存" tabindex="-1">为什么引入三级缓存 <a class="header-anchor" href="#为什么引入三级缓存" aria-label="Permalink to &quot;为什么引入三级缓存&quot;">​</a></h3><p>为了解决 AOP对象引入三级缓存。</p><p>Bean创建的生命周期可以简化为 <strong>实例化 → 依赖注入 → AOP</strong>。</p><p>AOP之后 Bean 实际上生成了一个代理对象，该代理对象和二级缓存里面存放的对象不是一个对象。这样就会导致 B 依赖的是 A的原始对象，但是需要的是 A的代理对象。</p><h3 id="三级缓存的内容" tabindex="-1">三级缓存的内容 <a class="header-anchor" href="#三级缓存的内容" aria-label="Permalink to &quot;三级缓存的内容&quot;">​</a></h3><p>三级缓存，缓存的是ObjectFactory，其实就是 一个函数式接口。</p><p><code>() -&gt; getEarlyBeanReference(beanName, mbd,bean)</code></p><p>作用是能通过该函数获取一个对象的代理对象。</p><ul><li>如果对象有 AOP，返回的就是 AOP 之后的代理对象。</li><li>如果对象没有 AOP，返回原对象。</li></ul><p><img src="https://s2.loli.net/2025/06/27/hSd8qMcsLwRDTV1.png" alt="" loading="lazy"></p><p>注意：调用该函数不是在放入三级缓存的时候。</p><h3 id="三级缓存的执行流程" tabindex="-1">三级缓存的执行流程 <a class="header-anchor" href="#三级缓存的执行流程" aria-label="Permalink to &quot;三级缓存的执行流程&quot;">​</a></h3><ol><li>A 实例化。</li><li>将 A 对应的 <code>ObjectFactory</code> 放入三级缓存中。</li><li>依赖 B → 创建B → 实例化 B → 依赖 A。 <ol><li>从三级缓存获取 A 对应的 ObjectFactory。</li><li>通过 ObjectFactory 获取代理对象 A+(如果没有AOP，A+就是原对象)。</li><li>将代理对象 A+ 放到二级缓存，并且移除三级缓存中对应的 <code>ObjectFactory</code>。</li><li>B 读取二级缓存中的 A+，完成依赖注入。</li><li>清除二级缓存中的 B，然后将 B 放到一级缓存。</li></ol></li><li>B 注入完成之后，A完成依赖注入。</li><li>继续 A 的生命周期。</li><li>判断 A 是否需要 AOP。</li></ol><ul><li>如果需要 AOP，从二级缓存（earlySingletonObjects）中获取对象 A+，放入一级缓存。</li><li>如果不需要 AOP，将 A 放入一级缓存，并从二级缓存移除 A。</li></ul>`,44)]))}const g=i(e,[["render",p]]);export{o as __pageData,g as default};
