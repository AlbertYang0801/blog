import{_ as a,c as i,o as n,ae as e}from"./chunks/framework.BAYqcHKv.js";const E=JSON.parse('{"title":"写空闲和读空闲","description":"","frontmatter":{},"headers":[],"relativePath":"frame/netty/写空闲和读空闲.md","filePath":"frame/netty/写空闲和读空闲.md"}'),t={name:"frame/netty/写空闲和读空闲.md"};function l(h,s,p,r,k,d){return n(),i("div",null,s[0]||(s[0]=[e(`<h1 id="写空闲和读空闲" tabindex="-1">写空闲和读空闲 <a class="header-anchor" href="#写空闲和读空闲" aria-label="Permalink to &quot;写空闲和读空闲&quot;">​</a></h1><p>在Netty框架中，<strong>写空闲（Write Idle）</strong> 和 <strong>读空闲（Read Idle）</strong> 是空闲检测机制中的两个重要概念，它们用于监控网络连接的活跃状态，确保连接的有效性和资源的有效管理。</p><h3 id="写空闲-write-idle" tabindex="-1">写空闲（Write Idle） <a class="header-anchor" href="#写空闲-write-idle" aria-label="Permalink to &quot;写空闲（Write Idle）&quot;">​</a></h3><ul><li><strong>定义</strong>：写空闲指的是在一段指定时间内，没有数据通过当前的<code>Channel</code>被写入到网络中传输给对方。这可能意味着在这段时间内，服务端没有向客户端发送任何数据，或者客户端没有向服务端发送数据。</li><li><strong>应用场景</strong>：在某些协议或应用场景中，如果长时间没有数据写入，可能需要触发特定的操作，比如<strong>发送心跳包以维持连接活跃</strong>，或者是<strong>判断连接是否已经失效，进而关闭连接</strong>以释放资源。</li></ul><h3 id="读空闲-read-idle" tabindex="-1">读空闲（Read Idle） <a class="header-anchor" href="#读空闲-read-idle" aria-label="Permalink to &quot;读空闲（Read Idle）&quot;">​</a></h3><ul><li><strong>定义</strong>：读空闲则是指在一段指定时间内，没有从网络中读取到任何数据到当前的<code>Channel</code>中。即使连接是打开的，但如果长时间没有数据可读，也可能意味着连接另一端可能已经断开或者不再发送数据。</li><li><strong>应用场景</strong>：读空闲检测可以帮助及时发现并处理“僵尸”连接，即那些虽然建立但不再有数据交互的连接。<strong>一旦检测到读空闲，服务端可以主动断开连接，避免资源浪费</strong>。</li></ul><h3 id="实现机制" tabindex="-1">实现机制 <a class="header-anchor" href="#实现机制" aria-label="Permalink to &quot;实现机制&quot;">​</a></h3><p>Netty 提供了 <code>IdleStateHandler</code> 类来实现空闲检测机制，它作为一个 ChannelHandler 被添加到 ChannelPipeline 中。通过配置不同的超时时间（如读空闲超时、写空闲超时、全空闲超时），可以分别对读、写或两者都无活动的情况做出响应。当触发了任一种空闲状态时，<code>IdleStateHandler</code> 会向 ChannelPipeline 中的下一个 ChannelInboundHandler 触发一个 <code>IdleStateEvent</code>，对应的处理器可以通过覆盖 <code>userEventTriggered</code> 方法来捕获并处理这些事件。</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>通过区分写空闲与读空闲，Netty 允许开发者更加精细地控制和管理网络连接的状态，确保系统的稳定性和资源的有效利用。在实际应用中，根据具体需求，可以设置不同的空闲超时策略来应对不同的业务场景。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * userEventTriggered 是 Netty 中 ChannelInboundHandler 接口的一个方法，用于处理用户自定义事件</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> ctx</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@param</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> evt</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@throws</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Exception</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Override</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> userEventTriggered</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ChannelHandlerContext ctx, Object evt) throws Exception {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(evt </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> IdleStateEvent.FIRST_WRITER_IDLE_STATE_EVENT){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            MyMessage heartBeat </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> buildHeatBeat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            log.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">debug</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;写空闲，发出心跳报文维持连接： &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> heartBeat);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            ctx.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">writeAndFlush</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(heartBeat);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">userEventTriggered</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(ctx, evt);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre></div>`,11)]))}const g=a(t,[["render",l]]);export{E as __pageData,g as default};
