import{_ as a,c as i,o as n,aM as l}from"./chunks/framework.Du1sph90.js";const E=JSON.parse('{"title":"Netty实现通信框架","description":"","frontmatter":{},"headers":[],"relativePath":"frame/netty/Netty实现通信框架.md","filePath":"frame/netty/Netty实现通信框架.md","lastUpdated":1752827238000}'),e={name:"frame/netty/Netty实现通信框架.md"};function p(t,s,h,k,r,d){return n(),i("div",null,s[0]||(s[0]=[l(`<h1 id="netty实现通信框架" tabindex="-1">Netty实现通信框架 <a class="header-anchor" href="#netty实现通信框架" aria-label="Permalink to &quot;Netty实现通信框架&quot;">​</a></h1><h2 id="功能点" tabindex="-1">功能点 <a class="header-anchor" href="#功能点" aria-label="Permalink to &quot;功能点&quot;">​</a></h2><ol><li>基于Netty的NIO通信框架。</li><li>提供消息的编码解码框架，实现对象的序列化和反序列化。</li><li>消息内容的放篡改机制。</li><li>提供基于IP的白名单认证机制。</li><li>链路的有效性机制（心跳）。</li><li>链路的断连重连机制。</li></ol><h2 id="通信模型" tabindex="-1">通信模型 <a class="header-anchor" href="#通信模型" aria-label="Permalink to &quot;通信模型&quot;">​</a></h2><p><img src="https://s2.loli.net/2025/06/13/hGfgzNHy9uWjl8r.png" alt="" loading="lazy"></p><h2 id="调用链路" tabindex="-1">调用链路 <a class="header-anchor" href="#调用链路" aria-label="Permalink to &quot;调用链路&quot;">​</a></h2><p><img src="https://s2.loli.net/2025/06/13/7cRHUs9pZQayJTP.png" alt="" loading="lazy"></p><p>粘包半包是最前面先要解决的问题。</p><h3 id="写空闲检测" tabindex="-1">写空闲检测 <a class="header-anchor" href="#写空闲检测" aria-label="Permalink to &quot;写空闲检测&quot;">​</a></h3><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CheckWriteIdleHandler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> IdleStateHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * 0 表示读空闲时间不进行检测，即不对读空闲做任何处理。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * 8 表示写空闲时间设置为8秒。如果在这8秒内，没有数据被写入到Channel（即向远端发送数据），则会触发一个写空闲事件。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * 0 同样表示全空闲时间不进行检测，即不关心读和写都没有活动的时间段。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> CheckWriteIdleHandler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //IdleStateHandler触发的事件会被userEventTriggered捕获到</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="解决粘包拆包" tabindex="-1">解决粘包拆包 <a class="header-anchor" href="#解决粘包拆包" aria-label="Permalink to &quot;解决粘包拆包&quot;">​</a></h3><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //1.解决粘包半包</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //包最大长度、包长度字段偏移量、包长度字段的长度、长度的修正值、丢弃的长度数量、是否快速失败-true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        socketChannel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pipeline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addLast</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> LengthFieldBasedFrameDecoder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">65535</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">                0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">                2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //在发送消息之前向消息的开头添加长度字段，确定消息边界</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //处理器会将消息的原始内容前面附加一个2字节的长度字段，这两个字节用来表示后续消息体的长度</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        socketChannel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pipeline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addLast</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> LengthFieldPrepender</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div>`,12)]))}const g=a(e,[["render",p]]);export{E as __pageData,g as default};
