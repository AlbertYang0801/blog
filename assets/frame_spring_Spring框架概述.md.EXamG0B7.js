import{_ as a,c as s,o as e,ae as n}from"./chunks/framework.BAYqcHKv.js";const d=JSON.parse('{"title":"Spring框架概述","description":"","frontmatter":{},"headers":[],"relativePath":"frame/spring/Spring框架概述.md","filePath":"frame/spring/Spring框架概述.md"}'),l={name:"frame/spring/Spring框架概述.md"};function p(r,i,t,h,o,g){return e(),s("div",null,i[0]||(i[0]=[n(`<h1 id="spring框架概述" tabindex="-1">Spring框架概述 <a class="header-anchor" href="#spring框架概述" aria-label="Permalink to &quot;Spring框架概述&quot;">​</a></h1><h3 id="一、什么是-spring-框架" tabindex="-1">一、什么是 Spring 框架？ <a class="header-anchor" href="#一、什么是-spring-框架" aria-label="Permalink to &quot;一、什么是 Spring 框架？&quot;">​</a></h3><p>Spring 框架指的是 Spring Framework，是一种轻量级的开发框架，主要核心是控制反转 （IOC）和 面向切面编程（AOP）。</p><h3 id="二、spring-的优点" tabindex="-1">二、Spring 的优点 <a class="header-anchor" href="#二、spring-的优点" aria-label="Permalink to &quot;二、Spring 的优点&quot;">​</a></h3><ol><li>方便解耦，简化开发（高内聚低耦合） <ul><li>Spring 是一个容器框架，将所有对象创建和依赖关系的维护交给 Spring 管理。</li><li>Spring 工厂用于生成 Bean。</li></ul></li><li>AOP编程的支持 <ul><li>Spring 提供面向切面编程，可以方便的实现权限拦截、运行监控等功能</li><li>日志打印</li></ul></li><li>支持声明式事务 <ul><li>只需要通过配置就可以完成对事务的管理，而无需手动编程</li></ul></li><li>方便程序测试 <ul><li>Spring 支持 Junit4等测试框架，可以通过注解进行方便的测试。</li></ul></li><li>方便集成各种框架 <ul><li>Spring支持集成各种框架。（如：Mybatis、ActiveMQ等）</li></ul></li><li>内部封装各种API <ul><li>Spring 内部封装了很多方便实用的 API。（如：JDBC、JavaMail等）</li></ul></li></ol><h3 id="三、什么是-ioc" tabindex="-1">三、什么是 IOC ？ <a class="header-anchor" href="#三、什么是-ioc" aria-label="Permalink to &quot;三、什么是 IOC ？&quot;">​</a></h3><p>IOC（控制反转）是一种设计思想，将原本在程序中手动创建对象的控制权，交给 Spring 框架来管理。</p><p>IOC 容器是 Spring 用来实现 IOC 的载体。将对象之间的相互依赖关系交给 IOC 容器来管理，并由 IOC容器完成对象的注入。IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置对应注解即可，完全不用考虑对象是如何创建出来的，同时也保证了对象之间的松耦合。</p><p>总结来说 IOC 就是对 Bean 的注册管理，由 IOC 容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。</p><h3 id="ioc-中的设计模式" tabindex="-1">IOC 中的设计模式 <a class="header-anchor" href="#ioc-中的设计模式" aria-label="Permalink to &quot;IOC 中的设计模式&quot;">​</a></h3><ul><li><p>简单工厂模式</p><p>Spring 中的 BeanFactory 就是简单工厂的体现，根据传入的标识获取 Bean 对象。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> BeanFactory</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Object </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getBean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(String </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throws</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> BeansException;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	......</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div></li><li><p>工厂模式</p><p>Spring 中的 FactoryBean 就用到了工厂模式，对应的 <code>getObject()</code> 方法可以返回一个对应的对象。</p></li><li><p>单例模式</p><p>在Spring中，所有的 Bean 默认都是单例创建的。</p></li><li><p>策略模式</p></li><li><p>装饰器模式</p></li></ul><h3 id="四、什么是-aop" tabindex="-1">四、什么是 AOP？ <a class="header-anchor" href="#四、什么是-aop" aria-label="Permalink to &quot;四、什么是 AOP？&quot;">​</a></h3><p>AOP（面向切面编程）能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（如事务管理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。</p><h3 id="动态代理和静态代理" tabindex="-1">动态代理和静态代理 <a class="header-anchor" href="#动态代理和静态代理" aria-label="Permalink to &quot;动态代理和静态代理&quot;">​</a></h3><ul><li><p>动态代理</p><p>以 Spring AOP 为代表。指代理类在JVM运行时动态生成的。效率会低一点，但是大大提高了代码的简洁度和开发工作。</p></li><li><p>静态代理</p><p>以 AspectJ 为代表。指代理类在编译期生成的，与动态代理相比，效率会很高，但是会生成大量代理类。</p></li></ul><h3 id="springaop-和-aspectj-有什么区别" tabindex="-1">SpringAOP 和 AspectJ 有什么区别？ <a class="header-anchor" href="#springaop-和-aspectj-有什么区别" aria-label="Permalink to &quot;SpringAOP 和 AspectJ 有什么区别？&quot;">​</a></h3><ul><li>SpringAOP 属于<code>运行时增强</code>，而 AspectJ 属于<code>编译期增强</code>。</li><li>SpringAOP 基于动态代理实现，而 AspectJ 属于静态代理。</li><li>SpringAOP 已经集成了 AspectJ ，AspectJ 相比于 SpringAOP 功能更加强大，但是 SpringAOP 更简单。</li></ul><h3 id="springaop-动态代理的两种方式" tabindex="-1">SpringAOP 动态代理的两种方式？ <a class="header-anchor" href="#springaop-动态代理的两种方式" aria-label="Permalink to &quot;SpringAOP 动态代理的两种方式？&quot;">​</a></h3><ul><li>JDK 动态代理</li><li>CGlib 动态代理</li></ul><h3 id="参考链接" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接" aria-label="Permalink to &quot;参考链接&quot;">​</a></h3><p><a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93?id=_1-%e4%bb%80%e4%b9%88%e6%98%af-spring-%e6%a1%86%e6%9e%b6" target="_blank" rel="noreferrer">JavaGuide-Spring框架</a></p><p><a href="https://www.cnblogs.com/wanghuaying/p/9678349.html" target="_blank" rel="noreferrer">博客园：Spring 框架概述</a></p><p><a href="https://javadoop.com/post/spring-ioc" target="_blank" rel="noreferrer">Spring IOC 容器源码分析</a></p>`,23)]))}const k=a(l,[["render",p]]);export{d as __pageData,k as default};
