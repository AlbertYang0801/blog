import{_ as o,c as n,o as r,aM as l}from"./chunks/framework.Du1sph90.js";const h=JSON.parse('{"title":"TCP粘包拆包","description":"","frontmatter":{},"headers":[],"relativePath":"other/network/TCP粘包拆包.md","filePath":"other/network/TCP粘包拆包.md","lastUpdated":1752827268000}'),e={name:"other/network/TCP粘包拆包.md"};function i(a,t,p,s,T,g){return r(),n("div",null,t[0]||(t[0]=[l('<h1 id="tcp粘包拆包" tabindex="-1">TCP粘包拆包 <a class="header-anchor" href="#tcp粘包拆包" aria-label="Permalink to &quot;TCP粘包拆包&quot;">​</a></h1><p><img src="https://s2.loli.net/2025/07/17/6JkFCrL7g3SfMHz.png" alt="image.png" loading="lazy"></p><h2 id="发生粘包的原因" tabindex="-1">发生粘包的原因 <a class="header-anchor" href="#发生粘包的原因" aria-label="Permalink to &quot;发生粘包的原因&quot;">​</a></h2><ul><li>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包；</li><li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；</li><li>要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包；</li><li>待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。即 TCP 报文长度 - TCP 头部长度 &gt; MSS。</li></ul><h2 id="解决粘包拆包问题" tabindex="-1">解决粘包拆包问题 <a class="header-anchor" href="#解决粘包拆包问题" aria-label="Permalink to &quot;解决粘包拆包问题&quot;">​</a></h2><ul><li><strong>定长消息</strong>：发送端将每个数据包封装为固定长度</li><li><strong>特殊分隔符</strong>：在数据尾部增加特殊字符进行分割</li><li><strong>消息头</strong>：将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小</li><li>自定义协议：自定义消息格式。</li></ul><p>TCP协议是一个面向字节流的协议，并不会提供解决粘包拆包问题。</p><p>解决粘包拆包问题都是应用层去做的。</p><h3 id="http-1-1" tabindex="-1">HTTP/1.1 <a class="header-anchor" href="#http-1-1" aria-label="Permalink to &quot;HTTP/1.1&quot;">​</a></h3><p>HTTP/1.1 是基于文本的协议，并且每个请求和响应都是独立的实体。HTTP/1.1 请求和响应的格式包括以下几个部分：</p><ol><li><strong>起始行</strong>（Start Line）: 包含请求方法（对于请求）或状态码（对于响应）。</li><li><strong>头部字段</strong>（Header Fields）: 包括各种元数据，如 Content-Type 和 Content-Length。</li><li><strong>空行</strong>（CRLF）: <code>\\r\\n\\r\\n</code>，用于分隔头部和主体。</li><li><strong>主体</strong>（Body）: 可能携带的数据负载。</li></ol><p>HTTP/1.1 中的粘包和拆包问题主要是通过以下方式解决的：</p><ul><li><p><strong>Content-Length</strong>:</p><p>通过 <code>Content-Length</code> 头部字段来指定消息体的长度，接收端可以据此确定消息的结束位置。</p></li><li><p><strong>Transfer-Encoding: chunked</strong>:</p><p>当消息体的长度未知或较大时，可以使用 <code>Transfer-Encoding: chunked</code> 来指示消息体是以一系列长度已知的块来发送的，每个块都有自己的长度指示器和结束标记。</p></li><li><p><strong>起始行和头部的结束</strong>:</p><p>起始行和头部以 <code>\\r\\n\\r\\n</code> 结束，这帮助接收方识别请求或响应的开始和结束。</p></li></ul><h3 id="http-2" tabindex="-1">HTTP/2 <a class="header-anchor" href="#http-2" aria-label="Permalink to &quot;HTTP/2&quot;">​</a></h3><p>HTTP/2 是一种二进制协议，它引入了帧的概念来传输数据。HTTP/2 使用帧来封装消息的不同部分，并且这些帧总是具有明确的边界，因此不需要像 HTTP/1.1 那样依赖于消息的结束标志。</p><p>HTTP/2 中的帧类型包括但不限于：</p><ul><li><p><strong>HEADERS</strong>:</p><p>用于承载请求或响应的头部信息。</p></li><li><p><strong>DATA</strong>:</p><p>用于传输请求或响应的主体数据。</p></li><li><p><strong>SETTINGS</strong>:</p><p>用于协商连接级别的参数。</p></li><li><p><strong>PUSH_PROMISE</strong>:</p><p>用于服务器推送。</p></li><li><p><strong>GOAWAY</strong>:</p><p>用于关闭连接。</p></li></ul><p>HTTP/2 中的粘包和拆包问题主要是通过以下方式解决的：</p><ul><li><p><strong>帧边界</strong>:</p><p>每个帧都有一个明确的开始和结束标记，使得接收端能够容易地区分不同的帧。</p></li><li><p><strong>帧头部</strong>:</p><p>每个帧的头部包含了必要的元数据，例如类型、长度和标识符，这些信息帮助接收方理解帧的内容和上下文。</p></li><li><p><strong>多路复用</strong>:</p><p>HTTP/2 支持在同一连接上并行传输多个请求和响应，每个请求和响应通过不同的流来标识，流之间不会相互干扰。</p></li></ul>',19)]))}const c=o(e,[["render",i]]);export{h as __pageData,c as default};
