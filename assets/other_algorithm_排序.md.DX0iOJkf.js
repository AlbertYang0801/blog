import{_ as s,c as a,o as l,aM as n}from"./chunks/framework.Du1sph90.js";const d=JSON.parse('{"title":"排序","description":"","frontmatter":{},"headers":[],"relativePath":"other/algorithm/排序.md","filePath":"other/algorithm/排序.md","lastUpdated":1752827268000}'),t={name:"other/algorithm/排序.md"};function h(e,i,p,k,r,c){return l(),a("div",null,i[0]||(i[0]=[n(`<h1 id="排序" tabindex="-1">排序 <a class="header-anchor" href="#排序" aria-label="Permalink to &quot;排序&quot;">​</a></h1><h2 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h2><h3 id="稳定性" tabindex="-1">稳定性 <a class="header-anchor" href="#稳定性" aria-label="Permalink to &quot;稳定性&quot;">​</a></h3><p>稳定性指的是相同的数据所在的位置经过排序后是否发生变化。若是排序后，次序不变，则是稳定的。</p><h3 id="内部排序" tabindex="-1">内部排序 <a class="header-anchor" href="#内部排序" aria-label="Permalink to &quot;内部排序&quot;">​</a></h3><p>排序记录全部存放在内存中进行排序的过程。</p><h3 id="外部排序" tabindex="-1">外部排序 <a class="header-anchor" href="#外部排序" aria-label="Permalink to &quot;外部排序&quot;">​</a></h3><p>待排序记录的数量很大，以至于内存不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程。</p><p><img src="https://s2.loli.net/2025/07/18/7dYNyKUk9tECrS1.png" alt="image.png" loading="lazy"></p><h2 id="选择排序-不稳定" tabindex="-1">选择排序-不稳定 <a class="header-anchor" href="#选择排序-不稳定" aria-label="Permalink to &quot;选择排序-不稳定&quot;">​</a></h2><p>每次选择剩余待排序元素中的最小值，放到已排序元素的末尾。</p><p>原理：<strong>每次排序选出最小的元素，替换到对应顺序末尾的位置。</strong> 思路：<strong>第一次排序选出最小的元素，和待排序数组第一位的元素进行交换。</strong></p><div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * 选择排序的思路：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * 1.外层循环n-1次，对所有元素进行遍历，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * 2.首先设置循环位次为初始下标位置</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * 3.内层排序从遍历元素位置+1开始遍历，到最后一个元素。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * 4.比较元素下标，记录最小元素的下标</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * 5.将最小元素下标位置元素与循环位次下标元素进行替换</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     *</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * @param arr</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * @return</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    public static int[] choooseSort(int[] arr) {</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">        for</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> (int</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> i</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> =</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> 0;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> i</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> &lt;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> arr.length-1;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> i++)</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            //设置最小元素下标初始值</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">            int</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> min</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> =</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> i;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            //选择出最小的值</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">            for</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> (int</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> j</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> =</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> i</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> +</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> 1;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> j</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> &lt;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> arr.length;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> j++)</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> {</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">                if</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> (arr[min]</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> &gt;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> arr[j])</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                    //设置最小元素下标位置</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">                    min</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> =</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> j;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            if (min != i) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                //设置临时变量</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">                int</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> temp;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                //交换最小元素与未排序的第一个元素</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">                temp</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> =</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> arr[i];</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">                arr[i]</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> =</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> arr[min];</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">                arr[min]</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> =</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> temp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            log.info(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;第{}次排序后的结果：{}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, i, Arrays.toString(arr));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        return arr;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p><img src="https://s2.loli.net/2025/07/18/BDqLoyKIOfRpXtP.png" alt="image.png" loading="lazy"></p><ul><li>17和21交换位置。破坏了两个21之间的相对位置。</li></ul><h2 id="冒泡排序-稳定" tabindex="-1">冒泡排序-稳定 <a class="header-anchor" href="#冒泡排序-稳定" aria-label="Permalink to &quot;冒泡排序-稳定&quot;">​</a></h2><p>从第一个元素开始，和相邻的元素进比较，若前面的元素比后面的元素大，则两者交换位置，直到最大的元素放到最后位置。</p><p>相邻两个元素，两两交换。</p><ol><li>外层循环n-1次，代表需要循环n-1次。</li><li>内层循环：比较为排序的字段列表，相邻元素进行比较，大的元素排在后面。</li></ol><h2 id="直接插入排序-稳定" tabindex="-1">直接插入排序-稳定 <a class="header-anchor" href="#直接插入排序-稳定" aria-label="Permalink to &quot;直接插入排序-稳定&quot;">​</a></h2><p>将数据按照顺序插入到表里。保证插入每个元素之后，表元素顺序是有序的。</p><ol><li>将传入数组的第一个元素视为顺序表的第一个元素。</li><li>从第二个元素开始和之前的元素进行比较</li><li>比较规则是：若元素比比较的元素小，则两者交换位置</li></ol><div class="language-json vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    public static int[] sort(int[] arr) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //临时变量</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">        int</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> temp;</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">        for</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> (int</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> i</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> =</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> 1;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> i</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> &lt;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> arr.length;</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> i++)</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            //从第一个开始和之前的元素比较</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">            for(int</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> j</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> =0;j&lt;i;j++){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                //若比之前的元素小，则交换元素</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">                if(arr[i]&lt;arr[j]){</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">                    temp</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> =</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> arr[i];</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">                    arr[i]=arr[j];</span></span>
<span class="line"><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">                    arr[j]</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> =</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;"> temp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            System.out.println(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;第&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">+i+</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;次排序后的结果:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">+ Arrays.toString(arr));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        return arr;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><img src="https://s2.loli.net/2025/07/18/E4gNxYaVOhUvPAD.png" alt="image.png" loading="lazy"></p><p>如果待排序列基本有序，使用直接插入排序。</p><h2 id="希尔排序-不稳定" tabindex="-1">希尔排序-不稳定 <a class="header-anchor" href="#希尔排序-不稳定" aria-label="Permalink to &quot;希尔排序-不稳定&quot;">​</a></h2><p>直接插入排序的增强版本。</p><p>现将整个待排记录序列分割成若干子序列，然后分别进行直接插入排序；待整个序列中的记录基本有序的时候，再对全体记录进行一次直接插入排序。</p><p><img src="https://s2.loli.net/2025/07/18/7dYNyKUk9tECrS1.png" alt="image.png" loading="lazy"></p><h2 id="堆排序-不稳定" tabindex="-1">堆排序-不稳定 <a class="header-anchor" href="#堆排序-不稳定" aria-label="Permalink to &quot;堆排序-不稳定&quot;">​</a></h2><p>对树进行调整，调整完的树保证根节点比左右子树都要大。即为大根堆，每次调整将堆顶元素弹出。</p><p>每次调整完，弹出堆顶元素，直到弹出所有元素即可得到有序序列。</p><p><img src="https://s2.loli.net/2025/07/18/bQ1TZ5sAlhvCEdc.png" alt="image.png" loading="lazy"></p><p><img src="https://s2.loli.net/2025/07/18/pKi81safxZRO974.png" alt="image.png" loading="lazy"></p><p>大根堆递增，小根堆递减。</p><h2 id="快速排序-不稳定" tabindex="-1">快速排序-不稳定 <a class="header-anchor" href="#快速排序-不稳定" aria-label="Permalink to &quot;快速排序-不稳定&quot;">​</a></h2><p>快速排序首先选择了一个基准值，然后分别选择两个指针在数组中一个找大，一个找小，然后进行交换。</p><p>通过一趟排序将待排序的记录以基准值为分界，分为独立的两个部分，称为前半区和后半区；前半区均小于基准值，后半区均大于基准值。</p><p>然后再分别对这两个部分在进行快速排序，从而使得整个序列有序。</p><p>分而治之</p><p><img src="https://s2.loli.net/2025/07/18/HsObXrJjBY2DqwF.png" alt="image.png" loading="lazy"></p><p>在基本有序的情况下，快排的时间复杂度是最坏的。</p><ol><li>快速排序整体的综合性能和使用场景都是比较好的，所以才叫快速排序。</li><li>时间复杂度：最好：O(N*logN) ； 最坏：O(N2)</li><li>空间复杂度：O(logN) ~ O(N)</li><li>稳定性：<em>不稳定</em></li><li>快速排序整体的综合性能和使用场景都是比较好的，所以才叫快速排序。</li><li>时间复杂度：最好：O(N*logN) ； 最坏：O(N2)</li><li>空间复杂度：O(logN) ~ O(N)</li><li>稳定性：<em>不稳定</em></li></ol><h2 id="归并排序" tabindex="-1">归并排序 <a class="header-anchor" href="#归并排序" aria-label="Permalink to &quot;归并排序&quot;">​</a></h2><p><img src="https://s2.loli.net/2025/07/18/M3l8FyTjHf6bnhw.png" alt="image.png" loading="lazy"></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p><img src="https://s2.loli.net/2025/07/18/D1umsy5UrlKiaR8.png" alt="image.png" loading="lazy"></p><ul><li>选择排序： <ul><li>将元素分为已排序和待排序。</li><li><strong>从待排序元素中选择出最小值。追加到待排序元素末尾。</strong></li></ul></li><li>冒泡排序：相邻元素两两交换，直到最大元素放到末尾。</li><li>直接插入排序： <ul><li>将元素分为排序和待排序，已排序元素保持有序状态。</li><li><strong>遍历待排序中的元素，将元素插入到已排序元素列表合适的位置。</strong></li></ul></li><li>希尔排序 - 插入排序增强版（分而治之）： <ul><li>适合大数据量的情况，将数据分为多个分组。</li><li>每个分组先进行直接插入排序。</li><li>将排序好的分组统一进行直接插入排序。</li></ul></li><li>快速排序： <ul><li>选择一个基准值，将比基准值小的元素放到左边，比基准值大的元素放到右边。</li><li>对左右分区进行快速排序，直到整个序列有序。</li></ul></li><li>堆排序： <ul><li>构造排序树，每次将最小值出树。</li></ul></li></ul><p><img src="https://s2.loli.net/2025/07/18/wc3K4NLk7ldXOhz.png" alt="image.png" loading="lazy"></p><h3 id="复杂度" tabindex="-1">复杂度 <a class="header-anchor" href="#复杂度" aria-label="Permalink to &quot;复杂度&quot;">​</a></h3><ol><li><p>空间复杂度</p><ul><li><p>大部分排序都是比较交换，无需额外空间。</p></li><li><p>快速排序需要存储每次基准值。</p></li></ul></li><li><p>时间复杂度</p><ul><li><p>与堆、树、二分有关的算法都是 n*logn。</p><ul><li>堆排序（堆）</li><li>快速排序（二分）</li></ul></li><li><p>直接的算法都是 n*n。</p></li></ul></li></ol>`,51)]))}const y=s(t,[["render",h]]);export{d as __pageData,y as default};
