import{_ as l,c as e,o as t,aM as i}from"./chunks/framework.Du1sph90.js";const u=JSON.parse('{"title":"redis集群","description":"","frontmatter":{},"headers":[],"relativePath":"database/redis/redis集群.md","filePath":"database/redis/redis集群.md","lastUpdated":1752827238000}'),r={name:"database/redis/redis集群.md"};function s(o,a,n,d,p,h){return t(),e("div",null,a[0]||(a[0]=[i('<h1 id="redis集群" tabindex="-1">redis集群 <a class="header-anchor" href="#redis集群" aria-label="Permalink to &quot;redis集群&quot;">​</a></h1><p>Redis集群是一个由多个主从节点群组成的分布式服务集群，它具有复制、高可用和分片特性。</p><h2 id="主从模式" tabindex="-1">主从模式 <a class="header-anchor" href="#主从模式" aria-label="Permalink to &quot;主从模式&quot;">​</a></h2><p><img src="https://s2.loli.net/2025/06/18/9MeK71BzsnDY2iO.png" alt="" loading="lazy"></p><ul><li><p>主数据库可以进行<strong>读写</strong>操作。</p><p>数据会通过主从同步，由主服务器同步给从服务器。</p><p>主服务器将数据</p></li><li><p>从数据库一般是<strong>只读</strong>的。</p></li></ul><p><strong>引入主从复制机制的目的有两个：</strong></p><ul><li>一个是读写分离，分担 “master” 的读写压力</li><li>一个是方便做容灾恢复，避免单点故障。</li></ul><h3 id="主从同步的原理" tabindex="-1">主从同步的原理 <a class="header-anchor" href="#主从同步的原理" aria-label="Permalink to &quot;主从同步的原理&quot;">​</a></h3><p><img src="https://s2.loli.net/2025/06/18/nArwy3zkLoCDvKh.png" alt="" loading="lazy"></p><ul><li><p>全量复制</p><p>从数据库在第一次同步的时候会进行全量同步。</p><p>主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。</p><p>从库收到 RDB 文件后，清空自己的数据，载入 RDB文件。</p></li><li><p>增量复制</p><p>第一次全量同步之后，后续<strong>主</strong>存在数据变更的时候会将命令同步给**从，**从进行增量复制。</p><blockquote><p>当全量复制完成之后，主和从之间会建立一个网络连接，从后续会将收到的写命令通过这个连接传给从。</p></blockquote></li></ul><h3 id="主从复制优缺点" tabindex="-1">主从复制优缺点 <a class="header-anchor" href="#主从复制优缺点" aria-label="Permalink to &quot;主从复制优缺点&quot;">​</a></h3><p><strong>优点</strong></p><ul><li>支持主从复制，主机会自动将数据同步到从机，可以进行<strong>读写分离</strong>；</li><li>为了分载 Master 的读操作压力，Slave 服务器可以为客户端提供只读操作的服务，写服务仍然必须由Master来完成；</li><li>Slave 同样可以接受其它 Slaves 的连接和同步请求，这样可以有效的分载 Master 的同步压力；</li><li>Master Server 是以<strong>非阻塞</strong>的方式为 Slaves 提供服务。所以在 Master-Slave 同步期间，客户端仍然可以提交查询或修改请求；</li><li>Slave Server 同样是以<strong>非阻塞</strong>的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据；</li></ul><p><strong>缺点</strong></p><ul><li>当<strong>主服务器宕机</strong>后，需要<strong>手动把一台从服务器切换为主服务器</strong>，这就需要<strong>人工干预</strong>，费事费力，还会造成一段时间内服务不可用。</li><li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性；</li></ul><blockquote><p>主从复制主要存在的问题就是，主从集群故障之后不能自动恢复。</p></blockquote><h2 id="哨兵模式" tabindex="-1">哨兵模式 <a class="header-anchor" href="#哨兵模式" aria-label="Permalink to &quot;哨兵模式&quot;">​</a></h2><p><strong>Redis 提供了哨兵机制来实现主从集群故障的自动恢复。</strong></p><h3 id="哨兵" tabindex="-1">哨兵 <a class="header-anchor" href="#哨兵" aria-label="Permalink to &quot;哨兵&quot;">​</a></h3><p><strong>哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个 Redis 实例。</strong></p><p><img src="https://s2.loli.net/2025/06/18/tFeSWuasZhjfEUr.png" alt="" loading="lazy"></p><h3 id="哨兵的作用" tabindex="-1">哨兵的作用 <a class="header-anchor" href="#哨兵的作用" aria-label="Permalink to &quot;哨兵的作用&quot;">​</a></h3><ul><li><strong>运行状态监控</strong>：监测 Redis 服务器的运行状态，包括主服务器和从服务器。</li><li><strong>自动故障恢复</strong>：当哨兵监测到 master 宕机，会自动将 slave 切换成 master ，然后通过<strong>发布订阅模式</strong>通知其他的从服务器，修改配置文件，让它们切换主机。</li><li><strong>通知</strong>：Sentinel充当 Redis客户端（RedisClient） 的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端。</li></ul><p><img src="https://s2.loli.net/2025/06/18/1USYEaiwDrqcHKl.png" alt="" loading="lazy"></p><h3 id="运行状态监控" tabindex="-1">运行状态监控 <a class="header-anchor" href="#运行状态监控" aria-label="Permalink to &quot;运行状态监控&quot;">​</a></h3><ul><li><p>主观下线</p><p>每个 Sentinel 以每秒一次的频率向它所知的主从服务器以及其它 Sentinel 实例发送一个 PING 命令，实例距离最后一次<strong>有效回复 PING 命令的时间超过指定的值</strong>， 那么这个实例会被 Sentinel 标记为<strong>主观下线</strong>。</p></li><li><p>客观下线</p><p>若超过指定数量（quorum）的 Sentinel 认为某个节点主观下线，则该实例<strong>客观下线</strong>。</p><p>客观下线后会重新选举 Master。</p></li></ul><h2 id="分片集群模式" tabindex="-1">分片集群模式 <a class="header-anchor" href="#分片集群模式" aria-label="Permalink to &quot;分片集群模式&quot;">​</a></h2><p>Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，所以在 redis3.0上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，<strong>也就是说每台 Redis 节点上存储不同的内容</strong>。</p><p><img src="https://s2.loli.net/2025/06/18/5dWZNbzRA6r7XBM.png" alt="" loading="lazy"></p><h3 id="集群的数据分片" tabindex="-1">集群的数据分片 <a class="header-anchor" href="#集群的数据分片" aria-label="Permalink to &quot;集群的数据分片&quot;">​</a></h3><p>Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽。<strong>集群的每个节点负责一部分hash槽</strong>，举个例子，比如当前集群有3个节点，那么：</p><ul><li>节点 A 包含 0 到 5460 号哈希槽</li><li>节点 B 包含 5461 到 10922 号哈希槽</li><li>节点 C 包含 10923 到 16383 号哈希槽</li></ul><h3 id="主从复制" tabindex="-1">主从复制 <a class="header-anchor" href="#主从复制" aria-label="Permalink to &quot;主从复制&quot;">​</a></h3><ul><li>当主节点挂了之后，启用从节点。</li><li>如果主节点和它的从节点都挂了，redis 不能提供服务。</li><li>当集群内半数主节点 PING 主节点不通的时候，认为主节点挂掉（fail 半数检查机制）。</li></ul><h3 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h3><ol><li>所有的 redis 节点彼此互联 (PING-PONG机制)，内部使用二进制协议优化传输速度和带宽。</li><li>fail 半数检查机制才认为节点挂掉。</li><li>客户端连接集群中任意节点即可。客户端可以与节点直连。</li></ol>',36)]))}const c=l(r,[["render",s]]);export{u as __pageData,c as default};
