import{_ as r,c as a,o,aM as t}from"./chunks/framework.Du1sph90.js";const p=JSON.parse('{"title":"RocketMQ基础学习","description":"","frontmatter":{},"headers":[],"relativePath":"middleware/rocketmq/RocketMQ基础学习.md","filePath":"middleware/rocketmq/RocketMQ基础学习.md","lastUpdated":1752827238000}'),s={name:"middleware/rocketmq/RocketMQ基础学习.md"};function n(i,e,l,c,d,g){return o(),a("div",null,e[0]||(e[0]=[t('<h1 id="rocketmq基础学习" tabindex="-1">RocketMQ基础学习 <a class="header-anchor" href="#rocketmq基础学习" aria-label="Permalink to &quot;RocketMQ基础学习&quot;">​</a></h1><h2 id="基础架构" tabindex="-1">基础架构 <a class="header-anchor" href="#基础架构" aria-label="Permalink to &quot;基础架构&quot;">​</a></h2><p><img src="https://s2.loli.net/2025/06/27/JQ74usXOmze6LI3.png" alt="image.png" loading="lazy"></p><h2 id="生产者" tabindex="-1">生产者 <a class="header-anchor" href="#生产者" aria-label="Permalink to &quot;生产者&quot;">​</a></h2><p>RocketMQ提供多种发送方式，<strong>同步发送、异步发送、顺序发送、单向发送</strong>。</p><p>同步和异步方式均需要 Broker 返回确认信息，单向发送不需要。</p><p>生产者中，会把同一类 Producer 组成一个集合，叫做生产者组。<strong>同一组的 Producer 被认为是发送同一类消息且发送逻辑一致</strong>。</p><h2 id="消费者" tabindex="-1">消费者 <a class="header-anchor" href="#消费者" aria-label="Permalink to &quot;消费者&quot;">​</a></h2><h3 id="消费者组" tabindex="-1">消费者组 <a class="header-anchor" href="#消费者组" aria-label="Permalink to &quot;消费者组&quot;">​</a></h3><p><strong>消费者组消费同一组数据，消费相同topic，并且消费逻辑一致。消费者组的消费者实例必须订阅完全相同的Topic</strong>。</p><h3 id="消费模式" tabindex="-1">消费模式 <a class="header-anchor" href="#消费模式" aria-label="Permalink to &quot;消费模式&quot;">​</a></h3><p>RocketMQ 支持两种消息模式：<strong>集群消费（Clustering）和广播消费（Broadcasting）</strong>。</p><ul><li>集群消费模式下, 相同Consumer Group的每个Consumer<strong>实例平均分摊消息</strong>。</li><li>广播消费模式下，相同Consumer Group的每个Consumer<strong>实例都接收全量的消息</strong>。</li></ul><h2 id="topic" tabindex="-1">Topic <a class="header-anchor" href="#topic" aria-label="Permalink to &quot;Topic&quot;">​</a></h2><p>Topic只是一个逻辑概念，<strong>并不实际保存消息</strong>。同一个Topic下的消息，会分片保存到不同的Broker上，而每一个分片单位，就叫做<strong>MessageQueue</strong>。</p><p>MessageQueue是一个具有<strong>FIFO特性的队列</strong>结构，生产者发送消息与消费者<strong>消费消息的最小单位</strong>。</p><p>类似于Kakfa的Partation。</p><h2 id="broker" tabindex="-1">Broker <a class="header-anchor" href="#broker" aria-label="Permalink to &quot;Broker&quot;">​</a></h2><p>Broker Server是 RocketMQ 的核心。</p><ul><li>Remoting Module：整个Broker的实体，负责处理来自clients端的请求。</li><li>Client Manager：负责管理客户端(Producer/Consumer)和维护Consumer的Topic订阅信息。</li><li>Store Service：提供方便简单的API接口处理消息存储到物理硬盘和查询功能。</li><li>HA Service：高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能。</li><li>Index Service：根据特定的Message key对投递到Broker的消息进行索引服务，以提供消息的快速查询。</li></ul><h3 id="broker集群" tabindex="-1">Broker集群 <a class="header-anchor" href="#broker集群" aria-label="Permalink to &quot;Broker集群&quot;">​</a></h3><h3 id="普通集群" tabindex="-1">普通集群 <a class="header-anchor" href="#普通集群" aria-label="Permalink to &quot;普通集群&quot;">​</a></h3><p>这种集群模式下会给每个节点分配一个固定的角色。</p><ul><li>master负责响应客户端的请求，并存储消息。</li><li>slave则只负责对master的消息进行同步保存，并响应部分客户端的读请求。消息同步方式分为<strong>同步</strong>同步和<strong>异步</strong>同步。</li></ul><p>这种集群模式下各个节点的角色无法进行切换，也就是说，master节点挂了，这一组Broker就不可用了。</p><p><strong>读写分离，master挂了之后这一组Borker就失效了。没有master选举机制</strong></p><h3 id="dledger集群" tabindex="-1">Dledger集群 <a class="header-anchor" href="#dledger集群" aria-label="Permalink to &quot;Dledger集群&quot;">​</a></h3><p>Dledger是 RocketMQ 自4.5版本引入的实现高可用集群的一项技术。</p><p>这个模式下的集群会随机选出一个节点作为master，而当master节点挂了后，会从<strong>slave中自动选出一个节点升级成为master</strong>。</p><p>Dledger技术做的事情：</p><ol><li><strong>从集群中选举出master节点</strong>。</li><li><strong>完成master节点往slave节点的消息同步</strong>。</li></ol><h2 id="nameserver" tabindex="-1">NameServer <a class="header-anchor" href="#nameserver" aria-label="Permalink to &quot;NameServer&quot;">​</a></h2><p>NameServer 就是 <strong>Broker的注册中心</strong>。</p><p>BrokerServer 会在启动时向所有的 NameServer 注册自己的服务信息，并且后续通过心跳请求的方式保证这个服务信息的实时性。</p><p>生产者或消费者能够通过名字服务查找各主题相应的 Broker IP 列表。多个 Nameserver 实例组成集群，但相互独立，没有信息交换。</p><h2 id="message" tabindex="-1">Message <a class="header-anchor" href="#message" aria-label="Permalink to &quot;Message&quot;">​</a></h2><p>生产和消费数据的最小单位，每条消息<strong>必须属于一个 Topic</strong>。</p><h3 id="messageid" tabindex="-1">MessageID <a class="header-anchor" href="#messageid" aria-label="Permalink to &quot;MessageID&quot;">​</a></h3><p>RocketMQ 中每个消息拥有<strong>唯一的 MessageID</strong>，且可以携带具有业务标识的 Key。系统提供了通过 Message ID 和 Key 查询消息的功能。</p><h3 id="tag" tabindex="-1">Tag <a class="header-anchor" href="#tag" aria-label="Permalink to &quot;Tag&quot;">​</a></h3><p>Message 上有一个为消息设置的标志-<strong>Tag标签</strong>。用于<strong>同一Topic下区分不同类型的消息</strong>。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化 RocketMQ 提供的查询系统。</p><p><strong>消费者可以设置消费某个Topic的指定Tag数据，用于数据过滤。</strong></p><blockquote><p>消费者可以指定 topic 和 tag。</p></blockquote>',43)]))}const m=r(s,[["render",n]]);export{p as __pageData,m as default};
