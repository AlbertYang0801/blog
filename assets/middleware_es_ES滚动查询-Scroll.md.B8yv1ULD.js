import{_ as a,c as n,o as l,aN as i}from"./chunks/framework.A-MC8nKA.js";const d=JSON.parse('{"title":"ES滚动查询-Scroll","description":"","frontmatter":{},"headers":[],"relativePath":"middleware/es/ES滚动查询-Scroll.md","filePath":"middleware/es/ES滚动查询-Scroll.md","lastUpdated":1752827238000}'),p={name:"middleware/es/ES滚动查询-Scroll.md"};function e(r,s,t,c,h,o){return l(),n("div",null,s[0]||(s[0]=[i(`<h1 id="es滚动查询-scroll" tabindex="-1">ES滚动查询-Scroll <a class="header-anchor" href="#es滚动查询-scroll" aria-label="Permalink to &quot;ES滚动查询-Scroll&quot;">​</a></h1><h2 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理&quot;">​</a></h2><p>Elasticsearch中的滚动查询是基于 <strong>固定的排序规则</strong> 来加载一部分数据。</p><p>当用户刷新时，将从上次加载的最后一条数据的位置再加载同样数量的数据。</p><p>滚动查询的原理类似于分页查询，但是滚动查询不需要重新执行搜索，只需要继续检索下一批结果。在滚动查询中，每次只加载当前页的数据，而不是一次性加载所有数据。这使得滚动查询比分页查询更高效，因为滚动查询不需要将所有数据都存储在内存中。同时，滚动查询也适用于大量数据的处理，因为它可以分批次地处理数据，而不是一次性处理所有数据。</p><h3 id="滚动查询的排序规则" tabindex="-1">滚动查询的排序规则 <a class="header-anchor" href="#滚动查询的排序规则" aria-label="Permalink to &quot;滚动查询的排序规则&quot;">​</a></h3><p><strong>滚动查询的排序规则不一定是时间</strong>。在Elasticsearch中，滚动查询是使用”scroll” API来执行的操作，它的排序规则取决于你在搜索请求中指定的排序方式。</p><p>例如，你可以根据文档的特定字段进行排序，如按照日期字段排序，或者按照相关性得分排序。如果你没有指定排序方式，Elasticsearch将按照相关性得分进行排序。</p><p>固定排序规则意味着每次滚动查询都按照相同的规则返回数据。如果数据的排序发生改变，那么之前保存的滚动ID将无法使用。</p><p>因此，如果你需要根据时间进行滚动查询，你需要确保时间字段在搜索请求中作为排序的一部分，这样滚动查询的结果才能按照时间进行排序。</p><p><strong>通过使用ScrollId机制，用户可以继续从上一次停止的位置开始检索，而不是重新从头开始检索。</strong></p><h3 id="scrollid清除" tabindex="-1">ScrollId清除 <a class="header-anchor" href="#scrollid清除" aria-label="Permalink to &quot;ScrollId清除&quot;">​</a></h3><p><strong>是的</strong>，scrollId需要手动清除。scrollId是Elasticsearch中用于滚动查询的标识符，它会在每次滚动查询时生成，并返回给客户端。在完成滚动查询后，需要手动清除scrollId，以释放Elasticsearch资源并避免文件描述符被占用。可以通过使用<code>ClearScrollRequest</code>来手动清除scrollId。</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            List&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; scrollList </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Arrays.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">asList</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(scrollIds);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            ClearScrollRequest clearScrollRequest </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ClearScrollRequest</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            clearScrollRequest.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setScrollIds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(scrollList);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            ClearScrollResponse clearScrollResponse </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                clearScrollResponse </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ConnectEs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">instance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getRestHighLevelClient</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">clearScroll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(clearScrollRequest, RequestOptions.DEFAULT);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (IOException </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                log.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">warn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;clearScroll exp -&gt;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, e);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="使用示例" tabindex="-1">使用示例 <a class="header-anchor" href="#使用示例" aria-label="Permalink to &quot;使用示例&quot;">​</a></h2><p>当使用滚动查询时，通常需要将滚动ID传递给滚动API以检索下一批结果。以下是一个示例：</p><p>假设我们有一个名为”my_index”的索引，并且我们想要检索其中包含单词”elasticsearch”的所有文档。我们可以通过以下步骤执行滚动查询：</p><ol><li>发送初始搜索请求，并指定滚动查询参数：</li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>    POST /my_index/_search?scroll=1m</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      &quot;query&quot;: {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        &quot;match&quot;: {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>          &quot;content&quot;: &quot;elasticsearch&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>该请求将返回一个滚动ID，我们将需要传递该ID以检索下一批结果。</p><ol><li>发送滚动API请求以检索下一批结果：</li></ol><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>	POST /my_index/_search?scroll=1m  </span></span>
<span class="line"><span></span></span>
<span class="line"><span>	{  </span></span>
<span class="line"><span></span></span>
<span class="line"><span>	  &quot;query&quot;: {  </span></span>
<span class="line"><span></span></span>
<span class="line"><span>	    &quot;match&quot;: {  </span></span>
<span class="line"><span></span></span>
<span class="line"><span>	      &quot;content&quot;: &quot;elasticsearch&quot;  </span></span>
<span class="line"><span></span></span>
<span class="line"><span>	    }  </span></span>
<span class="line"><span></span></span>
<span class="line"><span>	  }  </span></span>
<span class="line"><span></span></span>
<span class="line"><span>	}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>其中，<code>scroll_id</code> 是从初始搜索请求中获得的滚动ID。该请求将返回下一批结果。</p><ol><li><p>重复执行步骤2，直到所有结果都被检索到或达到停止条件。</p><p>需要注意的是，滚动查询不适合用于实时数据，因为滚动查询会保持搜索上下文，可能会返回旧数据。此外，滚动查询会消耗大量的内存和CPU资源，不建议在生产环境中频繁使用。</p></li></ol>`,24)]))}const b=a(p,[["render",e]]);export{d as __pageData,b as default};
