import{_ as e,c as r,o as t,aM as n}from"./chunks/framework.Du1sph90.js";const u=JSON.parse('{"title":"ConcurrentHashMap -1.8","description":"","frontmatter":{},"headers":[],"relativePath":"java/collection/ConcurrentHashMap1.8.md","filePath":"java/collection/ConcurrentHashMap1.8.md","lastUpdated":1751523274000}'),o={name:"java/collection/ConcurrentHashMap1.8.md"};function c(p,a,s,l,h,i){return t(),r("div",null,a[0]||(a[0]=[n('<h1 id="concurrenthashmap-1-8" tabindex="-1">ConcurrentHashMap -1.8 <a class="header-anchor" href="#concurrenthashmap-1-8" aria-label="Permalink to &quot;ConcurrentHashMap -1.8&quot;">​</a></h1><p><a href="https://javaguide.cn/java/collection/concurrent-hash-map-source-code.html#_4-get" target="_blank" rel="noreferrer">ConcurrentHashMap 源码分析</a></p><p>1.8的ConcurrentHashMap，采用对Node加锁机制。</p><h3 id="加锁原理" tabindex="-1">加锁原理 <a class="header-anchor" href="#加锁原理" aria-label="Permalink to &quot;加锁原理&quot;">​</a></h3><p>采用CAS+Synchronized组合锁的方法。</p><ul><li><p>CAS</p><p>操作Node数组的时候以CAS方式操作。</p></li><li><p>Synchronized</p><p>操作Node对应的数据结构，链表或红黑树的时候加Synchronized。保证操作数据的原子性。</p></li></ul>',6)]))}const _=e(o,[["render",c]]);export{u as __pageData,_ as default};
