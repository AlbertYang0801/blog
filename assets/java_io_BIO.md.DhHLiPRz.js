import{_ as t,c as a,o,aM as r}from"./chunks/framework.Du1sph90.js";const I=JSON.parse('{"title":"BIO","description":"","frontmatter":{},"headers":[],"relativePath":"java/io/BIO.md","filePath":"java/io/BIO.md","lastUpdated":1751453543000}'),p={name:"java/io/BIO.md"};function c(i,e,n,s,l,d){return o(),a("div",null,e[0]||(e[0]=[r('<h1 id="bio" tabindex="-1">BIO <a class="header-anchor" href="#bio" aria-label="Permalink to &quot;BIO&quot;">​</a></h1><p>JDK 网络编程 BIO，意为阻塞的 IO。</p><p>BIO 的阻塞体现在两个方面：</p><ol><li>若一个服务端的服务绑定端口启动后，主线程就会一直等待客户端的连接。</li><li>客户端和服务端 Socket 端口建立连接之后，在读取到 Socket 信息之前，线程一直处于等待，一直处于阻塞状态。</li></ol><p>典型的 <strong>请求 -应答模型</strong></p><p>由一个独立的 <code>Acceptor</code> 模型监听客户端的请求，收到请求后为每一个客户端创建一个线程去处理，处理完成后将结果返回给客户端。</p><p>Java BIO：传统的网络通讯模型，就是BIO，同步阻塞IO。</p><p>其实就是服务端创建一个ServerSocket， 然后就是客户端用一个 Socket 去连接服务端的那个ServerSocket， ServerSocket接收到了一个的连接请求就创建一个Socket和一个线程去跟那个Socket进行通讯。</p><p>接着客户端和服务端就进行阻塞式的通信，客户端发送一个请求，服务端Socket进行处理后返回响应，在响应返回前，客户端那边就阻塞等待，什么事情也做不了。</p><p>这种方式的缺点， 每次一个客户端接入，都需要在服务端创建一个线程来服务这个客户端，<strong>这样大量客户端来的时候，就会造成服务端的线程数量可能达到了几千甚至几万，这样就可能会造成服务端过载过高，最后崩溃死掉</strong>。</p><h3 id="伪异步io模型" tabindex="-1">伪异步IO模型 <a class="header-anchor" href="#伪异步io模型" aria-label="Permalink to &quot;伪异步IO模型&quot;">​</a></h3><p>用线程池管理服务端的线程，实现异步处理Socket请求。</p><p>但是底层还是使用同步阻塞IO，所以叫伪异步。</p>',13)]))}const S=t(p,[["render",c]]);export{I as __pageData,S as default};
