import{_ as a,c as e,o as l,aM as r}from"./chunks/framework.Du1sph90.js";const g=JSON.parse('{"title":"倒排索引图解","description":"","frontmatter":{},"headers":[],"relativePath":"middleware/es/倒排索引原理.md","filePath":"middleware/es/倒排索引原理.md","lastUpdated":1752827238000}'),d={name:"middleware/es/倒排索引原理.md"};function p(i,t,o,n,h,s){return l(),e("div",null,t[0]||(t[0]=[r('<h1 id="倒排索引图解" tabindex="-1">倒排索引图解 <a class="header-anchor" href="#倒排索引图解" aria-label="Permalink to &quot;倒排索引图解&quot;">​</a></h1><h2 id="原理图" tabindex="-1">原理图 <a class="header-anchor" href="#原理图" aria-label="Permalink to &quot;原理图&quot;">​</a></h2><p><img src="https://s2.loli.net/2025/06/26/PrSpY4mgJo2RQhU.png" alt="image.png" loading="lazy"></p><h3 id="倒排索引的搜索过程" tabindex="-1">倒排索引的搜索过程 <a class="header-anchor" href="#倒排索引的搜索过程" aria-label="Permalink to &quot;倒排索引的搜索过程&quot;">​</a></h3><p><img src="https://s2.loli.net/2025/06/26/kmrfp1xyqgCoNDM.png" alt="image.png" loading="lazy"></p><h1 id="倒排索引原理" tabindex="-1">倒排索引原理 <a class="header-anchor" href="#倒排索引原理" aria-label="Permalink to &quot;倒排索引原理&quot;">​</a></h1><p>Elasticsearch 主要功能就是搜索，为了提高搜索效率，其内部使用了倒排索引。</p><h2 id="正排索引" tabindex="-1">正排索引 <a class="header-anchor" href="#正排索引" aria-label="Permalink to &quot;正排索引&quot;">​</a></h2><p>在搜索引擎中，每个文件对应一个文件 ID （doc_id），文件内容是关键词的集合。</p><p><img src="https://s2.loli.net/2025/06/26/p7oH6VIwuerOXGY.jpg" alt="20210709222359.jpg" loading="lazy"></p><p>根据 <code>doc_id</code> 可以查找到文档详情。</p><p><em>这种方式本质上就是通过文档的 key 查找 value 值。</em></p><p>比如查找 <code>name=jetty wan</code> 的文档，只能按照顺序从前向后匹配每个文档的 name 字段。</p><p>这种查找方式的效率非常低下。</p><h2 id="倒排索引" tabindex="-1">倒排索引 <a class="header-anchor" href="#倒排索引" aria-label="Permalink to &quot;倒排索引&quot;">​</a></h2><p>倒排索引和正向索引相比，通过数据结构保存包含每个单词的文档列表，来实现单词的快速查询。</p><p>如下图，比如说我想搜索 name 中包含 wang 的文档，先从单词词典中查找到 wang ，再去倒排列表中查找 wang 对应的文档列表。能够大大提升查询速率。</p><h3 id="倒排索引组成" tabindex="-1">倒排索引组成 <a class="header-anchor" href="#倒排索引组成" aria-label="Permalink to &quot;倒排索引组成&quot;">​</a></h3><p>倒排索引的结构由三部分组成：<strong>单词词典、倒排列表和倒排文件</strong>。</p><p><img src="https://s2.loli.net/2025/06/26/9AoBrv5wJ7p1WDa.jpg" alt="20210709231001.jpg" loading="lazy"></p><ol><li><p>单词词典</p><p>搜索引擎搜索时单位通常是单词，而单词词典就是文档集合中出现的所有单词列表，每个单词都包含一个指向倒排列表的指针。</p></li><li><p>倒排列表</p><p>根据倒排列表可以知道包含某个单词的所有文档信息。倒排列表中的每条记录又叫做倒排项。</p><p>主要包含：</p><ul><li>单词和出现该单词的文档列表。</li><li>记录每个单词在所有文档中的出现次数和所在位置。</li></ul></li><li><p>倒排文件介绍</p><p>倒排列表是倒排索引的主要组成部分，而倒排文件就是磁盘中保存倒排列表的文件，是存储倒排列表的物理文件。</p></li></ol><h3 id="倒排索引位置" tabindex="-1">倒排索引位置 <a class="header-anchor" href="#倒排索引位置" aria-label="Permalink to &quot;倒排索引位置&quot;">​</a></h3><p>倒排索引的结构由三部分组成：<strong>单词词典、倒排列表和倒排文件</strong>。</p><p>单词词典通过特定结构存在于内存中，而倒排文件存在磁盘中。</p><p><img src="https://s2.loli.net/2025/06/26/TvUzGchuPIKOMQ7.png" alt="image.png" loading="lazy"></p><h3 id="单词词典" tabindex="-1">单词词典 <a class="header-anchor" href="#单词词典" aria-label="Permalink to &quot;单词词典&quot;">​</a></h3><p>单词列表中包含的数据是文档中出现过的所有单词，每个单词都包含一个指向倒排列表的指针。</p><p>当想要查询包含某个单词的所有文档时，第一步就要从单词列表中查询该单词。若单词列表数据结构是线性表的话，查询效率是非常低下的。</p><p>常见的单词列表数据结构有 <strong>哈希加链表</strong> 和 <strong>B+树</strong>）。</p><ul><li><p>哈希加链表</p><p>和 HashMap 1.7 时的底层数据结构一样。</p><p>通过计算单词的 hash 值计算出其所在哈希表的位置，若哈希表同一位置上出现多个单词，则会在该位置形成链表结构。</p><p><img src="https://s2.loli.net/2025/06/26/fKGxXQdY624iJeO.jpg" alt="20210709233959.jpg" loading="lazy"></p><p>哈希加链表最大的缺点就是不能支持单词的顺序或者范围查找。</p></li><li><p>B+树</p><p>B+ 树要求存入的单词字典项能够按照大小排序（数字或字符串），而哈希表是无需满足该要求的。</p><p>同样的 B+ 树结构可以满足顺序查找和范围查找。</p><p><img src="https://s2.loli.net/2025/06/26/4a3IMLFjuUSgki6.png" alt="20210709235334.png" loading="lazy"></p><p>B+ 树的叶子结点保存了单词的地址信息，通过地址信息就能找到单词信息。</p><p>使用 B+ 树能够大大减少查找次数，提高查询效率。</p><p><strong>单词词典索引</strong></p><p>单词词典保存了文档中所有存在的单词。</p><p>在Elasticsearch（ES）的倒排索引中，<code>Term Index</code>（有时也称为前缀索引或加速索引）包含了<strong>倒排索引中词条（terms）的前缀</strong>，而不是完整的词条本身。其主要目的是为了加速词条的查找过程。</p></li></ul><h3 id="倒排列表" tabindex="-1">倒排列表 <a class="header-anchor" href="#倒排列表" aria-label="Permalink to &quot;倒排列表&quot;">​</a></h3><p>倒排列表主要包含：</p><ul><li>单词和出现该单词的文档列表。</li><li>记录每个单词在所有文档中的出现次数和所在位置。每条记录又称一个倒排项。</li></ul><p>倒排列表元素数据结构：<code>((DocID;TF;&lt;POS&gt;))</code></p><ul><li>DocID：出现某单词的文档ID</li><li>TF(Term Frequency)：单词在该文档中出现的次数</li><li>POS：单词在文档中的位置</li></ul><hr><p>假设有下面单个文档</p><table tabindex="0"><thead><tr><th>内容</th><th></th></tr></thead><tbody><tr><td>文档1</td><td>百度的年度目标</td></tr><tr><td>文档2</td><td>AI技术生态部的年度目标</td></tr><tr><td>文档3</td><td>AI市场的年度目标</td></tr></tbody></table><p>则他们生成的倒排索引</p><table tabindex="0"><thead><tr><th>单词ID</th><th>单词</th><th>逆向文档频率</th><th>倒排列表(DocID;TF;)</th></tr></thead><tbody><tr><td>1</td><td>目标</td><td>3</td><td>(1;1;&lt;3&gt;),(2;1;&lt;5&gt;),(3;1;&lt;4&gt;)</td></tr><tr><td>2</td><td>年度</td><td>3</td><td>(1;1;&lt;2&gt;),(2;1;&lt;4&gt;),(3;1;&lt;3&gt;)</td></tr><tr><td>3</td><td>AI</td><td>2</td><td>(2;1;&lt;1&gt;),(3;1;&lt;1&gt;)</td></tr><tr><td>4</td><td>技术</td><td>1</td><td>(2;1;&lt;2&gt;)</td></tr><tr><td>5</td><td>生态</td><td>1</td><td>(2;1;&lt;3&gt;)</td></tr><tr><td>6</td><td>市场</td><td>1</td><td>(3;1;&lt;2&gt;)</td></tr></tbody></table><p>比如单词“年度”，单词ID为2，在三个文档中出现过，所以逆向文档频率为3，同时倒排索引中的元素也有三个：<code>(1;1;&lt;2&gt;),(2;1;&lt;4&gt;),(3;1;&lt;3&gt;)</code>。</p><p>拿第一个元素<code>(1;1;&lt;2&gt;)</code>进行说明，它表示“年度”再文档ID为1的文档中出现过1次，出现的位置是第二个单词。</p><h2 id="参考链接" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接" aria-label="Permalink to &quot;参考链接&quot;">​</a></h2><ul><li><a href="https://lanffy.github.io/2019/05/10/Inverted-Index-In-Elasticsearch" target="_blank" rel="noreferrer">Elasticsearch源码解读六：ES中的倒排索引</a></li><li><a href="https://zhuanlan.zhihu.com/p/195812446" target="_blank" rel="noreferrer">ElasticSearch 索引 VS MySQL 索引</a></li><li><a href="https://blog.csdn.net/andy_wcl/article/details/81631609" target="_blank" rel="noreferrer">Elasticsearch系列——（1.1）倒排索引原理</a></li></ul>',44)]))}const u=a(d,[["render",p]]);export{g as __pageData,u as default};
