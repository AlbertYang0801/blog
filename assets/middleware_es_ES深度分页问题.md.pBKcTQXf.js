import{_ as a,c as s,o as l,aM as t}from"./chunks/framework.Du1sph90.js";const m=JSON.parse('{"title":"ES深度分页问题","description":"","frontmatter":{},"headers":[],"relativePath":"middleware/es/ES深度分页问题.md","filePath":"middleware/es/ES深度分页问题.md","lastUpdated":1752827238000}'),i={name:"middleware/es/ES深度分页问题.md"};function p(r,e,o,n,d,c){return l(),s("div",null,e[0]||(e[0]=[t('<h1 id="es深度分页问题" tabindex="-1">ES深度分页问题 <a class="header-anchor" href="#es深度分页问题" aria-label="Permalink to &quot;ES深度分页问题&quot;">​</a></h1><h2 id="from-to分页" tabindex="-1">from+to分页 <a class="header-anchor" href="#from-to分页" aria-label="Permalink to &quot;from+to分页&quot;">​</a></h2><p>es在查询时候默认使用的是分页查询，单次只会返回10条数据。</p><p>可以指定size。</p><p><img src="https://s2.loli.net/2025/06/26/ESd9BlDPsabtgTr.png" alt="image.png" loading="lazy"></p><ul><li><p>查询要求默认 from+size 的结果必须不超过10000。</p><p>可以通过修改配置</p><div class="language-java vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;index.max_result_window&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;20000&quot;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>限制单词查询满足条件的结果窗口的大小，由from+size共同决定。</p><p>因为es是先将数据全查出来再做分页，这样做是为了限制内存的消耗。</p><hr><p>因为es查询场景复杂，需要先根据条件过滤出符合的数据发给协调节点。由协调节点进行分页操作。</p><p>整个过程将查出来的数据放到了内存中，再去操作。</p><aside> 💡 <p>改配置只能解决一时的问题，当索引的数据量持续增长时，在查询全量数据时很容易把内存吃完。</p></aside></li></ul><h2 id="scroll深度分页" tabindex="-1">Scroll深度分页 <a class="header-anchor" href="#scroll深度分页" aria-label="Permalink to &quot;Scroll深度分页&quot;">​</a></h2><p><a href="https://flowus.cn/cfa70242-873e-445f-b27a-19c273393fd4" target="_blank" rel="noreferrer">es滚动查询-Scroll</a></p><p><em>使用游标查询可以分批查，不用把数据全量加载到内存中。</em></p><ul><li><p>初始化滚动查询</p><p>首次发出滚动查询请求后，es会执行查询并返回第一批结果，和游标ID - ScrollId。</p></li><li><p>存储上下文</p><p>根据滚动查询，创建上下文保存到内存中，标志查询的环境和数据快照的版本，记录es接下来要从哪里查数据。</p></li><li><p>分批获取结果</p><p>根据ScrollId获取上下文，然后按照顺序接着往下读，直到所有符合条件数据全都返回。</p></li></ul><blockquote><p>虽然上下文在内存中保存，但并不是将所有数据加载到内存中。每次滚动请求仅返回请求的数量，而剩余的数据仍然存储在磁盘上。这样可以避免因大量数据而导致的内存溢出问题，同时也保证了高效率和低延迟的查询响应。</p></blockquote>',11)]))}const u=a(i,[["render",p]]);export{m as __pageData,u as default};
