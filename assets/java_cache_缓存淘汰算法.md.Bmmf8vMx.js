import{_ as t,c as e,o as r,ag as p}from"./chunks/framework.D7pKEi_Q.js";const u=JSON.parse('{"title":"缓存淘汰算法","description":"","frontmatter":{},"headers":[],"relativePath":"java/cache/缓存淘汰算法.md","filePath":"java/cache/缓存淘汰算法.md"}'),o={name:"java/cache/缓存淘汰算法.md"};function l(s,a,n,i,c,h){return r(),e("div",null,a[0]||(a[0]=[p('<h1 id="缓存淘汰算法" tabindex="-1">缓存淘汰算法 <a class="header-anchor" href="#缓存淘汰算法" aria-label="Permalink to &quot;缓存淘汰算法&quot;">​</a></h1><h2 id="fifo-先进先出" tabindex="-1">FIFO-先进先出 <a class="header-anchor" href="#fifo-先进先出" aria-label="Permalink to &quot;FIFO-先进先出&quot;">​</a></h2><p><img src="https://s2.loli.net/2025/05/29/sBnDWI6qKlCapc1.png" alt=""></p><p>比较简单，不够灵活。</p><p>没有跟缓存使用频次和时间等维度联系起来。</p><h2 id="lru-最近最少使用" tabindex="-1">LRU-最近最少使用 <a class="header-anchor" href="#lru-最近最少使用" aria-label="Permalink to &quot;LRU-最近最少使用&quot;">​</a></h2><p>核心思想是<strong>最近使用的时间</strong>。比如最近一小时以内使用缓存的时间。</p><p><img src="https://s2.loli.net/2025/05/29/pIrVCw8Q2GzuUoO.png" alt=""></p><p>根据数据的历史访问记录来淘汰数据，淘汰最久未被使用的数据。</p><p>基于<strong>如果数据最近被访问过，那么将来访问的记录会更高</strong>。优先淘汰最久未被使用的冷数据。</p><h2 id="lfu-最近最不常用" tabindex="-1">LFU-最近最不常用 <a class="header-anchor" href="#lfu-最近最不常用" aria-label="Permalink to &quot;LFU-最近最不常用&quot;">​</a></h2><p>核心思想是最近使用的次数。比如最近一小时内使用缓存的次数。</p><p><img src="https://s2.loli.net/2025/05/29/tNSXLjZzckpP4f9.png" alt=""></p><p>LFU能够提高热点数据的命中率。</p><p>但是当缓存中数据都是热点数据的时候，将失去该特性。</p><p><strong>单纯的LFU存在缺陷</strong>。</p><p>比如目前缓存中都是热点数据，新加进来的缓存没有被访问过，就会被基于访问次数的LFU淘汰。导致新缓存无效。</p><blockquote><p>可以为新缓存设置一个中位数的访问次数，防止缓存直接被淘汰。</p></blockquote><h2 id="slru-分段最近最少使用" tabindex="-1">SLRU- 分段最近最少使用 <a class="header-anchor" href="#slru-分段最近最少使用" aria-label="Permalink to &quot;SLRU- 分段最近最少使用&quot;">​</a></h2><p>LRU算法存在个问题，就是如果元素只被访问一次的情况下，很可能被其它元素挤出去。</p><p>比如遇到列表遍历这种写入缓存，很可能把大量缓存挤出去，留下一堆很可能不会再访问的元素在缓存中，导致缓存命中率下降。</p><h3 id="slru设计" tabindex="-1">SLRU设计 <a class="header-anchor" href="#slru设计" aria-label="Permalink to &quot;SLRU设计&quot;">​</a></h3><p>SLRU将缓存分为两段，一段是淘汰段，一段是保护段。两段都基于LRU算法进行淘汰。</p><p>访问过一次的元素在访问第二次的时候会放入保护段。</p><p>淘汰元素时候只会在淘汰段淘汰。保护段淘汰的元素进入淘汰段。这样能有效保护数据不会被只访问一次的数据给淘汰。</p><p><img src="https://s2.loli.net/2025/05/29/oFaKrbBGLn8xTvN.png" alt=""></p>',26)]))}const _=t(o,[["render",l]]);export{u as __pageData,_ as default};
