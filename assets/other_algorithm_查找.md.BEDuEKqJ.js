import{_ as t,c as e,o as l,aM as i}from"./chunks/framework.Du1sph90.js";const g=JSON.parse('{"title":"查找","description":"","frontmatter":{},"headers":[],"relativePath":"other/algorithm/查找.md","filePath":"other/algorithm/查找.md","lastUpdated":1752827268000}'),p={name:"other/algorithm/查找.md"};function o(r,a,n,s,h,d){return l(),e("div",null,a[0]||(a[0]=[i('<h1 id="查找" tabindex="-1">查找 <a class="header-anchor" href="#查找" aria-label="Permalink to &quot;查找&quot;">​</a></h1><p><img src="https://s2.loli.net/2025/07/18/tX6iv8zVu1cOgHE.png" alt="image.png" loading="lazy"></p><h2 id="静态查找表" tabindex="-1">静态查找表 <a class="header-anchor" href="#静态查找表" aria-label="Permalink to &quot;静态查找表&quot;">​</a></h2><h3 id="顺序查找" tabindex="-1">顺序查找 <a class="header-anchor" href="#顺序查找" aria-label="Permalink to &quot;顺序查找&quot;">​</a></h3><p>线性表查询，查找效率（n+1)/2</p><p><img src="https://s2.loli.net/2025/07/18/xni6qt8HVGBEPhw.png" alt="image.png" loading="lazy"></p><h3 id="折半查找" tabindex="-1">折半查找 <a class="header-anchor" href="#折半查找" aria-label="Permalink to &quot;折半查找&quot;">​</a></h3><p><img src="https://s2.loli.net/2025/07/18/6QVMsjEY8GrLDxt.png" alt="image.png" loading="lazy"></p><p>二分查找，仅适用于有序的线性表。</p><p>折半查找比较次数最多为 [log2n]+1 次。n=2^x，比如8个元素最多需要3次，对应 8=2^3。</p><p>所以时间复杂度为 O(log2n) 。</p><h3 id="分块查找" tabindex="-1">分块查找 <a class="header-anchor" href="#分块查找" aria-label="Permalink to &quot;分块查找&quot;">​</a></h3><p>特点是<strong>块内无序，但是块间有序</strong>。</p><ul><li>先在索引表确定目标所在块。</li><li>在块内顺序查找。</li></ul><p><img src="https://s2.loli.net/2025/07/18/t7Hbd3Fa6DnifwS.png" alt="image.png" loading="lazy"></p><p>比如索引表或者索引文件。</p><h2 id="哈希表" tabindex="-1">哈希表 <a class="header-anchor" href="#哈希表" aria-label="Permalink to &quot;哈希表&quot;">​</a></h2><p><img src="https://s2.loli.net/2025/07/18/3zcaNUYseZI46oP.png" alt="image.png" loading="lazy"></p><p>按照哈希存储元素到哈希表里。</p><h3 id="哈希冲突解决方式" tabindex="-1">哈希冲突解决方式 <a class="header-anchor" href="#哈希冲突解决方式" aria-label="Permalink to &quot;哈希冲突解决方式&quot;">​</a></h3><p>按照值的哈希值存储会出现哈希冲突的问题，可以通过以下方法解决：</p><ol><li><p>链地址法</p><p>hashmap采用该方法。</p></li><li><p>开放地址法</p><p>按顺序往后存储元素。</p></li><li><p>重复哈希</p><p>重复进行哈希，直到能存成功。</p></li><li><p>建立一个公共溢出区。</p><p>将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p></li></ol>',22)]))}const m=t(p,[["render",o]]);export{g as __pageData,m as default};
