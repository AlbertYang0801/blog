import{_ as a,c as e,o as r,aN as o}from"./chunks/framework.A-MC8nKA.js";const h=JSON.parse('{"title":"AQS","description":"","frontmatter":{},"headers":[],"relativePath":"java/concurrent/single/AQS.md","filePath":"java/concurrent/single/AQS.md","lastUpdated":1751453543000}'),n={name:"java/concurrent/single/AQS.md"};function l(s,t,d,i,p,c){return r(),e("div",null,t[0]||(t[0]=[o('<h1 id="aqs" tabindex="-1">AQS <a class="header-anchor" href="#aqs" aria-label="Permalink to &quot;AQS&quot;">​</a></h1><p><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html" target="_blank" rel="noreferrer">从ReentrantLock的实现看AQS的原理及应用</a></p><p>AQS是一种提供了原子式管理<strong>同步状态</strong>、<strong>阻塞和唤醒线程</strong>功能以及队列模型的简单框架。</p><h2 id="组成" tabindex="-1">组成 <a class="header-anchor" href="#组成" aria-label="Permalink to &quot;组成&quot;">​</a></h2><ol><li><p>共享资源状态维护state。</p><ul><li><p>AQS使用一个<code>volatile</code>修饰的 int 成员变量来表示同步状态，这个状态可以反映锁的当前持有情况。</p><p>例如，当状态为 0 时表示无锁状态，而当状态为非零时表示有锁被占用。</p></li></ul></li><li><p><strong>FIFO 队列实现线程排队</strong>。</p><p>AQS维护了一个FIFO（先入先出）的双向队列，用于<strong>管理等待获取锁的线程</strong>，当一个线程尝试获取锁但失败时，它会进入这个队列并阻塞，直到锁被释放。</p><p><img src="https://s2.loli.net/2025/05/28/RSwyacbWLZl8Ds1.png" alt="image-20250528172108770" loading="lazy"></p></li><li><p><strong>CAS操作实现同步状态修改</strong>。</p><p>AQS使用 compareAndSetState 方法进行<strong>原子操作来修改同步状态</strong>，这个方法通过循环CAS操作来确保对状态变量的更新，如果更新成功，则表示操作成功，否则会重新尝试。</p><p><strong>AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</strong></p></li></ol><h2 id="aqs应用" tabindex="-1">AQS应用 <a class="header-anchor" href="#aqs应用" aria-label="Permalink to &quot;AQS应用&quot;">​</a></h2><ol><li><p><strong>独占锁和共享锁模式</strong></p><p>AQS支持独占锁和共享锁两种模式，独占锁模式下，每次只有一个线程可以获取锁，而共享锁模式下，允许多个线程同时获取锁。</p></li><li><p><strong>条件队列和信号量</strong></p><p>AQS还支持条件队列和信号量等同步机制，这些机制允许线程在等待某些条件（如锁被释放）时阻塞，并在满足条件时被唤醒</p></li></ol><h3 id="juc中的应用场景" tabindex="-1">JUC中的应用场景 <a class="header-anchor" href="#juc中的应用场景" aria-label="Permalink to &quot;JUC中的应用场景&quot;">​</a></h3><p>除了上边 ReentrantLock 的可重入性的应用，AQS 作为并发编程的框架，为很多其他同步工具提供了良好的解决方案。下面列出了JUC中的几种同步工具，大体介绍一下AQS的应用场景：</p><table tabindex="0"><thead><tr><th>同步工具</th><th>同步工具与AQS的关联</th></tr></thead><tbody><tr><td>ReentrantLock</td><td>使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。</td></tr><tr><td>Semaphore</td><td>使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数。</td></tr><tr><td>CountDownLatch</td><td>使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。</td></tr><tr><td>ReentrantReadWriteLock</td><td>使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数。</td></tr><tr><td>ThreadPoolExecutor</td><td>Worker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）。</td></tr></tbody></table><p>自定义同步器在<strong>实现时只需要实现共享资源 state 的获取与释放方式即可</strong>，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），<strong>AQS已经在顶层实现好了。</strong></p>',11)]))}const A=a(n,[["render",l]]);export{h as __pageData,A as default};
